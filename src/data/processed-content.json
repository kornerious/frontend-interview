{
  "theory": [
    {
      "relatedQuestions": [],
      "requiredFor": [],
      "examples": [],
      "content": "#### Execution Context\n\nThe environment where JavaScript code is evaluated and executed. Each context has its own variable environment, scope chain, and `this` value.\n\n![JavaScript Memory Heap and Call Stack](images/js_engine_memory_heap.png)\n\n![JavaScript Event Loop](images/js_engine_execution.png)\n\n![JavaScript Execution Context](images/js_event_loop.png)",
      "tags": [],
      "interviewRelevance": 5,
      "prerequisites": [],
      "relatedTasks": [],
      "complexity": 5,
      "technology": "JavaScript",
      "id": "theory_1749195757850_679",
      "learningPath": "intermediate",
      "title": "JavaScript Engine and Execution Context"
    },
    {
      "tags": [],
      "interviewRelevance": 5,
      "title": "Event Loop and Asynchronous JavaScript",
      "examples": [],
      "requiredFor": [],
      "id": "theory_1749195757850_535",
      "technology": "JavaScript",
      "relatedQuestions": [],
      "prerequisites": [],
      "content": "The Event Loop is a crucial concept in JavaScript that enables non-blocking, asynchronous behavior despite JavaScript being single-threaded. It continuously checks if there are any tasks in the task queue that need to be executed.\n\n**Key Components of JavaScript Runtime:**\n\n1. **Call Stack**: Where function calls are stacked and executed (LIFO - Last In, First Out)\n2. **Web APIs**: Browser APIs (DOM, AJAX, setTimeout, etc.) that run operations asynchronously\n3. **Callback Queue**: Where callbacks from async operations wait to be executed\n4. **Microtask Queue**: Higher priority queue for Promises and mutation observers\n5. **Event Loop**: Constantly checks if the call stack is empty and moves callbacks to it\n\n**Event Loop Algorithm:**\n\n1. Execute code in the call stack until it's empty\n2. Check the microtask queue and execute all tasks there\n3. Render UI updates if needed\n4. Check the callback queue and push the oldest task to the call stack\n5. Repeat\n\n#### Event Loop Detailed Diagrams\n\n![JavaScript Event Loop 7](images/event_loop_6.jpeg)\n\nThe above diagram shows how the Event Loop connects the Call Stack, Web APIs, and Callback Queue.\n\n![JavaScript Event Loop Processing](images/event_loop_1.png)\n\nThis visualization demonstrates how asynchronous operations flow through the JavaScript runtime.\n\n![JavaScript Call Stack 1](images/event_loop_2.jpeg)\n\n![JavaScript Call Stack 2](images/event_loop_3.jpeg)\n\n![JavaScript Call Stack 3](images/event_loop_4.jpeg)\n\n![JavaScript Call Stack 4](images/event_loop_5.jpeg)\n\nThe sequence above shows how functions enter and exit the call stack, and how asynchronous callbacks are processed.\n\n![JavaScript Processing Model](images/event_loop_6.jpeg)\n\n**Common Event Loop Examples:**\n\n```javascript\nconsole.log('Start'); // 1. Runs immediately\n\nsetTimeout(() => {\n  console.log('Timeout callback'); // 4. Runs after stack is empty and delay is complete\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise callback'); // 3. Runs after stack is empty but before timeout\n});\n\nconsole.log('End'); // 2. Runs immediately\n\n// Output order:\n// 'Start'\n// 'End'\n// 'Promise callback' (microtask)\n// 'Timeout callback' (task queue)\n```",
      "learningPath": "intermediate",
      "complexity": 5,
      "relatedTasks": []
    },
    {
      "relatedQuestions": [],
      "prerequisites": [],
      "content": "#### Creational Patterns\n\n**Constructor Pattern**\n```javascript\n// Constructor Pattern\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n  \n  this.sayHello = function() {\n    console.log(`Hello, my name is ${this.name}`);\n  };\n}\n\nconst john = new Person('John', 30);\njohn.sayHello(); // Hello, my name is John\n```\n\n**Factory Pattern**\n```javascript\n// Factory Pattern\nfunction createUser(type) {\n  if (type === 'admin') {\n    return {\n      name: 'Admin',\n      permissions: ['read', 'write', 'delete']\n    };\n  } else if (type === 'user') {\n    return {\n      name: 'User',\n      permissions: ['read']\n    };\n  }\n}\n\nconst admin = createUser('admin');\nconst user = createUser('user');\n```",
      "id": "theory_1749195757850_660",
      "examples": [],
      "requiredFor": [],
      "learningPath": "intermediate",
      "title": "JavaScript Design Patterns - Creational Patterns",
      "complexity": 5,
      "tags": [],
      "interviewRelevance": 5,
      "relatedTasks": [],
      "technology": "JavaScript"
    },
    {
      "relatedTasks": [],
      "requiredFor": [],
      "title": "JavaScript Design Patterns - Creational Patterns",
      "relatedQuestions": [],
      "content": "#### Creational Patterns\n\n**Constructor Pattern**\n```javascript\n// Constructor Pattern\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n  \n  this.sayHello = function() {\n    console.log(`Hello, my name is ${this.name}`);\n  };\n}\n\nconst john = new Person('John', 30);\njohn.sayHello(); // Hello, my name is John\n```\n\n**Factory Pattern**\n```javascript\n// Factory Pattern\nfunction createUser(type) {\n  if (type === 'admin') {\n    return {\n      name: 'Admin',\n      permissions: ['read', 'write', 'delete']\n    };\n  } else if (type === 'user') {\n    return {\n      name: 'User',\n      permissions: ['read']\n    };\n  }\n}\n\nconst admin = createUser('admin');\nconst user = createUser('user');\n```\n\n**Singleton Pattern**\n```javascript\n// Singleton Pattern\nconst Singleton = (function() {\n  let instance;\n  \n  function createInstance() {\n    return {\n      data: [],\n      addItem: function(item) {\n        this.data.push(item);\n      }\n    };\n  }\n  \n  return {\n    getInstance: function() {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return instance;\n    }\n  };\n})();\n\nconst instance1 = Singleton.getInstance();\nconst instance2 = Singleton.getInstance();\n\nconsole.log(instance1 === instance2); // true\n```",
      "technology": "JavaScript",
      "examples": [],
      "id": "theory_1749196196530_14",
      "tags": [],
      "prerequisites": [],
      "learningPath": "intermediate",
      "complexity": 5,
      "interviewRelevance": 5
    },
    {
      "requiredFor": [],
      "relatedQuestions": [],
      "technology": "JavaScript",
      "prerequisites": [],
      "content": "#### Structural Patterns\n\n**Adapter Pattern**\n```javascript\n// Adapter Pattern\nclass OldCalculator {\n  operate(term1, term2, operation) {\n    switch(operation) {\n      case 'add': return term1 + term2;\n      case 'sub': return term1 - term2;\n      default: return NaN;\n    }\n  }\n}\n\nclass NewCalculator {\n  add(term1, term2) {\n    return term1 + term2;\n  }\n  \n  sub(term1, term2) {\n    return term1 - term2;\n  }\n}\n\n// Adapter\nclass CalcAdapter {\n  constructor() {\n    this.calc = new NewCalculator();\n  }\n  \n  operate(term1, term2, operation) {\n    switch(operation) {\n      case 'add': return this.calc.add(term1, term2);\n      case 'sub': return this.calc.sub(term1, term2);\n      default: return NaN;\n    }\n  }\n}\n\n// Usage\nconst oldCalc = new OldCalculator();\nconsole.log(oldCalc.operate(10, 5, 'add')); // 15\n\nconst newCalcAdapter = new CalcAdapter();\nconsole.log(newCalcAdapter.operate(10, 5, 'add')); // 15\n```\n\n**Decorator Pattern**\n```javascript\n// Decorator Pattern\nfunction Coffee() {\n  this.cost = function() {\n    return 5;\n  };\n}\n\nfunction Milk(coffee) {\n  const cost = coffee.cost();\n  coffee.cost = function() {\n    return cost + 1;\n  };\n}\n\nfunction Whip(coffee) {\n  const cost = coffee.cost();\n  coffee.cost = function() {\n    return cost + 2;\n  };\n}\n\nfunction Vanilla(coffee) {\n  const cost = coffee.cost();\n  coffee.cost = function() {\n    return cost + 3;\n  };\n}\n\nconst coffee = new Coffee();\nMilk(coffee);\nWhip(coffee);\nVanilla(coffee);\nconsole.log(coffee.cost()); // 11\n```",
      "id": "theory_1749196196530_499",
      "learningPath": "intermediate",
      "title": "JavaScript Design Patterns - Structural Patterns",
      "relatedTasks": [],
      "interviewRelevance": 5,
      "examples": [],
      "tags": [],
      "complexity": 5
    },
    {
      "technology": "JavaScript",
      "examples": [],
      "prerequisites": [],
      "requiredFor": [],
      "title": "JavaScript Design Patterns - Behavioral Patterns",
      "relatedTasks": [],
      "learningPath": "intermediate",
      "interviewRelevance": 5,
      "complexity": 5,
      "id": "theory_1749196196530_306",
      "content": "#### Behavioral Patterns\n\n**Observer Pattern**\n```javascript\n// Observer Pattern\nclass Subject {\n  constructor() {\n    this.observers = [];\n  }\n  \n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n  \n  unsubscribe(observer) {\n    this.observers = this.observers.filter(obs => obs !== observer);\n  }\n  \n  notify(data) {\n    this.observers.forEach(observer => observer.update(data));\n  }\n}\n\nclass Observer {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  update(data) {\n    console.log(`${this.name} received: ${data}`);\n  }\n}\n\nconst subject = new Subject();\nconst observer1 = new Observer('Observer 1');\nconst observer2 = new Observer('Observer 2');\n\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\n\nsubject.notify('Hello Observers!');\n// Observer 1 received: Hello Observers!\n// Observer 2 received: Hello Observers!\n```",
      "tags": [],
      "relatedQuestions": []
    }
  ],
  "questions": [
    {
      "question": "Explain the order of execution in the following code and why:\n\n```javascript\nconsole.log('1');\nsetTimeout(() => console.log('2'), 0);\nPromise.resolve().then(() => console.log('3'));\nconsole.log('4');\n```",
      "evaluationCriteria": [],
      "answer": "The output will be: 1, 4, 3, 2",
      "prerequisites": [],
      "complexity": 5,
      "id": "question_1749195757850_208",
      "level": "medium",
      "options": [],
      "example": "",
      "learningPath": "intermediate",
      "type": "theory",
      "topic": "General",
      "analysisPoints": [],
      "interviewFrequency": 5,
      "keyConcepts": [],
      "tags": []
    },
    {
      "prerequisites": [],
      "interviewFrequency": 5,
      "topic": "General",
      "options": [],
      "complexity": 5,
      "id": "question_1749195757850_365",
      "question": "What is the difference between the Constructor Pattern and Factory Pattern in JavaScript?",
      "level": "medium",
      "type": "theory",
      "evaluationCriteria": [],
      "answer": "Constructor Pattern uses the 'new' keyword and 'this' to create objects, while Factory Pattern returns objects from a function without 'new'.",
      "tags": [],
      "learningPath": "intermediate",
      "keyConcepts": [],
      "analysisPoints": [],
      "example": ""
    },
    {
      "type": "theory",
      "topic": "General",
      "evaluationCriteria": [],
      "answer": "Call Stack (executes code), Web APIs (handle async operations), Callback Queue (holds callbacks), Microtask Queue (holds promises), and Event Loop (coordinates execution).",
      "tags": [],
      "learningPath": "intermediate",
      "analysisPoints": [],
      "id": "question_1749195757850_924",
      "question": "What are the key components of the JavaScript runtime environment and how do they interact?",
      "level": "medium",
      "complexity": 5,
      "prerequisites": [],
      "interviewFrequency": 5,
      "keyConcepts": [],
      "options": [],
      "example": ""
    },
    {
      "type": "theory",
      "level": "medium",
      "keyConcepts": [],
      "interviewFrequency": 5,
      "tags": [],
      "evaluationCriteria": [],
      "answer": "Singleton ensures only one instance of a class exists throughout the application, while Factory creates multiple instances of different types based on input parameters.",
      "id": "question_1749196196530_45",
      "prerequisites": [],
      "example": "",
      "topic": "General",
      "complexity": 5,
      "learningPath": "intermediate",
      "analysisPoints": [],
      "options": [],
      "question": "What is the main difference between the Singleton pattern and the Factory pattern?"
    },
    {
      "analysisPoints": [],
      "question": "How does the Adapter pattern help with code compatibility?",
      "keyConcepts": [],
      "tags": [],
      "id": "question_1749196196530_722",
      "evaluationCriteria": [],
      "learningPath": "intermediate",
      "level": "medium",
      "topic": "General",
      "prerequisites": [],
      "example": "",
      "options": [],
      "interviewFrequency": 5,
      "answer": "The Adapter pattern allows incompatible interfaces to work together by creating a wrapper that translates one interface to another.",
      "complexity": 5,
      "type": "theory"
    },
    {
      "example": "",
      "interviewFrequency": 5,
      "evaluationCriteria": [],
      "complexity": 5,
      "options": [],
      "learningPath": "intermediate",
      "analysisPoints": [],
      "id": "question_1749196196530_464",
      "prerequisites": [],
      "question": "In the Observer pattern, what happens when you call notify() on the Subject?",
      "answer": "The notify() method calls the update() method on all registered observers, passing the data to each observer.",
      "type": "theory",
      "tags": [],
      "topic": "General",
      "level": "medium",
      "keyConcepts": []
    }
  ],
  "tasks": [
    {
      "complexity": 5,
      "tags": [],
      "interviewRelevance": 5,
      "solutionCode": "function predictExecutionOrder() {\n  const order = [];\n  \n  // Synchronous code executes first\n  order.push('A');\n  order.push('D');\n  \n  // Microtasks (Promises) execute next\n  order.push('C');\n  \n  // Macrotasks (setTimeout) execute last\n  order.push('B');\n  \n  return order;\n}\n\n// Alternative implementation that actually runs the code:\nfunction actualExecutionOrder() {\n  return new Promise(resolve => {\n    const order = [];\n    const originalLog = console.log;\n    \n    console.log = (msg) => order.push(msg);\n    \n    console.log('A');\n    setTimeout(() => {\n      console.log('B');\n      setTimeout(() => {\n        console.log = originalLog;\n        resolve(order);\n      }, 0);\n    }, 0);\n    Promise.resolve().then(() => console.log('C'));\n    console.log('D');\n  });\n}",
      "title": "Implement Event Loop Execution Order Predictor",
      "timeEstimate": 30,
      "description": "Create a function that predicts the execution order of mixed synchronous and asynchronous JavaScript code.",
      "testCases": [
        "Should return ['A', 'D', 'C', 'B'] for the given code",
        "Synchronous code should execute first",
        "Promise callbacks should execute before setTimeout callbacks"
      ],
      "id": "task_1749195757850_572",
      "hints": [],
      "prerequisites": [],
      "difficulty": "medium",
      "relatedConcepts": [],
      "startingCode": "// Your code here",
      "learningPath": "intermediate"
    },
    {
      "prerequisites": [],
      "difficulty": "medium",
      "description": "Create a flexible user factory that combines Factory and Builder patterns to create users with different roles and configurations.",
      "learningPath": "intermediate",
      "complexity": 5,
      "testCases": [
        "Should create different user types with appropriate permissions",
        "Should support method chaining for configuration",
        "Should throw error for invalid user type or missing required fields",
        "Should include configuration options in created user object"
      ],
      "id": "task_1749195757850_891",
      "tags": [],
      "interviewRelevance": 5,
      "timeEstimate": 30,
      "hints": [],
      "title": "Advanced User Factory with Builder Pattern",
      "solutionCode": "class UserFactory {\n  constructor() {\n    this.config = {\n      theme: 'light',\n      language: 'en',\n      notifications: true\n    };\n  }\n  \n  createUser(type, name, email) {\n    if (!name || !email) {\n      throw new Error('Name and email are required');\n    }\n    \n    const baseUser = {\n      id: Math.random().toString(36).substr(2, 9),\n      name,\n      email,\n      createdAt: new Date().toISOString(),\n      isActive: true,\n      ...this.config\n    };\n    \n    const userTypes = {\n      admin: {\n        type: 'admin',\n        permissions: ['read', 'write', 'delete', 'manage'],\n        role: 'administrator'\n      },\n      moderator: {\n        type: 'moderator',\n        permissions: ['read', 'write', 'moderate'],\n        role: 'moderator'\n      },\n      user: {\n        type: 'user',\n        permissions: ['read', 'write'],\n        role: 'user'\n      },\n      guest: {\n        type: 'guest',\n        permissions: ['read'],\n        role: 'guest'\n      }\n    };\n    \n    if (!userTypes[type]) {\n      throw new Error('Invalid user type');\n    }\n    \n    return { ...baseUser, ...userTypes[type] };\n  }\n  \n  withTheme(theme) {\n    this.config.theme = theme;\n    return this;\n  }\n  \n  withLanguage(language) {\n    this.config.language = language;\n    return this;\n  }\n  \n  withNotifications(enabled) {\n    this.config.notifications = enabled;\n    return this;\n  }\n  \n  reset() {\n    this.config = {\n      theme: 'light',\n      language: 'en',\n      notifications: true\n    };\n    return this;\n  }\n}",
      "relatedConcepts": [],
      "startingCode": "// Your code here"
    },
    {
      "id": "task_1749196196530_900",
      "startingCode": "// Your code here",
      "description": "Create a Singleton logger that can be configured with different log levels and output formats.",
      "complexity": 5,
      "interviewRelevance": 5,
      "tags": [],
      "relatedConcepts": [],
      "timeEstimate": 30,
      "learningPath": "intermediate",
      "solutionCode": "class Logger {\n  constructor() {\n    if (Logger.instance) {\n      return Logger.instance;\n    }\n    \n    this.logLevel = 'INFO';\n    this.format = 'simple';\n    this.levels = {\n      DEBUG: 0,\n      INFO: 1,\n      WARN: 2,\n      ERROR: 3\n    };\n    \n    Logger.instance = this;\n    return this;\n  }\n  \n  static getInstance() {\n    if (!Logger.instance) {\n      Logger.instance = new Logger();\n    }\n    return Logger.instance;\n  }\n  \n  configure(options = {}) {\n    if (options.logLevel) {\n      this.logLevel = options.logLevel;\n    }\n    if (options.format) {\n      this.format = options.format;\n    }\n    return this;\n  }\n  \n  shouldLog(level) {\n    return this.levels[level] >= this.levels[this.logLevel];\n  }\n  \n  formatMessage(level, message) {\n    const timestamp = new Date().toISOString();\n    \n    switch (this.format) {\n      case 'detailed':\n        return `[${timestamp}] ${level}: ${message}`;\n      case 'json':\n        return JSON.stringify({ timestamp, level, message });\n      default:\n        return `${level}: ${message}`;\n    }\n  }\n  \n  log(level, message) {\n    if (this.shouldLog(level)) {\n      console.log(this.formatMessage(level, message));\n    }\n  }\n  \n  debug(message) {\n    this.log('DEBUG', message);\n  }\n  \n  info(message) {\n    this.log('INFO', message);\n  }\n  \n  warn(message) {\n    this.log('WARN', message);\n  }\n  \n  error(message) {\n    this.log('ERROR', message);\n  }\n}\n\n// Usage:\n// const logger = Logger.getInstance();\n// logger.configure({ logLevel: 'DEBUG', format: 'detailed' });\n// logger.info('Application started');\n// logger.error('Something went wrong');",
      "hints": [],
      "prerequisites": [],
      "title": "Implement a Configurable Singleton Logger",
      "testCases": [
        "Should return the same instance when called multiple times",
        "Should respect log level filtering (DEBUG messages shouldn't show when level is INFO)",
        "Should format messages according to the configured format",
        "Should include timestamps in detailed and JSON formats"
      ],
      "difficulty": "medium"
    },
    {
      "interviewRelevance": 5,
      "title": "Build a Plugin System using Decorator Pattern",
      "id": "task_1749196196530_491",
      "description": "Create a plugin system for a text processor that uses the Decorator pattern to add features dynamically.",
      "tags": [],
      "testCases": [
        "Should apply single decorator transformation correctly",
        "Should chain multiple decorators in correct order",
        "Should handle empty or whitespace-only text",
        "Should count words correctly including edge cases",
        "Should allow fluent interface chaining with factory function"
      ],
      "startingCode": "// Your code here",
      "relatedConcepts": [],
      "difficulty": "medium",
      "solutionCode": "class TextProcessor {\n  constructor(text) {\n    this.text = text;\n  }\n  \n  process() {\n    return this.text;\n  }\n}\n\nclass TextDecorator {\n  constructor(processor) {\n    this.processor = processor;\n  }\n  \n  process() {\n    return this.processor.process();\n  }\n}\n\nclass UppercaseDecorator extends TextDecorator {\n  process() {\n    return super.process().toUpperCase();\n  }\n}\n\nclass LowercaseDecorator extends TextDecorator {\n  process() {\n    return super.process().toLowerCase();\n  }\n}\n\nclass TrimDecorator extends TextDecorator {\n  process() {\n    return super.process().trim();\n  }\n}\n\nclass ReverseDecorator extends TextDecorator {\n  process() {\n    return super.process().split('').reverse().join('');\n  }\n}\n\nclass WordCountDecorator extends TextDecorator {\n  process() {\n    const text = super.process();\n    const wordCount = text.split(/\\s+/).filter(word => word.length > 0).length;\n    return `${text} [Word count: ${wordCount}]`;\n  }\n}\n\nclass PrefixDecorator extends TextDecorator {\n  constructor(processor, prefix) {\n    super(processor);\n    this.prefix = prefix;\n  }\n  \n  process() {\n    return `${this.prefix}${super.process()}`;\n  }\n}\n\n// Usage example:\n// let processor = new TextProcessor('  Hello World  ');\n// processor = new TrimDecorator(processor);\n// processor = new UppercaseDecorator(processor);\n// processor = new WordCountDecorator(processor);\n// console.log(processor.process()); // 'HELLO WORLD [Word count: 2]'\n\n// Factory function for easier chaining\nfunction createTextProcessor(text) {\n  return {\n    processor: new TextProcessor(text),\n    trim() {\n      this.processor = new TrimDecorator(this.processor);\n      return this;\n    },\n    uppercase() {\n      this.processor = new UppercaseDecorator(this.processor);\n      return this;\n    },\n    lowercase() {\n      this.processor = new LowercaseDecorator(this.processor);\n      return this;\n    },\n    reverse() {\n      this.processor = new ReverseDecorator(this.processor);\n      return this;\n    },\n    wordCount() {\n      this.processor = new WordCountDecorator(this.processor);\n      return this;\n    },\n    prefix(text) {\n      this.processor = new PrefixDecorator(this.processor, text);\n      return this;\n    },\n    process() {\n      return this.processor.process();\n    }\n  };\n}",
      "prerequisites": [],
      "learningPath": "intermediate",
      "timeEstimate": 30,
      "hints": [],
      "complexity": 5
    }
  ]
}