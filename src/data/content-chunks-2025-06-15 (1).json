[
  {
    "completed": false,
    "startLine": 0,
    "logicalBlockInfo": {
      "suggestedEndLine": -1
    },
    "questions": [
      {
        "id": "question_event_loop_1",
        "evaluationCriteria": [
          "Understanding of fundamental JavaScript engine components.",
          "Distinguishing between synchronous execution and asynchronous orchestration."
        ],
        "analysisPoints": [
          "The Call Stack is where synchronous function calls are placed and executed.",
          "Web APIs are browser-provided functionalities that handle asynchronous operations.",
          "Microtask Queue holds high-priority asynchronous callbacks.",
          "The Event Loop orchestrates the movement of tasks from queues to the Call Stack, but doesn't execute the code itself."
        ],
        "level": "easy",
        "type": "mcq",
        "keyConcepts": [
          "Call Stack",
          "Synchronous Execution",
          "JavaScript Engine Components"
        ],
        "options": [
          "A. Web APIs",
          "B. Call Stack",
          "C. Microtask Queue",
          "D. Event Loop"
        ],
        "topic": "JavaScript Event Loop Fundamentals",
        "question": "Which component is responsible for executing synchronous JavaScript code?",
        "learningPath": "beginner",
        "prerequisites": [
          "javascript_runtime_event_loop"
        ],
        "answer": "B",
        "tags": [
          "JavaScript",
          "Event Loop",
          "Call Stack"
        ],
        "interviewFrequency": 7,
        "complexity": 2
      },
      {
        "question": "Consider the following code snippet:\n```javascript\nconsole.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise');\n});\n\nconsole.log('End');\n```\nWhat will be the exact output order?",
        "options": [
          "A. Start, Timeout, Promise, End",
          "B. Start, End, Promise, Timeout",
          "C. Start, Promise, Timeout, End",
          "D. End, Start, Promise, Timeout"
        ],
        "topic": "Microtask vs. Macrotask Priority",
        "example": "\n```javascript\nconsole.log('Start');\nsetTimeout(() => console.log('Timeout'), 0);\nPromise.resolve().then(() => console.log('Promise'));\nconsole.log('End');\n```",
        "level": "medium",
        "answer": "B",
        "keyConcepts": [
          "Event Loop",
          "Microtask Queue",
          "Macrotask Queue",
          "Asynchronous Execution Order"
        ],
        "analysisPoints": [
          "Synchronous code ('Start', 'End') executes first.",
          "Promises are microtasks and are prioritized over `setTimeout` callbacks (macrotasks).",
          "The Event Loop processes all microtasks before moving to the next macrotask."
        ],
        "complexity": 5,
        "prerequisites": [
          "javascript_runtime_event_loop"
        ],
        "tags": [
          "JavaScript",
          "Event Loop",
          "Promises",
          "setTimeout",
          "Asynchronous"
        ],
        "learningPath": "intermediate",
        "interviewFrequency": 8,
        "type": "mcq",
        "id": "question_event_loop_2",
        "evaluationCriteria": [
          "Ability to correctly predict the execution order of synchronous and asynchronous code.",
          "Understanding the priority difference between microtasks and macrotasks."
        ]
      },
      {
        "level": "medium",
        "type": "open",
        "id": "question_event_loop_3",
        "analysisPoints": [
          "Correctly identifies Variable Environment, Lexical Environment, and `this` binding.",
          "Provides a clear definition of Lexical Environment.",
          "Explains the concept of the 'outer' lexical environment and its role in scope chain.",
          "Connects Lexical Environment to variable lookup and scoping."
        ],
        "tags": [
          "JavaScript",
          "Execution Context",
          "Scope",
          "Lexical Environment"
        ],
        "interviewFrequency": 7,
        "prerequisites": [
          "javascript_runtime_event_loop"
        ],
        "complexity": 6,
        "learningPath": "intermediate",
        "answer": "An Execution Context is the environment in which JavaScript code is evaluated and executed. Each context has three main components:\n\n1.  **Variable Environment**: This is where `var` variables and function declarations are stored during the 'creation phase' of the execution context. It's essentially the actual memory space for these identifiers.\n2.  **Lexical Environment**: This is a conceptual structure that defines the scope of variables and functions. It's a key-value store of identifier-variable mappings for the current scope and contains a reference to its 'outer' lexical environment. This 'outer' reference allows the JavaScript engine to look up variables in parent scopes if they are not found in the current scope, forming the 'scope chain'. When a variable is accessed, the engine searches the current Lexical Environment, then its outer environment, and so on, until it reaches the global lexical environment.\n3.  **`this` binding**: This determines the value of the `this` keyword within that specific execution context. Its value depends on how the function was called.\n\nThe Lexical Environment is crucial for understanding how JavaScript determines the accessibility of variables and functions (scoping rules). It's built during the parsing phase and dictates where variables are looked up.",
        "evaluationCriteria": [
          "Accuracy of definitions.",
          "Clarity and completeness of explanations.",
          "Demonstrated understanding of interconnections between components."
        ],
        "keyConcepts": [
          "Execution Context",
          "Lexical Environment",
          "Variable Environment",
          "Scope Chain",
          "`this` keyword"
        ],
        "topic": "JavaScript Execution Context Components",
        "question": "Describe the main components of an Execution Context in JavaScript and explain the role of the Lexical Environment."
      },
      {
        "prerequisites": [
          "javascript_runtime_event_loop",
          "dom_manipulation"
        ],
        "type": "open",
        "answer": "Understanding the JavaScript Event Loop is critical for writing performant and responsive frontend applications because JavaScript runs on a single thread (the main thread) in the browser. If this thread is blocked, the UI becomes unresponsive, animations stutter, and user interactions are delayed or ignored.\n\nKey ways understanding the Event Loop helps:\n\n1.  **Non-blocking Operations**: It enables developers to use asynchronous operations (like `fetch`, `setTimeout`, `Promises`, `async/await`) to offload long-running tasks from the main thread. Instead of waiting for these tasks to complete, the main thread can continue processing UI updates and user input, ensuring a smooth user experience.\n2.  **Concurrency Model**: It clarifies the order of execution for asynchronous tasks (synchronous -> microtasks -> macrotasks). This knowledge allows for correct sequencing of operations, especially when dealing with UI updates that depend on asynchronous data.\n3.  **Preventing UI Freezes**: By knowing that the Event Loop only picks up tasks from the queues when the Call Stack is empty, developers can consciously avoid putting computationally intensive or blocking operations directly on the main thread.\n\n**Common Mistake leading to a blocked UI:**\nA common mistake is performing a long, synchronous computation directly on the main thread, blocking the Event Loop from processing any queued tasks (including UI rendering updates or event handlers).\n\n**Example:**\n```javascript\nfunction performHeavyComputation() {\n  let sum = 0;\n  for (let i = 0; i < 1000000000; i++) { // A billion iterations\n    sum += i;\n  }\n  console.log('Computation finished:', sum);\n}\n\nconst button = document.getElementById('myButton');\nbutton.addEventListener('click', () => {\n  console.log('Button clicked!');\n  performHeavyComputation(); // This blocks the main thread\n  console.log('Button click handler finished.');\n});\n\nconsole.log('Application started.');\n// If the user clicks the button, the UI will freeze until performHeavyComputation finishes.\n```\nIn this example, `performHeavyComputation()` is a synchronous CPU-bound task. When `myButton` is clicked, the `click` event's callback is pushed onto the Call Stack. Inside this callback, `performHeavyComputation()` is called, which then entirely occupies the Call Stack. While this function is running, the Event Loop cannot check for other pending tasks (like rendering updates, other user inputs, or `setTimeout` callbacks), leading to a completely frozen UI until the loop completes. The solution would be to move `performHeavyComputation` into a Web Worker or break it into smaller, asynchronous chunks using `setTimeout` or `requestAnimationFrame`.",
        "level": "hard",
        "id": "question_event_loop_4",
        "analysisPoints": [
          "Explains the direct link between Event Loop and UI responsiveness (single-threaded nature).",
          "Lists benefits of understanding Event Loop (non-blocking, concurrency, preventing freezes).",
          "Provides a clear and runnable example of a blocking operation.",
          "Explains *why* the example blocks the UI in terms of the Event Loop.",
          "Suggests potential solutions (Web Workers, chunking)."
        ],
        "keyConcepts": [
          "Event Loop",
          "UI Responsiveness",
          "Single-threaded JavaScript",
          "Blocking operations",
          "Web Workers",
          "Asynchronous Programming"
        ],
        "tags": [
          "JavaScript",
          "Event Loop",
          "Performance",
          "UI",
          "Blocking",
          "Web Workers"
        ],
        "learningPath": "advanced",
        "topic": "Event Loop and UI Responsiveness",
        "interviewFrequency": 9,
        "question": "How does understanding the JavaScript Event Loop help in writing performant and responsive frontend applications? Provide an example of a common mistake related to the Event Loop that can lead to a blocked UI.",
        "complexity": 8,
        "evaluationCriteria": [
          "Depth of understanding of the Event Loop's impact on UI.",
          "Ability to articulate complex concepts clearly.",
          "Provision of a relevant and accurate code example.",
          "Correctly identifying the cause of UI blocking.",
          "Suggesting appropriate solutions."
        ]
      },
      {
        "answer": "LIFO stands for 'Last In, First Out'. In the context of the Call Stack, it means that the last function pushed onto the stack is the first one to be executed and popped off. When a function calls another function, the new function is pushed onto the top of the stack. Once that inner function completes, it's popped off, and execution returns to the function below it on the stack.",
        "question": "What does LIFO stand for in the context of the Call Stack, and what does it mean?",
        "level": "easy",
        "evaluationCriteria": [
          "Correctness of definition and explanation."
        ],
        "tags": [
          "JavaScript",
          "Call Stack"
        ],
        "interviewFrequency": 6,
        "prerequisites": [
          "javascript_runtime_event_loop"
        ],
        "type": "flashcard",
        "complexity": 3,
        "analysisPoints": [
          "Correctly defines LIFO.",
          "Explains its application to the Call Stack (function calls and returns)."
        ],
        "topic": "Call Stack Operations",
        "keyConcepts": [
          "Call Stack",
          "LIFO",
          "Function Execution"
        ],
        "learningPath": "beginner",
        "id": "question_event_loop_5"
      }
    ],
    "tasks": [
      {
        "interviewRelevance": 9,
        "startingCode": "function runEventLoopChallenge() {\n  console.log('A: Sync Start');\n\n  setTimeout(() => {\n    console.log('B: Macrotask 1 (setTimeout 0ms)');\n    Promise.resolve().then(() => {\n      console.log('C: Microtask inside Macrotask');\n    });\n  }, 0);\n\n  Promise.resolve().then(() => {\n    console.log('D: Microtask 1');\n    setTimeout(() => {\n      console.log('E: Macrotask inside Microtask');\n    }, 0);\n  });\n\n  setTimeout(() => {\n    console.log('F: Macrotask 2 (setTimeout 0ms)');\n  }, 0);\n\n  Promise.resolve().then(() => {\n    console.log('G: Microtask 2');\n  });\n\n  console.log('H: Sync End');\n}\n\nrunEventLoopChallenge();",
        "description": "\nGiven a JavaScript code snippet involving synchronous code, `setTimeout` (macrotask), and `Promise` (microtask), your task is to predict the exact order of `console.log` statements. Then, run the code to verify your prediction and explain any discrepancies based on your understanding of the Event Loop, Call Stack, Microtask Queue, and Macrotask Queue.\n\n**Requirements:**\n1.  Analyze the provided `startingCode`.\n2.  Write down your predicted output order.\n3.  Run the code in a browser console or Node.js environment.\n4.  Compare your prediction with the actual output.\n5.  In the `solutionCode` (or a comment within), provide a step-by-step explanation of how the Event Loop processes the code to produce the observed output, explicitly mentioning the Call Stack, Microtask Queue, and Macrotask Queue at each significant step.\n",
        "complexity": 7,
        "title": "Predict Asynchronous Execution Order",
        "prerequisites": [
          "javascript_runtime_event_loop"
        ],
        "id": "task_event_loop_prediction",
        "relatedConcepts": [
          "call_stack",
          "microtask_queue",
          "macrotask_queue"
        ],
        "timeEstimate": 30,
        "tags": [
          "JavaScript",
          "Event Loop",
          "Asynchronous",
          "Promises",
          "setTimeout",
          "Execution Order"
        ],
        "hints": [
          "Remember that synchronous code always runs to completion first.",
          "The Microtask Queue is always emptied before the Event Loop picks up *any* task from the Macrotask Queue.",
          "A new microtask generated within a macrotask will run immediately after that macrotask completes, before the *next* macrotask."
        ],
        "solutionCode": "function runEventLoopChallenge() {\n  console.log('A: Sync Start');\n\n  setTimeout(() => {\n    console.log('B: Macrotask 1 (setTimeout 0ms)');\n    Promise.resolve().then(() => {\n      console.log('C: Microtask inside Macrotask');\n    });\n  }, 0);\n\n  Promise.resolve().then(() => {\n    console.log('D: Microtask 1');\n    setTimeout(() => {\n      console.log('E: Macrotask inside Microtask');\n    }, 0);\n  });\n\n  setTimeout(() => {\n    console.log('F: Macrotask 2 (setTimeout 0ms)');\n  }, 0);\n\n  Promise.resolve().then(() => {\n    console.log('G: Microtask 2');\n  });\n\n  console.log('H: Sync End');\n}\n\nrunEventLoopChallenge();\n\n// Predicted/Actual Output and Explanation:\n// Output: A, H, D, G, B, C, F, E\n\n/*\nDetailed Step-by-Step Explanation:\n\n1.  **Initial Execution (Synchronous Phase):**\n    *   `runEventLoopChallenge()` is called and pushed to Call Stack.\n    *   `console.log('A: Sync Start')` executes. Output: `A`.\n    *   `setTimeout` (for 'B') is encountered. Its callback (`() => { console.log('B'); ... }`) is registered with the Web API. After 0ms, it's moved to the Macrotask Queue.\n        *   Macrotask Queue: [callback B]\n    *   `Promise.resolve().then()` (for 'D') is encountered. Its callback (`() => { console.log('D'); ... }`) is immediately moved to the Microtask Queue.\n        *   Microtask Queue: [callback D]\n    *   `setTimeout` (for 'F') is encountered. Its callback (`() => { console.log('F'); }`) is registered with the Web API. After 0ms, it's moved to the Macrotask Queue.\n        *   Macrotask Queue: [callback B, callback F]\n    *   `Promise.resolve().then()` (for 'G') is encountered. Its callback (`() => { console.log('G'); }`) is immediately moved to the Microtask Queue.\n        *   Microtask Queue: [callback D, callback G]\n    *   `console.log('H: Sync End')` executes. Output: `H`.\n    *   `runEventLoopChallenge()` finishes and is popped from Call Stack. Call Stack is now empty.\n\n2.  **Event Loop - Microtask Phase 1:**\n    *   Call Stack is empty, so Event Loop checks Microtask Queue.\n    *   Pulls `callback D` (from `Promise.resolve().then(() => console.log('D'); ...)`).\n    *   `callback D` is pushed to Call Stack.\n    *   `console.log('D: Microtask 1')` executes. Output: `D`.\n    *   Inside `callback D`, `setTimeout` (for 'E') is encountered. Its callback (`() => { console.log('E'); }`) is registered with the Web API and moved to Macrotask Queue (at the end).\n        *   Macrotask Queue: [callback B, callback F, callback E]\n    *   `callback D` finishes and is popped from Call Stack.\n    *   Microtask Queue is not empty.\n    *   Pulls `callback G` (from `Promise.resolve().then(() => console.log('G'))`).\n    *   `callback G` is pushed to Call Stack.\n    *   `console.log('G: Microtask 2')` executes. Output: `G`.\n    *   `callback G` finishes and is popped from Call Stack.\n    *   Microtask Queue is now empty. Call Stack is empty.\n\n3.  **Event Loop - Macrotask Phase 1:**\n    *   Call Stack is empty, Microtask Queue is empty, so Event Loop checks Macrotask Queue.\n    *   Pulls `callback B` (from `setTimeout(() => console.log('B'); ...)`).\n    *   `callback B` is pushed to Call Stack.\n    *   `console.log('B: Macrotask 1 (setTimeout 0ms)')` executes. Output: `B`.\n    *   Inside `callback B`, `Promise.resolve().then()` (for 'C') is encountered. Its callback (`() => { console.log('C'); }`) is immediately moved to the Microtask Queue (which is currently empty).\n        *   Microtask Queue: [callback C]\n    *   `callback B` finishes and is popped from Call Stack.\n\n4.  **Event Loop - Microtask Phase 2 (after a Macrotask):**\n    *   Call Stack is empty, so Event Loop checks Microtask Queue.\n    *   Pulls `callback C` (from `Promise.resolve().then(() => console.log('C'))`).\n    *   `callback C` is pushed to Call Stack.\n    *   `console.log('C: Microtask inside Macrotask')` executes. Output: `C`.\n    *   `callback C` finishes and is popped from Call Stack.\n    *   Microtask Queue is now empty. Call Stack is empty.\n\n5.  **Event Loop - Macrotask Phase 2:**\n    *   Call Stack is empty, Microtask Queue is empty, so Event Loop checks Macrotask Queue.\n    *   Pulls `callback F` (from `setTimeout(() => console.log('F'))`).\n    *   `callback F` is pushed to Call Stack.\n    *   `console.log('F: Macrotask 2 (setTimeout 0ms)')` executes. Output: `F`.\n    *   `callback F` finishes and is popped from Call Stack.\n    *   Macrotask Queue is not empty. Call Stack is empty.\n\n6.  **Event Loop - Macrotask Phase 3:**\n    *   Pulls `callback E` (from `setTimeout(() => console.log('E'))`).\n    *   `callback E` is pushed to Call Stack.\n    *   `console.log('E: Macrotask inside Microtask')` executes. Output: `E`.\n    *   `callback E` finishes and is popped from Call Stack.\n    *   Macrotask Queue is now empty. Call Stack is empty.\n\nExecution ends.\n*/",
        "learningPath": "intermediate",
        "testCases": [
          "Verify synchronous execution order first.",
          "Verify microtasks (Promises) execute before macrotasks (setTimeout) if queued at the same 'tick'.",
          "Verify microtasks generated within a macrotask execute immediately after that macrotask completes, before the next macrotask.",
          "Verify macrotasks generated within a microtask are queued normally and wait for all current microtasks and the current macrotask queue to clear."
        ],
        "difficulty": "medium"
      },
      {
        "testCases": [
          "Run the code in Chrome DevTools or similar.",
          "Set breakpoints at the beginning of the heavy loop, inside the Promise callback, and inside the setTimeout callback.",
          "Observe the Call Stack state at each breakpoint.",
          "Verify that the UI remains blocked during the heavy synchronous loop and unblocks afterwards."
        ],
        "relatedConcepts": [
          "call_stack",
          "microtask_queue",
          "macrotask_queue",
          "web_apis"
        ],
        "timeEstimate": 45,
        "startingCode": "function simulateEventLoop() {\n  console.log('1. Start (Sync)');\n\n  setTimeout(() => {\n    console.log('4. setTimeout callback (Macrotask)');\n  }, 0);\n\n  Promise.resolve().then(() => {\n    console.log('3. Promise callback (Microtask)');\n  });\n\n  // Simulate a blocking operation to see its effect on the UI/Event Loop\n  console.log('2. Starting heavy synchronous task...');\n  let sum = 0;\n  for (let i = 0; i < 100000000; i++) { // A hundred million iterations\n    sum += i;\n  }\n  console.log('2. Heavy task finished (Sync):', sum);\n\n  console.log('5. End (Sync)');\n}\n\nsimulateEventLoop();\n\n// Place debugger; statements and observe the Call Stack in browser dev tools.",
        "learningPath": "intermediate",
        "complexity": 6,
        "difficulty": "medium",
        "hints": [
          "Open your browser's Developer Tools (F12 or Cmd+Option+I).",
          "Go to the 'Sources' tab to see your JavaScript file.",
          "Click on line numbers to set breakpoints, or add `debugger;` statements directly in your code.",
          "Use the 'Step over next function call' (F10) and 'Step into next function call' (F11) buttons to navigate execution.",
          "Pay close attention to the 'Call Stack' panel as you step through the code."
        ],
        "tags": [
          "JavaScript",
          "Event Loop",
          "Debugging",
          "Developer Tools",
          "Performance",
          "Asynchronous"
        ],
        "description": "\nYour task is to write a simple JavaScript program that demonstrates the Event Loop's behavior by logging messages at different stages, and then use your browser's developer tools (debugger) to step through the code and observe the Call Stack, and conceptually trace the queues.\n\n**Requirements:**\n1.  Create a JavaScript file or use a browser's console.\n2.  Write code that includes:\n    *   At least one synchronous `console.log`.\n    *   At least one `setTimeout` with a 0ms delay.\n    *   At least one `Promise.resolve().then()`.\n    *   A synchronous loop that takes a noticeable amount of time (e.g., iterating a large number).\n3.  Place `debugger;` statements strategically to pause execution and inspect the Call Stack.\n4.  Explain, in comments or a separate README, how the debugger helps you confirm the Event Loop's operation (e.g., when the Call Stack becomes empty, when microtasks are processed, when macrotasks are processed).\n\nThis task is less about writing complex code and more about using developer tools to understand runtime behavior.\n",
        "solutionCode": "function simulateEventLoop() {\n  console.log('1. Start (Sync)');\n\n  setTimeout(() => {\n    // debugger; // You can place debugger here to see Call Stack when this runs\n    console.log('4. setTimeout callback (Macrotask)');\n  }, 0);\n\n  Promise.resolve().then(() => {\n    // debugger; // You can place debugger here to see Call Stack when this runs\n    console.log('3. Promise callback (Microtask)');\n  });\n\n  // Simulate a blocking operation to see its effect on the UI/Event Loop\n  console.log('2. Starting heavy synchronous task...');\n  let sum = 0;\n  // debugger; // Place debugger here to see the Call Stack during the loop\n  for (let i = 0; i < 1000000000; i++) { // One billion iterations to clearly block\n    sum += i;\n  }\n  console.log('2. Heavy task finished (Sync):', sum);\n\n  console.log('5. End (Sync)');\n}\n\nsimulateEventLoop();\n\n/*\nExplanation of Debugging Observations:\n\n1.  **Initial synchronous execution (`console.log('1. Start (Sync)');` and the loop):**\n    *   When you start execution, `simulateEventLoop` is on the Call Stack. `console.log` calls are also pushed and popped.\n    *   When the `for` loop executes, you'll see `simulateEventLoop` (and potentially the anonymous context) remain on the Call Stack until the loop completes. During this time, the browser tab might become unresponsive because the main thread is blocked, preventing the Event Loop from processing other tasks.\n    *   `setTimeout` and `Promise.then` callbacks are offloaded to Web APIs and their respective queues *during* this synchronous phase.\n\n2.  **After synchronous code (`console.log('5. End (Sync)');`):**\n    *   Once '5. End (Sync)' is logged, `simulateEventLoop` pops off the Call Stack, and the Call Stack becomes empty.\n    *   This is the critical moment when the Event Loop can step in.\n\n3.  **Microtask Queue processing (`Promise.resolve().then()`):**\n    *   The Event Loop first checks the Microtask Queue. It finds the Promise callback.\n    *   The Promise callback is moved from the Microtask Queue to the Call Stack and executed (`console.log('3. Promise callback (Microtask)');`).\n    *   If you had a `debugger;` inside this callback, you'd see only this callback on the Call Stack (or the global context, depending on exact timing).\n    *   After the Promise callback finishes, it's popped, and the Microtask Queue is checked again (and found empty).\n\n4.  **Macrotask Queue processing (`setTimeout()`):**\n    *   Only after the Microtask Queue is completely empty does the Event Loop check the Macrotask Queue.\n    *   It finds the `setTimeout` callback.\n    *   The `setTimeout` callback is moved from the Macrotask Queue to the Call Stack and executed (`console.log('4. setTimeout callback (Macrotask)');`).\n    *   If you had a `debugger;` inside this callback, you'd see only this callback on the Call Stack.\n    *   After the `setTimeout` callback finishes, it's popped, and the Macrotask Queue is checked again (and found empty).\n\nThis step-by-step observation using `debugger;` visually confirms the Event Loop's prioritization: synchronous code first, then all microtasks, then one macrotask at a time, repeatedly.\n*/",
        "prerequisites": [
          "javascript_runtime_event_loop",
          "debugging_techniques"
        ],
        "interviewRelevance": 8,
        "title": "Simulate Event Loop with Debugging",
        "id": "task_event_loop_visualizer"
      }
    ],
    "displayEndLine": 99,
    "theory": [
      {
        "content": "JavaScript is a single-threaded, non-blocking, asynchronous, and concurrent language. This seemingly contradictory statement is explained by the JavaScript runtime environment, which includes the JavaScript engine, Web APIs, Callback Queues (Task Queues), and the Event Loop.\n\n## JavaScript Engine\nThe JavaScript Engine (e.g., V8 in Chrome, SpiderMonkey in Firefox) is responsible for executing JavaScript code. It comprises:\n\n*   **Memory Heap**: Where memory allocation for variables and objects happens.\n*   **Call Stack**: A LIFO (Last In, First Out) stack that keeps track of the execution context of the currently running function. When a function is called, it's pushed onto the stack. When it returns, it's popped off.\n\n![JavaScript Memory Heap and Call Stack](images/js_engine_memory_heap.png)\n\n## Execution Context\nAn Execution Context is the environment in which JavaScript code is evaluated and executed. Every time a function is called, a new execution context is created and pushed onto the Call Stack. There are two types:\n\n1.  **Global Execution Context (GEC)**: The default context created when the JavaScript file first loads. It's the base context where all global code runs.\n2.  **Function Execution Context (FEC)**: Created whenever a function is called. Each function gets its own FEC.\n\nEach execution context has:\n\n*   **Variable Environment**: Where variables (var, let, const) and function declarations are stored.\n*   **Lexical Environment**: A conceptual structure that defines the scope of variables and functions. It stores identifier-variable mapping for the current scope and a reference to the outer lexical environment, forming the scope chain.\n*   **`this` binding**: The value of the `this` keyword for that context.\n\n![JavaScript Execution Context](images/js_engine_execution.png)\n\n## Event Loop and Asynchronous JavaScript\nSince JavaScript is single-threaded, it can only execute one task at a time. To handle long-running operations (like network requests or timers) without blocking the main thread, JavaScript uses an asynchronous model facilitated by the Event Loop.\n\n**Key Components of JavaScript Runtime for Asynchronous Behavior:**\n\n1.  **Call Stack**: (As described above) Executes synchronous code.\n2.  **Web APIs**: Browser-provided APIs (e.g., `setTimeout`, `fetch`, DOM events like `click`). These are *not* part of the JavaScript engine. They run in the background (often on separate threads managed by the browser).\n3.  **Callback Queue (Task Queue / Macrotask Queue)**: A queue where callbacks from Web APIs (like `setTimeout` callbacks, DOM event handlers, `fetch` response handlers) are placed once their asynchronous operation is complete.\n4.  **Microtask Queue**: A higher-priority queue for callbacks like `Promise.then()`, `Promise.catch()`, `Promise.finally()`, and `MutationObserver` callbacks.\n5.  **Event Loop**: A continuously running process that constantly monitors the Call Stack and the Callback Queues.\n    *   If the Call Stack is empty, it first checks the **Microtask Queue**. If there are microtasks, it moves them (one by one) to the Call Stack until the Microtask Queue is empty.\n    *   Only after the Microtask Queue is empty does the Event Loop check the **Callback Queue (Macrotask Queue)**. If there are macrotasks, it moves the *first* one to the Call Stack for execution. This process repeats.\n\n![JavaScript Event Loop](images/js_event_loop.png)\n\nThis mechanism ensures that synchronous code is always executed first, followed by microtasks, and then macrotasks, allowing non-blocking I/O operations.\n\n## Synchronous vs. Asynchronous Execution Order\nSynchronous code is executed immediately. Asynchronous code is offloaded to Web APIs and their callbacks are queued. Microtasks have priority over macrotasks.\n\n```javascript\nconsole.log('Start'); // Sync\n\nsetTimeout(() => {\n  console.log('setTimeout callback'); // Macrotask\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise callback'); // Microtask\n});\n\nconsole.log('End'); // Sync\n\n// Expected output order:\n// Start\n// End\n// Promise callback\n// setTimeout callback\n```",
        "relatedQuestions": [
          "question_event_loop_1",
          "question_event_loop_2",
          "question_event_loop_3",
          "question_event_loop_4",
          "question_event_loop_5"
        ],
        "learningPath": "intermediate",
        "requiredFor": [
          "promises_async_await",
          "frontend_performance",
          "service_workers"
        ],
        "interviewRelevance": 9,
        "complexity": 7,
        "title": "JavaScript Runtime, Execution Context, and Event Loop",
        "technology": "JavaScript",
        "examples": [
          {
            "title": "Basic Event Loop Flow",
            "language": "javascript",
            "id": "example_event_loop_1",
            "explanation": "This example demonstrates the fundamental order of execution within the JavaScript Event Loop. 'Synchronous 1' and 'Synchronous 2' are part of the main thread and execute immediately. The `Promise.resolve().then()` callback is placed in the Microtask Queue, which is processed before the Macrotask Queue. The `setTimeout` callback, even with a 0ms delay, is a macrotask and waits for the Microtask Queue to be empty and the Call Stack to be free. The output will be: 'Synchronous 1', 'Synchronous 2', 'Promise callback (Microtask)', 'setTimeout callback (Macrotask)'.",
            "code": "console.log('Synchronous 1');\n\nsetTimeout(() => {\n  console.log('setTimeout callback (Macrotask)');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise callback (Microtask)');\n});\n\nconsole.log('Synchronous 2');"
          },
          {
            "code": "console.log('A');\n\nsetTimeout(() => {\n  console.log('B');\n  Promise.resolve().then(() => console.log('C'));\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('D');\n  setTimeout(() => console.log('E'), 0);\n});\n\nconsole.log('F');",
            "language": "javascript",
            "explanation": "This example illustrates a more complex interplay. 'A' and 'F' execute synchronously. Then, the Microtask Queue is checked. The promise in the main scope adds 'D' and then a new setTimeout ('E') to the Macrotask Queue. After all microtasks, the Event Loop processes macrotasks one by one. The first `setTimeout` adds 'B' and then another promise ('C') to the Microtask Queue. 'C' will execute immediately after 'B' because it's a microtask generated within a macrotask. Finally, 'E' executes. The output order is: 'A', 'F', 'D', 'B', 'C', 'E'.",
            "title": "Complex Asynchronous Interaction",
            "id": "example_event_loop_2"
          }
        ],
        "tags": [
          "JavaScript",
          "Asynchronous",
          "Event Loop",
          "Execution Context",
          "Runtime",
          "Concurrency",
          "Web APIs"
        ],
        "relatedTasks": [
          "task_event_loop_prediction",
          "task_event_loop_visualizer"
        ],
        "id": "theory_javascript_runtime_event_loop",
        "prerequisites": [
          "javascript_basics",
          "functions"
        ]
      }
    ],
    "endLine": 100,
    "processedDate": "2025-06-15T08:51:34.730Z",
    "id": "chunk_0_99_1749977494730"
  },
  {
    "logicalBlockInfo": {
      "suggestedEndLine": -1
    },
    "questions": [
      {
        "question": "Predict the exact output of the following JavaScript code snippet and explain your reasoning based on the Event Loop mechanism:\n```typescript\nconsole.log('A');\n\nsetTimeout(() => {\n  console.log('B');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('C');\n});\n\nnew Promise((resolve) => {\n  console.log('D');\n  resolve();\n}).then(() => {\n  console.log('E');\n});\n\nconsole.log('F');\n\nsetTimeout(() => {\n  console.log('G');\n}, 0);\n\nconsole.log('H');\n```",
        "tags": [
          "Event Loop",
          "Asynchronous JavaScript",
          "Promises",
          "setTimeout",
          "Interview Question",
          "Prediction"
        ],
        "type": "code",
        "example": "\n```typescript\n// Provided code for analysis\nconsole.log('A');\n\nsetTimeout(() => {\n  console.log('B');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('C');\n});\n\nnew Promise((resolve) => {\n  console.log('D');\n  resolve();\n}).then(() => {\n  console.log('E');\n});\n\nconsole.log('F');\n\nsetTimeout(() => {\n  console.log('G');\n}, 0);\n\nconsole.log('H');\n```",
        "learningPath": "intermediate",
        "evaluationCriteria": [
          "Accuracy of output prediction.",
          "Clarity and correctness of explanation.",
          "Demonstration of deep understanding of Event Loop mechanics."
        ],
        "level": "medium",
        "keyConcepts": [
          "Event Loop",
          "Call Stack",
          "Microtask Queue",
          "Callback Queue",
          "Promises",
          "setTimeout"
        ],
        "options": [],
        "topic": "Event Loop Execution Order",
        "answer": "The output will be:\n```\nA\nD\nF\nH\nC\nE\nB\nG\n```\n\n**Explanation:**\n1.  **Synchronous Execution:** `console.log('A')`, `console.log('D')` (inside `new Promise`), `console.log('F')`, `console.log('H')` are executed immediately in the Call Stack. The `new Promise` constructor function runs synchronously.\n2.  **Microtask Queue:** After the synchronous code completes, the Event Loop checks the Microtask Queue. The `Promise.resolve().then(() => { console.log('C'); })` callback is added to the microtask queue when the promise is resolved. Similarly, the `.then(() => { console.log('E'); })` callback from the second promise is also added. Since microtasks are processed completely before macrotasks, 'C' and 'E' will be logged.\n3.  **Callback Queue (Macrotask Queue):** After all microtasks are processed, the Event Loop moves to the Callback Queue. The `setTimeout(() => { console.log('B'); }, 0)` and `setTimeout(() => { console.log('G'); }, 0)` callbacks are added to the macrotask queue. They are executed in the order they were added, in separate event loop turns if subsequent microtasks arise, but here they are sequential.",
        "interviewFrequency": 9,
        "analysisPoints": [
          "Understanding of synchronous vs. asynchronous execution.",
          "Correct differentiation between microtasks (Promises) and macrotasks (setTimeout).",
          "Knowledge that `new Promise` constructor runs synchronously.",
          "Ability to trace the Event Loop's priority mechanism (Call Stack -> Microtasks -> Macrotasks)."
        ],
        "prerequisites": [
          "theory_event_loop_fundamentals"
        ],
        "complexity": 8,
        "id": "question_event_loop_order"
      },
      {
        "level": "medium",
        "options": [
          "A. All microtasks in the microtask queue are executed immediately after the call stack is empty, and *before* the browser renders or processes a single task from the macrotask queue.",
          "B. Macrotasks always have higher priority than microtasks and are processed first once the call stack is empty.",
          "C. Microtasks and macrotasks are processed in an alternating fashion, one from each queue, until both are empty.",
          "D. The order of execution between microtasks and macrotasks is non-deterministic and depends on the browser implementation."
        ],
        "topic": "Microtask vs. Macrotask",
        "prerequisites": [
          "theory_event_loop_fundamentals"
        ],
        "interviewFrequency": 8,
        "analysisPoints": [
          "This question tests the core understanding of microtask vs. macrotask priority.",
          "Option A correctly identifies that microtasks are emptied entirely after the call stack before any macrotasks are picked up.",
          "Options B, C, and D are common misconceptions or incorrect statements about the Event Loop's behavior."
        ],
        "keyConcepts": [
          "Microtask Queue",
          "Callback Queue",
          "Event Loop Algorithm",
          "Execution Priority"
        ],
        "question": "Which statement best describes the execution priority difference between microtasks and macrotasks in the JavaScript Event Loop?",
        "tags": [
          "Event Loop",
          "Microtask",
          "Macrotask",
          "Priority",
          "MCQ"
        ],
        "id": "question_microtask_vs_macrotask",
        "answer": "A. All microtasks in the microtask queue are executed immediately after the call stack is empty, and *before* the browser renders or processes a single task from the macrotask queue.",
        "evaluationCriteria": [
          "Understanding of fundamental Event Loop principles.",
          "Ability to distinguish between queue types and their processing order."
        ],
        "example": null,
        "complexity": 6,
        "type": "mcq",
        "learningPath": "intermediate"
      },
      {
        "evaluationCriteria": [
          "Correct and concise definition."
        ],
        "keyConcepts": [
          "Event Loop",
          "Asynchronous JavaScript",
          "Single-threaded"
        ],
        "topic": "Event Loop Definition",
        "tags": [
          "Event Loop",
          "Definition",
          "Flashcard"
        ],
        "answer": "The Event Loop's primary role is to continuously check if the Call Stack is empty. If it is, it moves tasks from the Microtask Queue (highest priority) or Callback Queue (lower priority) to the Call Stack for execution. This mechanism allows JavaScript to perform non-blocking I/O operations and handle asynchronous events despite being single-threaded.",
        "learningPath": "beginner",
        "example": null,
        "options": [],
        "complexity": 4,
        "id": "question_event_loop_definition",
        "prerequisites": [],
        "interviewFrequency": 7,
        "analysisPoints": [
          "Defines the core function of the Event Loop.",
          "Highlights its importance for asynchronous operations in a single-threaded environment."
        ],
        "type": "flashcard",
        "level": "easy",
        "question": "What is the primary role of the JavaScript Event Loop?"
      },
      {
        "prerequisites": [
          "theory_js_design_patterns_creational"
        ],
        "topic": "Constructor vs. Factory Pattern",
        "analysisPoints": [
          "Clear definition and purpose of each pattern.",
          "Appropriate scenarios demonstrating the use case for each.",
          "Accurate comparison of key differences (e.g., `new` keyword, flexibility, abstraction).",
          "Insight into when to prefer one over the other."
        ],
        "learningPath": "intermediate",
        "evaluationCriteria": [
          "Depth of understanding of both patterns.",
          "Ability to articulate their advantages and disadvantages.",
          "Practical application knowledge through scenarios."
        ],
        "answer": "**Constructor Pattern:**\n*   **Definition:** Uses a function with the `new` keyword to create individual instances of an object. Properties and methods are typically attached to `this` or the function's `prototype`.\n*   **Use Case:** Ideal when you need to create multiple instances of the *same type* of object, and you want to ensure that instances share methods (via prototype) for memory efficiency. Good for creating objects with a clear blueprint and consistent structure.\n*   **Scenario:** Creating multiple `User` objects, each with a name, email, and a `greet()` method. All `User` objects will have the same structure and behavior.\n\n**Factory Pattern:**\n*   **Definition:** A function that creates and returns objects, abstracting the instantiation logic. It doesn't necessarily use `new` or directly expose constructors.\n*   **Use Case:** Preferred when the object creation logic is complex, or when you need to create different *types* of objects that share a common interface but have varying implementations or structures based on input parameters. It allows for more flexible and decoupled object creation.\n*   **Scenario:** Creating different types of `Notification` objects (e.g., `EmailNotification`, `SMSNotification`, `PushNotification`). The factory would take a `type` parameter and return the appropriate notification object, hiding the specific constructors.\n\n**Comparison:**\n| Feature           | Constructor Pattern                                   | Factory Pattern                                         |\n| :---------------- | :---------------------------------------------------- | :------------------------------------------------------ |\n| `new` keyword     | Explicitly used                                       | Hidden/Abstracted                                       |\n| Instantiation     | Direct (`new MyConstructor()`)                        | Indirect (`myFactory('type', args)`)                    |\n| Flexibility       | Less flexible; creates instances of a single type     | More flexible; can create various types of objects      |\n| Abstraction       | Less abstraction; client needs to know the constructor| More abstraction; client doesn't need to know constructors|\n| Polymorphism      | Can be achieved with inheritance                      | Naturally supports polymorphic object creation          |\n\n**Preference:**\n*   **Choose Constructor Pattern** when you have a well-defined object blueprint and want to create many similar instances, especially when combined with prototype inheritance for method sharing.\n*   **Choose Factory Pattern** when object creation logic is conditional, complex, or when you want to decouple the client code from the specific object types it creates, promoting more flexible and maintainable code.",
        "complexity": 7,
        "options": [],
        "question": "Compare and contrast the Constructor Pattern and the Factory Pattern in JavaScript. When would you prefer one over the other? Provide a scenario for each.",
        "keyConcepts": [
          "Constructor Pattern",
          "Factory Pattern",
          "Creational Design Patterns",
          "Object Instantiation",
          "Polymorphism",
          "Abstraction"
        ],
        "tags": [
          "Design Patterns",
          "Constructor Pattern",
          "Factory Pattern",
          "Comparison",
          "Open-Ended"
        ],
        "interviewFrequency": 8,
        "type": "open",
        "level": "medium",
        "id": "question_constructor_vs_factory",
        "example": null
      },
      {
        "keyConcepts": [
          "Event Loop",
          "Call Stack",
          "Web APIs",
          "Microtask Queue",
          "Callback Queue"
        ],
        "example": null,
        "analysisPoints": [
          "This question tests the knowledge of the main components of the JavaScript runtime and Event Loop.",
          "The Call Stack, Microtask Queue, and Web APIs are direct components of the Event Loop's operation.",
          "The Global Object (e.g., `window` in browsers, `global` in Node.js) is part of the JavaScript environment but not a *mechanism* of the Event Loop itself."
        ],
        "complexity": 5,
        "tags": [
          "Event Loop",
          "Components",
          "MCQ"
        ],
        "prerequisites": [
          "theory_event_loop_fundamentals"
        ],
        "answer": "B. Global Object",
        "learningPath": "beginner",
        "question": "Which of the following is NOT considered a core component directly involved in the JavaScript Event Loop mechanism as described by the browser's runtime?",
        "interviewFrequency": 7,
        "options": [
          "A. Call Stack",
          "B. Global Object",
          "C. Microtask Queue",
          "D. Web APIs"
        ],
        "topic": "Event Loop Components",
        "level": "easy",
        "id": "question_event_loop_components",
        "type": "mcq",
        "evaluationCriteria": [
          "Accurate identification of Event Loop components."
        ]
      },
      {
        "interviewFrequency": 7,
        "tags": [
          "Constructor Pattern",
          "Prototype",
          "Memory",
          "Inheritance",
          "Open-Ended"
        ],
        "options": [],
        "complexity": 6,
        "keyConcepts": [
          "Constructor Pattern",
          "Prototype",
          "Memory Management",
          "Inheritance",
          "JavaScript Objects"
        ],
        "prerequisites": [
          "theory_js_design_patterns_creational",
          "javascript_prototypes"
        ],
        "analysisPoints": [
          "Explains memory efficiency as a key benefit.",
          "Mentions the implication for inheritance.",
          "Contrasts the behavior of methods on `this` vs. `prototype`."
        ],
        "topic": "Constructor Pattern and Prototype",
        "example": null,
        "learningPath": "intermediate",
        "type": "open",
        "id": "question_constructor_prototype",
        "evaluationCriteria": [
          "Clear and accurate explanation of memory benefits.",
          "Understanding of prototype chain implications."
        ],
        "answer": "Defining methods on the constructor's `prototype` is recommended over defining them directly on `this` inside the constructor function primarily for **memory efficiency** and **inheritance capabilities**.\n\n1.  **Memory Efficiency:** When a method is defined directly on `this` inside the constructor, a *new instance* of that method is created for every object created with the constructor. If you create 100 `Person` objects, and each `Person` has a `sayHello` method defined on `this`, you'll have 100 separate `sayHello` function instances in memory. In contrast, when `sayHello` is defined on `Person.prototype`, all `Person` instances share a *single reference* to that method. This significantly reduces memory consumption, especially for applications with many objects.\n\n2.  **Inheritance:** Methods on the prototype are automatically inherited by instances. This is how JavaScript's classical inheritance model is typically implemented, allowing subclasses to inherit behavior from their parent constructors. If methods are on `this`, they are not automatically part of the prototype chain for inheritance.",
        "question": "In the Constructor Pattern, why is it generally recommended to define methods on the constructor's `prototype` rather than directly on `this` inside the constructor function?",
        "level": "medium"
      },
      {
        "tags": [
          "Factory Pattern",
          "Use Cases",
          "Frontend Architecture",
          "Open-Ended"
        ],
        "question": "Describe two real-world scenarios where the Factory Pattern would be a suitable design choice in a frontend application.",
        "complexity": 7,
        "type": "open",
        "level": "medium",
        "prerequisites": [
          "theory_js_design_patterns_creational"
        ],
        "id": "question_factory_use_cases",
        "options": [],
        "topic": "Factory Pattern Use Cases",
        "evaluationCriteria": [
          "Relevance and clarity of scenarios.",
          "Justification for using the Factory Pattern."
        ],
        "interviewFrequency": 6,
        "learningPath": "advanced",
        "answer": "1.  **Scenario: UI Component Creation (Dynamic Rendering)**\n    *   **Description:** Imagine a dashboard application that needs to render various types of widgets (e.g., `ChartWidget`, `TableWidget`, `TextWidget`). Each widget type might have different data requirements, rendering logic, and event handling. Instead of using a series of `if/else` or `switch` statements to instantiate the correct widget directly, a Factory Pattern can be used.\n    *   **Implementation:** A `WidgetFactory` function could take a `widgetType` string and data, then return the appropriate widget instance. This hides the complexities of `new ChartWidget(...)`, `new TableWidget(...)`, etc., from the component responsible for rendering the dashboard.\n    *   **Benefit:** Decouples the client (dashboard renderer) from specific widget constructors, making it easy to add new widget types without modifying existing rendering logic. Promotes clean, modular code.\n\n2.  **Scenario: API Client Generation (Environment-specific)**\n    *   **Description:** In a full-stack application, your frontend might interact with different backend APIs depending on the environment (development, staging, production) or even different versions of an API. The API client might also need different configurations (e.g., authentication headers).\n    *   **Implementation:** An `ApiClientFactory` could take an `environment` parameter (e.g., 'dev', 'prod') and return a configured API client instance. This instance could be an `Axios` instance with specific base URLs and interceptors, or a custom wrapper around `fetch`.\n    *   **Benefit:** Centralizes API client creation and configuration logic. It ensures that the correct API client is used based on the environment, reduces redundant configuration, and makes it easier to swap or upgrade API clients in the future.",
        "keyConcepts": [
          "Factory Pattern",
          "Design Patterns",
          "Decoupling",
          "Abstraction",
          "Modularity"
        ],
        "analysisPoints": [
          "Provides clear and distinct real-world scenarios.",
          "Explains *why* the Factory Pattern is suitable for each scenario.",
          "Demonstrates practical application knowledge."
        ],
        "example": null
      },
      {
        "evaluationCriteria": [
          "Concise and accurate definition."
        ],
        "interviewFrequency": 5,
        "complexity": 4,
        "example": null,
        "tags": [
          "Design Patterns",
          "Creational Patterns",
          "Definition",
          "Flashcard"
        ],
        "analysisPoints": [
          "Defines the core concept of creational patterns.",
          "Highlights the benefits of using them."
        ],
        "id": "question_creational_patterns_definition",
        "keyConcepts": [
          "Creational Design Patterns",
          "Object Creation",
          "Abstraction",
          "Flexibility"
        ],
        "question": "What is the main purpose of Creational Design Patterns?",
        "topic": "Creational Design Patterns",
        "level": "easy",
        "prerequisites": [],
        "type": "flashcard",
        "options": [],
        "answer": "Creational Design Patterns deal with object creation mechanisms. Their main purpose is to abstract the instantiation process, making the system independent of how its objects are created, composed, and represented. They provide ways to create objects in a manner suitable for a given situation, increasing flexibility and reusability.",
        "learningPath": "beginner"
      },
      {
        "type": "code",
        "id": "question_constructor_memory",
        "level": "hard",
        "answer": "1.  **Memory Inefficiency:**\n    The methods `getArea` and `getPerimeter` are defined directly on `this` inside the `Rectangle` constructor. This means that *every* time a new `Rectangle` object is created (`new Rectangle(...)`), a *new function instance* of `getArea` and `getPerimeter` is created and assigned to that object. If you create 1000 `Rectangle` objects, you will have 1000 copies of `getArea` and `getPerimeter` in memory, even though their logic is identical across all instances. This leads to redundant memory consumption.\n\n2.  **Rewritten Code (Memory-Efficient):**\n    ```typescript\n    function Rectangle(width: number, height: number) {\n      this.width = width;\n      this.height = height;\n    }\n    \n    // Define methods on the prototype for memory efficiency\n    Rectangle.prototype.getArea = function(): number {\n      return this.width * this.height;\n    };\n    \n    // Arrow functions on prototype need careful 'this' binding if not using standard function syntax\n    // For simplicity and consistent 'this' behavior with methods, standard functions are preferred on prototype\n    Rectangle.prototype.getPerimeter = function(): number {\n      return 2 * (this.width + this.height);\n    };\n    \n    const rect1 = new Rectangle(10, 5);\n    const rect2 = new Rectangle(7, 3);\n    \n    console.log(rect1.getArea()); // 50\n    console.log(rect2.getPerimeter()); // 20\n    \n    // Demonstrate shared methods\n    console.log(rect1.getArea === rect2.getArea); // true\n    console.log(rect1.getPerimeter === rect2.getPerimeter); // true\n    ```\n\n    **Explanation:** By moving `getArea` and `getPerimeter` to `Rectangle.prototype`, a single instance of each function is created and stored on the prototype object. All `Rectangle` instances then inherit these methods via their prototype chain. This means `rect1` and `rect2` (and any future `Rectangle` instances) will share the exact same function objects for `getArea` and `getPerimeter`, drastically reducing memory footprint.",
        "topic": "Constructor Pattern Memory Usage",
        "evaluationCriteria": [
          "Accurate identification of the problem.",
          "Correct and efficient refactoring of the code.",
          "Clear explanation of the solution's benefits."
        ],
        "learningPath": "advanced",
        "example": "\n```typescript\nfunction Rectangle(width, height) {\n  this.width = width;\n  this.height = height;\n\n  this.getArea = function() {\n    return this.width * this.height;\n  };\n\n  this.getPerimeter = () => {\n    return 2 * (this.width + this.height);\n  };\n}\n\nconst rect1 = new Rectangle(10, 5);\nconst rect2 = new Rectangle(7, 3);\n\n// Demonstrating the inefficiency:\nconsole.log(rect1.getArea === rect2.getArea); // false - different function instances\nconsole.log(rect1.getPerimeter === rect2.getPerimeter); // false - different function instances\n```",
        "keyConcepts": [
          "Constructor Pattern",
          "Prototype",
          "Memory Management",
          "JavaScript Objects",
          "this keyword"
        ],
        "prerequisites": [
          "theory_js_design_patterns_creational",
          "javascript_prototypes"
        ],
        "analysisPoints": [
          "Ability to identify memory inefficiencies in object creation.",
          "Knowledge of JavaScript prototype chain for method sharing.",
          "Correct application of the Constructor Pattern with `prototype`.",
          "Understanding of 'this' context in regular functions vs. arrow functions on prototype."
        ],
        "question": "Consider the following JavaScript `Rectangle` constructor:\n```typescript\nfunction Rectangle(width, height) {\n  this.width = width;\n  this.height = height;\n\n  this.getArea = function() {\n    return this.width * this.height;\n  };\n\n  this.getPerimeter = () => {\n    return 2 * (this.width + this.height);\n  };\n}\n\nconst rect1 = new Rectangle(10, 5);\nconst rect2 = new Rectangle(7, 3);\n```\n\n1.  Identify the potential memory inefficiency in this implementation.\n2.  Rewrite the `Rectangle` constructor to address this inefficiency, ensuring `getArea` and `getPerimeter` are memory-efficient.",
        "complexity": 8,
        "options": [],
        "tags": [
          "Constructor Pattern",
          "Prototype",
          "Memory",
          "Optimization",
          "Code Refactoring",
          "Hard"
        ],
        "interviewFrequency": 7
      },
      {
        "tags": [
          "Factory Pattern",
          "Abstraction",
          "Decoupling",
          "Design Principles",
          "Open-Ended"
        ],
        "keyConcepts": [
          "Factory Pattern",
          "Abstraction",
          "Decoupling",
          "Maintainability",
          "Polymorphism",
          "Dependency Injection (indirectly related)"
        ],
        "evaluationCriteria": [
          "Thorough explanation of concepts.",
          "Effectiveness of the example in demonstrating the benefits.",
          "Understanding of software design principles."
        ],
        "id": "question_factory_abstraction",
        "learningPath": "advanced",
        "options": [],
        "topic": "Factory Pattern Abstraction",
        "example": null,
        "complexity": 7,
        "question": "How does the Factory Pattern contribute to better abstraction and decoupling in a codebase? Provide an example.",
        "type": "open",
        "prerequisites": [
          "theory_js_design_patterns_creational"
        ],
        "answer": "The Factory Pattern contributes to better abstraction and decoupling by centralizing the object creation logic and hiding the specific details of object instantiation from the client code.\n\n**Abstraction:**\nInstead of the client code directly calling `new SpecificProductA()` or `new SpecificProductB()`, it calls a factory function like `createProduct('typeA')` or `createProduct('typeB')`. The client doesn't need to know the actual class names, their constructor parameters, or the logic involved in deciding which specific product to create. The factory *abstracts away* these complexities.\n\n**Decoupling:**\nBecause the client code interacts only with the factory interface and not the concrete product classes, the client becomes decoupled from the product implementations. If a new product type is introduced, or an existing product's implementation changes (e.g., its constructor signature), only the factory needs to be modified. The client code that uses the factory remains unchanged. This reduces dependencies and makes the system more flexible and easier to maintain.\n\n**Example:**\nConsider an application that processes payments through different gateways (PayPal, Stripe, Braintree).\n\n**Without Factory:**\n```typescript\n// Client code directly instantiating payment gateways\nlet gateway;\nif (paymentMethod === 'paypal') {\n  gateway = new PayPalGateway(apiKey, secretKey);\n} else if (paymentMethod === 'stripe') {\n  gateway = new StripeGateway(stripeSecret);\n} else if (paymentMethod === 'braintree') {\n  gateway = new BraintreeGateway(merchantId);\n} else {\n  throw new Error('Unsupported payment method');\n}\n// ... use gateway to process payment\n```\nHere, the client code (where `gateway` is assigned) is tightly coupled to the specific `PayPalGateway`, `StripeGateway`, and `BraintreeGateway` classes and their constructors. If a new gateway is added, or a constructor changes, this client code must be updated.\n\n**With Factory:**\n```typescript\ninterface PaymentGateway {\n  processPayment(amount: number): boolean;\n}\n\nclass PayPalGateway implements PaymentGateway { /* ... */ }\nclass StripeGateway implements PaymentGateway { /* ... */ }\nclass BraintreeGateway implements PaymentGateway { /* ... */ }\n\n// PaymentGatewayFactory.ts\nfunction createPaymentGateway(method: string, config: any): PaymentGateway {\n  switch (method) {\n    case 'paypal':\n      return new PayPalGateway(config.apiKey, config.secretKey);\n    case 'stripe':\n      return new StripeGateway(config.stripeSecret);\n    case 'braintree':\n      return new BraintreeGateway(config.merchantId);\n    default:\n      throw new Error('Unsupported payment method');\n  }\n}\n\n// Client code\nconst gatewayConfig = { /* ... */ }; // config based on environment/user choice\nconst gateway = createPaymentGateway(paymentMethod, gatewayConfig);\n// ... use gateway.processPayment(amount);\n```\nIn the factory example, the client code simply calls `createPaymentGateway()`. It doesn't know (or need to know) which concrete `PaymentGateway` class is being instantiated. This abstracts the creation process and decouples the client from the specific gateway implementations. If a new gateway is added, only the `createPaymentGateway` function needs modification; the client code remains untouched.",
        "level": "medium",
        "interviewFrequency": 6,
        "analysisPoints": [
          "Clear explanation of abstraction and decoupling in the context of Factory Pattern.",
          "Illustrative example showing both 'without factory' and 'with factory' scenarios.",
          "Emphasis on the benefits of reduced dependencies and improved maintainability."
        ]
      },
      {
        "options": [],
        "prerequisites": [
          "theory_event_loop_fundamentals",
          "javascript_promises",
          "javascript_async_await"
        ],
        "keyConcepts": [
          "Event Loop",
          "Async/Await",
          "Promises",
          "Microtask Queue",
          "Callback Queue",
          "Execution Context"
        ],
        "tags": [
          "Event Loop",
          "Async/Await",
          "Promises",
          "Microtask",
          "Macrotask",
          "Hard",
          "Code Prediction"
        ],
        "complexity": 9,
        "answer": "```typescript\nconsole.log('Script Start');\n\nasync function fetchData() {\n  console.log('fetchData: Before await');\n  await Promise.resolve('Data');\n  console.log('fetchData: After await');\n}\n\nfetchData();\n\nsetTimeout(() => {\n  console.log('setTimeout: 0ms delay');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise.then: outside async');\n});\n\nconsole.log('Script End');\n\n// Expected Output:\n// Script Start\n// fetchData: Before await\n// Script End\n// Promise.then: outside async\n// fetchData: After await\n// setTimeout: 0ms delay\n```\n\n**Explanation:**\n1.  **`Script Start`** is logged immediately as it's synchronous.\n2.  **`fetchData()` call:** The `fetchData` function is called. Its initial synchronous part, **`fetchData: Before await`**, is logged.\n3.  **`await Promise.resolve('Data')`:** When `await` is encountered, the execution of `fetchData` is paused. The resolved promise (`Promise.resolve('Data')`) makes the `await` immediately resolvable. The *remainder* of the `fetchData` function (i.e., `console.log('fetchData: After await')` and anything following it) is wrapped in a callback and pushed onto the **Microtask Queue**.\n4.  **`setTimeout`:** The `setTimeout` callback (`console.log('setTimeout: 0ms delay')`) is offloaded to the Web APIs. Once the timer expires (effectively 0ms, but still asynchronous), its callback is placed into the **Callback Queue (Macrotask Queue)**.\n5.  **`Promise.resolve().then()`:** The `then` callback (`console.log('Promise.then: outside async')`) is immediately placed into the **Microtask Queue**.\n6.  **`Script End`** is logged immediately as it's synchronous.\n\nNow the Call Stack is empty. The Event Loop kicks in:\n\n7.  **Microtask Queue Processing:** The Event Loop checks the Microtask Queue. It finds two tasks:\n    *   `console.log('Promise.then: outside async')` (from step 5).\n    *   `console.log('fetchData: After await')` (from step 3).\n    These are executed in the order they were added to the queue. So, `Promise.then: outside async` is logged, then `fetchData: After await` is logged.\n\n8.  **Callback Queue Processing:** After the Microtask Queue is completely empty, the Event Loop checks the Callback Queue. It finds the `setTimeout` callback. `setTimeout: 0ms delay` is logged.",
        "analysisPoints": [
          "Understanding of synchronous execution flow.",
          "Correctly identifying when `await` pauses execution and places the remainder into the Microtask Queue.",
          "Distinguishing between microtasks (from `await` and `Promise.then`) and macrotasks (`setTimeout`).",
          "Applying the Event Loop's priority rules (Call Stack -> All Microtasks -> One Macrotask)."
        ],
        "id": "question_event_loop_async_await_flow",
        "type": "code",
        "example": "\n```typescript\nconsole.log('Script Start');\n\nasync function fetchData() {\n  console.log('fetchData: Before await');\n  await Promise.resolve('Data');\n  console.log('fetchData: After await');\n}\n\nfetchData();\n\nsetTimeout(() => {\n  console.log('setTimeout: 0ms delay');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise.then: outside async');\n});\n\nconsole.log('Script End');\n```",
        "interviewFrequency": 9,
        "evaluationCriteria": [
          "Accuracy of predicted output.",
          "Detailed and correct explanation of `await`'s interaction with the Microtask Queue.",
          "Comprehensive understanding of asynchronous flow."
        ],
        "question": "Analyze the following code snippet involving `async/await` and determine the exact order of console logs. Explain how `await` interacts with the Microtask Queue.",
        "learningPath": "advanced",
        "level": "hard",
        "topic": "Async/Await and Event Loop Flow"
      },
      {
        "keyConcepts": [
          "Event Loop",
          "UI Rendering",
          "Blocking Thread",
          "Macrotask",
          "Responsive UI",
          "Web Workers",
          "requestAnimationFrame"
        ],
        "prerequisites": [
          "theory_event_loop_fundamentals"
        ],
        "question": "How do UI updates (like DOM changes) fit into the Event Loop processing model? Consider a scenario where you trigger a computationally intensive task, then immediately try to update the UI.",
        "complexity": 8,
        "topic": "Event Loop and UI Updates",
        "options": [],
        "type": "open",
        "interviewFrequency": 7,
        "learningPath": "advanced",
        "analysisPoints": [
          "Explains that UI updates are part of the rendering step, which happens within the Event Loop's cycle (between macrotasks).",
          "Demonstrates how synchronous blocking code prevents UI updates.",
          "Highlights the importance of asynchronous patterns for responsive UI.",
          "Mentions potential solutions for heavy computation without blocking UI."
        ],
        "tags": [
          "Event Loop",
          "UI",
          "Performance",
          "Blocking",
          "Asynchronous JavaScript",
          "Open-Ended"
        ],
        "level": "medium",
        "answer": "UI updates (rendering, repainting, reflows) are generally treated as **macrotasks** or occur at specific points *between* macrotasks within the Event Loop's cycle. The browser engine decides when to perform these rendering updates, typically after emptying the Microtask Queue and before picking the *next* macrotask from the Callback Queue. This allows for batching of multiple DOM changes for efficiency.\n\n**Scenario:**\nImagine a button click handler that performs a long, synchronous calculation and then attempts to update a UI element:\n\n```typescript\ndocument.getElementById('myButton').addEventListener('click', () => {\n  const statusDiv = document.getElementById('status');\n  statusDiv.textContent = 'Calculation started...'; // UI update attempt 1\n\n  // Simulate a computationally intensive synchronous task\n  let sum = 0;\n  for (let i = 0; i < 1000000000; i++) {\n    sum += i;\n  }\n  console.log('Calculation finished:', sum);\n\n  statusDiv.textContent = 'Calculation complete!'; // UI update attempt 2\n});\n```\n\n**Event Loop Flow for this scenario:**\n1.  **Click Event:** When the button is clicked, the `addEventListener` callback is placed into the **Callback Queue**.\n2.  **Event Loop picks callback:** Once the Call Stack is empty (e.g., initial script execution finished), the Event Loop pushes the click event callback onto the Call Stack.\n3.  **Synchronous Execution:**\n    *   `statusDiv.textContent = 'Calculation started...'` is executed. The browser *registers* this DOM change, but it **does not immediately render** it. Rendering happens in a separate macrotask turn.\n    *   The `for` loop (the computationally intensive task) runs synchronously. **This blocks the main thread.** No other JavaScript code, no microtasks, and crucially, **no UI rendering** can happen during this time.\n    *   `console.log('Calculation finished:', sum)` is logged.\n    *   `statusDiv.textContent = 'Calculation complete!'` is executed. This overwrites the previous text content change. Again, the browser registers this, but doesn't render yet.\n4.  **Call Stack Empty:** The click event callback finishes, and the Call Stack becomes empty.\n5.  **Microtask Queue:** The Event Loop checks the Microtask Queue. If there were any, they would execute now.\n6.  **UI Rendering:** After the Microtask Queue is empty, and before picking the *next* macrotask, the browser performs a rendering cycle. At this point, the accumulated DOM changes (from `statusDiv.textContent = 'Calculation complete!'`) are painted to the screen. The user will *only* see \"Calculation complete!\" and will *not* see \"Calculation started...\" because the rendering didn't happen until *after* the entire synchronous block finished.\n\n**Conclusion:** If a synchronous task blocks the main thread, the UI will become unresponsive, and any intermediate DOM updates will not be rendered until the blocking task completes and the Event Loop gets a chance to trigger a rendering cycle. To avoid this, computationally intensive tasks should be moved to asynchronous operations (e.g., using `requestAnimationFrame` for animations, Web Workers for heavy computation, or breaking tasks into smaller chunks with `setTimeout(..., 0)` or `queueMicrotask` for non-blocking UI updates).",
        "example": null,
        "id": "question_event_loop_dom_update",
        "evaluationCriteria": [
          "Clarity of explanation on UI rendering timing.",
          "Correct analysis of the blocking scenario.",
          "Practical understanding of maintaining UI responsiveness."
        ]
      }
    ],
    "id": "chunk_100_199_1749977605241",
    "completed": false,
    "displayEndLine": 199,
    "startLine": 100,
    "tasks": [
      {
        "description": "\nGiven a complex JavaScript snippet involving `setTimeout`, `Promise`, `async/await`, and synchronous code, your task is to:\n\n1.  Predict the exact order of console logs.\n2.  Provide a detailed explanation for your prediction, referencing the Event Loop, Call Stack, Microtask Queue, and Callback Queue.\n3.  (Optional for self-study) Run the code to verify your prediction.\n\n**Requirements:**\n*   Consider the given code snippet.\n*   Trace the execution step-by-step, explaining where each `console.log` statement's execution is scheduled or occurs.\n*   Clearly differentiate between synchronous execution, microtasks, and macrotasks.\n*   Explain the role of `await` and `new Promise` constructor in the Event Loop flow.\n",
        "learningPath": "advanced",
        "interviewRelevance": 10,
        "testCases": [
          "Expected output for the given snippet is: A, C, E, I, D, F, B, G, H",
          "Verify that synchronous logs appear first.",
          "Verify that all microtasks from the initial script run before any initial macrotasks.",
          "Verify that microtasks spawned within a macrotask run immediately after that macrotask completes, but before the next macrotask."
        ],
        "complexity": 9,
        "title": "Predict and Verify Event Loop Output",
        "tags": [
          "Event Loop",
          "Asynchronous JavaScript",
          "Promises",
          "setTimeout",
          "Async/Await",
          "Prediction",
          "Debugging"
        ],
        "prerequisites": [
          "theory_event_loop_fundamentals"
        ],
        "startingCode": "function runEventLoopTest() {\n  console.log('A: Script Start');\n\n  setTimeout(() => {\n    console.log('B: setTimeout (0ms)');\n  }, 0);\n\n  new Promise(resolve => {\n    console.log('C: Promise constructor');\n    resolve();\n  }).then(() => {\n    console.log('D: Promise.then (1)');\n  });\n\n  async function asyncFunc() {\n    console.log('E: asyncFunc - Before await');\n    await Promise.resolve();\n    console.log('F: asyncFunc - After await');\n  }\n  asyncFunc();\n\n  setTimeout(() => {\n    console.log('G: setTimeout (another 0ms)');\n    Promise.resolve().then(() => {\n      console.log('H: Promise.then inside setTimeout');\n    });\n  }, 0);\n\n  console.log('I: Script End');\n}\n\nrunEventLoopTest();\n",
        "id": "task_predict_event_loop_output",
        "timeEstimate": 60,
        "hints": [
          "Remember that `new Promise` constructor runs synchronously.",
          "`await` places the rest of the `async` function's execution into the Microtask Queue.",
          "Any `Promise.then` callback immediately queues a microtask.",
          "A `setTimeout` callback queues a macrotask.",
          "The Event Loop processes: Call Stack -> ALL Microtasks -> ONE Macrotask -> Repeat."
        ],
        "solutionCode": "function runEventLoopTest() {\n  console.log('A: Script Start');\n\n  setTimeout(() => {\n    console.log('B: setTimeout (0ms)');\n  }, 0);\n\n  new Promise(resolve => {\n    console.log('C: Promise constructor');\n    resolve();\n  }).then(() => {\n    console.log('D: Promise.then (1)');\n  });\n\n  async function asyncFunc() {\n    console.log('E: asyncFunc - Before await');\n    await Promise.resolve();\n    console.log('F: asyncFunc - After await');\n  }\n  asyncFunc();\n\n  setTimeout(() => {\n    console.log('G: setTimeout (another 0ms)');\n    Promise.resolve().then(() => {\n      console.log('H: Promise.then inside setTimeout');\n    });\n  }, 0);\n\n  console.log('I: Script End');\n}\n\n// Predicted Output:\n// A: Script Start\n// C: Promise constructor\n// E: asyncFunc - Before await\n// I: Script End\n// D: Promise.then (1)\n// F: asyncFunc - After await\n// B: setTimeout (0ms)\n// G: setTimeout (another 0ms)\n// H: Promise.then inside setTimeout\n\n/*\nExplanation:\n\n1.  **Synchronous Execution (Call Stack):**\n    *   `console.log('A: Script Start');` -> 'A'\n    *   `setTimeout` (B) is scheduled with Web API, callback goes to MacroQueue.\n    *   `new Promise` constructor runs synchronously: `console.log('C: Promise constructor');` -> 'C'. `resolve()` puts D's callback into MicroQueue.\n    *   `asyncFunc()` is called. Its synchronous part runs: `console.log('E: asyncFunc - Before await');` -> 'E'.\n    *   `await Promise.resolve()` pauses `asyncFunc` execution. The rest of `asyncFunc` (F's `console.log`) is pushed to the MicroQueue.\n    *   `setTimeout` (G) is scheduled with Web API, callback goes to MacroQueue.\n    *   `console.log('I: Script End');` -> 'I'\n\n    At this point, Call Stack is empty. MacroQueue: [B, G], MicroQueue: [D, F]\n\n2.  **Microtask Queue Execution:** The Event Loop prioritizes the Microtask Queue.\n    *   Pulls and executes D's callback: `console.log('D: Promise.then (1)');` -> 'D'\n    *   Pulls and executes F's callback: `console.log('F: asyncFunc - After await');` -> 'F'\n\n    MicroQueue is now empty.\n\n3.  **Macrotask (Callback Queue) Execution - Turn 1:** Event Loop picks the first task from MacroQueue.\n    *   Pulls and executes B's callback: `console.log('B: setTimeout (0ms)');` -> 'B'\n\n    Call Stack is empty again. MacroQueue: [G], MicroQueue: []\n\n4.  **Macrotask (Callback Queue) Execution - Turn 2:** Event Loop picks the next task from MacroQueue.\n    *   Pulls and executes G's callback: `console.log('G: setTimeout (another 0ms)');` -> 'G'.\n    *   *Inside* G's callback, `Promise.resolve().then(() => { console.log('H: Promise.then inside setTimeout'); });` is encountered. Its callback (H) is immediately pushed to the MicroQueue.\n\n    Call Stack is empty. MacroQueue: [], MicroQueue: [H]\n\n5.  **Microtask Queue Execution (after G completes):** Since the Call Stack is empty again (after G's execution), the Event Loop checks the Microtask Queue.\n    *   Pulls and executes H's callback: `console.log('H: Promise.then inside setTimeout');` -> 'H'\n\n    All queues are now empty.\n\n*/\n",
        "difficulty": "hard",
        "relatedConcepts": [
          "Call Stack",
          "Microtask Queue",
          "Callback Queue",
          "Web APIs"
        ]
      },
      {
        "timeEstimate": 45,
        "title": "Control Asynchronous Timing for UI Updates",
        "startingCode": "<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Async UI Update Demo</title>\n</head>\n<body>\n    <h1>Asynchronous UI Update</h1>\n    <button id=\"startButton\">Start Computation</button>\n    <div id=\"status\" style=\"margin-top: 20px; font-weight: bold;\">Ready</div>\n\n    <script src=\"script.js\"></script>\n</body>\n</html>\n\n// script.js\ndocument.getElementById('startButton').addEventListener('click', () => {\n    const statusDiv = document.getElementById('status');\n    statusDiv.textContent = 'Computation started...';\n\n    // TODO: Implement the non-blocking computation here\n    // Break down a loop or a series of operations using setTimeout(..., 0) or Promise/queueMicrotask\n    // Update statusDiv at different stages.\n\n    // Example of blocking code (DO NOT USE FOR SOLUTION):\n    // let sum = 0;\n    // for (let i = 0; i < 5000000000; i++) {\n    //     sum += i;\n    // }\n    // statusDiv.textContent = `Computation complete! Result: ${sum}`;\n});\n",
        "complexity": 7,
        "description": "\nImplement a function that simulates a long-running, non-blocking operation and updates the UI at distinct stages without freezing the browser.\n\n**Requirements:**\n1.  Create an HTML structure with a button and a `div` to display status messages.\n2.  When the button is clicked, start a 'heavy' computation.\n3.  Before the computation, update the status div to 'Computation started...'\n4.  The computation itself should be broken into smaller, asynchronous chunks (e.g., using `setTimeout(..., 0)` or `queueMicrotask`) to prevent UI blocking.\n5.  After the computation starts, but before it completes, update the status div to 'Processing data...'\n6.  Once the computation finishes, update the status div to 'Computation complete! Result: [value]'.\n7.  Ensure the UI remains responsive (e.g., you can click another button or scroll) throughout the 'Processing data...' phase.\n",
        "prerequisites": [
          "theory_event_loop_fundamentals",
          "html_basics",
          "dom_manipulation"
        ],
        "hints": [
          "To make a long synchronous loop non-blocking, break it into smaller segments.",
          "Use `setTimeout(callback, 0)` to schedule the next segment in the *next* Event Loop turn. This allows the browser to perform rendering updates and process other events between segments.",
          "Consider using a counter and a `chunkSize` to manage the segments.",
          "Remember to re-enable the button when the computation is truly finished."
        ],
        "interviewRelevance": 9,
        "difficulty": "medium",
        "testCases": [
          "Click the 'Start Computation' button. The 'status' div should immediately show 'Computation started...'",
          "After a brief moment, the 'status' div should change to 'Processing data...' and show a percentage, updating periodically.",
          "During the 'Processing data...' phase, attempt to interact with other elements on the page (if any) or scroll. The UI should not freeze.",
          "Once completed, the 'status' div should display 'Computation complete! Result: [value]' and the button should be re-enabled.",
          "Verify that the result of the computation is correct."
        ],
        "tags": [
          "Event Loop",
          "Asynchronous JavaScript",
          "UI Performance",
          "Non-blocking",
          "setTimeout",
          "Frontend Interview",
          "Responsiveness"
        ],
        "id": "task_control_async_timing",
        "relatedConcepts": [
          "Call Stack",
          "Macrotask",
          "UI Rendering",
          "Browser Event Model"
        ],
        "solutionCode": "<!-- index.html (same as starting code) -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Async UI Update Demo</title>\n</head>\n<body>\n    <h1>Asynchronous UI Update</h1>\n    <button id=\"startButton\">Start Computation</button>\n    <div id=\"status\" style=\"margin-top: 20px; font-weight: bold;\">Ready</div>\n\n    <script src=\"script.js\"></script>\n</body>\n</html>\n\n// script.js\ndocument.getElementById('startButton').addEventListener('click', () => {\n    const statusDiv = document.getElementById('status');\n    statusDiv.textContent = 'Computation started...';\n\n    // Use setTimeout to break up the long operation\n    let currentSum = 0;\n    let currentIteration = 0;\n    const totalIterations = 1000000000; // Simulate heavy load\n    const chunkSize = 1000000; // Process 1 million iterations at a time\n\n    const performChunk = () => {\n        const start = currentIteration;\n        const end = Math.min(currentIteration + chunkSize, totalIterations);\n\n        for (let i = start; i < end; i++) {\n            currentSum += i; // The actual 'computation'\n        }\n\n        currentIteration = end;\n\n        if (currentIteration < totalIterations) {\n            // If not finished, schedule the next chunk as a macrotask\n            // This allows the Event Loop to process UI updates and other events\n            statusDiv.textContent = `Processing data... (${Math.floor((currentIteration / totalIterations) * 100)}%)`;\n            setTimeout(performChunk, 0); // Schedule next chunk immediately\n        } else {\n            // Computation complete\n            statusDiv.textContent = `Computation complete! Result: ${currentSum}`;\n            document.getElementById('startButton').disabled = false;\n        }\n    };\n\n    document.getElementById('startButton').disabled = true; // Disable button during computation\n    statusDiv.textContent = 'Computation started... Initializing...';\n\n    // Start the first chunk in the next macrotask turn\n    setTimeout(performChunk, 0);\n});\n",
        "learningPath": "intermediate"
      },
      {
        "prerequisites": [
          "theory_js_design_patterns_creational",
          "javascript_prototypes"
        ],
        "learningPath": "beginner",
        "id": "task_implement_user_management_constructor",
        "solutionCode": "function User(id: number, name: string, email: string) {\n  this.id = id;\n  this.name = name;\n  this.email = email;\n}\n\n// Define methods on the prototype for memory efficiency\nUser.prototype.getFullName = function(): string {\n  // Assuming name is a full name string, or can be split\n  return this.name;\n};\n\nUser.prototype.sendEmail = function(): void {\n  console.log(`Email sent to ${this.email}`);\n};\n\n// Create instances\nconst user1 = new User(1, 'Alice Smith', 'alice@example.com');\nconst user2 = new User(2, 'Bob Johnson', 'bob@example.com');\n\n// Demonstrate properties and methods\nconsole.log(`User 1: ID=${user1.id}, Name=${user1.name}, Email=${user1.email}`);\nconsole.log(`User 1 Full Name: ${user1.getFullName()}`); // Output: Alice Smith\nuser1.sendEmail(); // Output: Email sent to alice@example.com\n\nconsole.log(`User 2: ID=${user2.id}, Name=${user2.name}, Email=${user2.email}`);\nconsole.log(`User 2 Full Name: ${user2.getFullName()}`); // Output: Bob Johnson\nuser2.sendEmail(); // Output: Email sent to bob@example.com\n\n// Verify memory efficiency (methods are shared)\nconsole.log('Are methods shared between instances?');\nconsole.log('getFullName:', user1.getFullName === user2.getFullName); // Should be true\nconsole.log('sendEmail:', user1.sendEmail === user2.sendEmail);     // Should be true\n",
        "hints": [
          "To make methods memory-efficient in the Constructor Pattern, define them on the `ConstructorName.prototype` property.",
          "Remember `this` context when defining methods on the prototype."
        ],
        "tags": [
          "Design Patterns",
          "Constructor Pattern",
          "Prototype",
          "Object Creation",
          "Memory Efficiency",
          "Easy"
        ],
        "interviewRelevance": 7,
        "timeEstimate": 30,
        "testCases": [
          "Create `user1` and `user2` instances.",
          "Verify `user1.id`, `user1.name`, `user1.email` match constructor arguments.",
          "Call `user1.getFullName()` and confirm it returns the correct name.",
          "Call `user1.sendEmail()` and confirm it logs the correct message.",
          "Check `user1.getFullName === user2.getFullName` to ensure methods are shared (return `true`).",
          "Check `user1.sendEmail === user2.sendEmail` to ensure methods are shared (return `true`)."
        ],
        "title": "Implement a User Management System (Constructor Pattern)",
        "description": "\nImplement a basic `User` object using the Constructor Pattern. The `User` objects should have properties like `id`, `name`, `email`, and methods like `getFullName()` and `sendEmail()`. Ensure methods are memory-efficient.\n\n**Requirements:**\n1.  Define a `User` constructor function.\n2.  Each `User` instance should have unique `id`, `name`, and `email` properties.\n3.  Implement a `getFullName()` method that returns the user's full name (e.g., 'John Doe'). Assume `name` is a single string for simplicity or parse it if you prefer.\n4.  Implement a `sendEmail()` method that simulates sending an email by logging a message to the console (e.g., 'Email sent to [user.email]').\n5.  Ensure both `getFullName()` and `sendEmail()` methods are defined in a memory-efficient way (i.e., not duplicated for every instance).\n6.  Create at least two `User` instances and demonstrate their properties and methods.\n",
        "difficulty": "easy",
        "startingCode": "function User(id, name, email) {\n  this.id = id;\n  this.name = name;\n  this.email = email;\n\n  // TODO: Define methods here, considering memory efficiency\n\n}\n\n// Example Usage (after implementing):\n// const user1 = new User(1, 'Alice Smith', 'alice@example.com');\n// console.log(user1.getFullName());\n// user1.sendEmail();\n",
        "complexity": 5,
        "relatedConcepts": [
          "JavaScript Objects",
          "Classes (ES6 equivalent)",
          "Inheritance"
        ]
      },
      {
        "description": "\nImplement a `NotificationFactory` that can create different types of notification objects (e.g., Email, SMS, Push) based on a specified type.\n\n**Requirements:**\n1.  Define a common interface (or type in TypeScript) for all notification objects, e.g., `Notification`, which should have a `send()` method.\n2.  Implement at least two concrete notification types (e.g., `EmailNotification`, `SMSNotification`, `PushNotification`). Each should implement the `Notification` interface and have its own unique properties and `send()` logic (e.g., logging a specific message).\n3.  Create a `NotificationFactory` function that takes a `type` string and relevant `options` as arguments.\n4.  The `NotificationFactory` should return an instance of the correct notification type based on the `type` argument.\n5.  Demonstrate the factory's usage by creating instances of different notification types and calling their `send()` method. Include a case for an unknown type.\n",
        "difficulty": "medium",
        "complexity": 6,
        "prerequisites": [
          "theory_js_design_patterns_creational",
          "typescript_interfaces_classes"
        ],
        "tags": [
          "Design Patterns",
          "Factory Pattern",
          "Object Creation",
          "Polymorphism",
          "Abstraction",
          "Medium"
        ],
        "timeEstimate": 45,
        "testCases": [
          "Create an 'email' notification and verify its `send()` method logs the correct email details.",
          "Create an 'sms' notification and verify its `send()` method logs the correct SMS details.",
          "Create a 'push' notification and verify its `send()` method logs the correct push notification details.",
          "Call the factory with an unsupported type and ensure it throws an appropriate error.",
          "Verify that `NotificationFactory('email', ...)` and `NotificationFactory('sms', ...)` return objects that both conform to the `Notification` interface (e.g., both have a `.send()` method, even if internal structure differs)."
        ],
        "relatedConcepts": [
          "Interface",
          "Encapsulation",
          "Dependency Inversion"
        ],
        "solutionCode": "interface Notification {\n  type: string;\n  send(): void;\n}\n\nclass EmailNotification implements Notification {\n  type: string = 'email';\n  constructor(private recipient: string, private subject: string, private body: string) {}\n  send(): void {\n    console.log(`Sending Email to ${this.recipient} - Subject: '${this.subject}' - Body: '${this.body}'`);\n  }\n}\n\nclass SMSNotification implements Notification {\n  type: string = 'sms';\n  constructor(private phoneNumber: string, private message: string) {}\n  send(): void {\n    console.log(`Sending SMS to ${this.phoneNumber} - Message: '${this.message}'`);\n  }\n}\n\nclass PushNotification implements Notification {\n  type: string = 'push';\n  constructor(private userId: string, private title: string, private content: string) {}\n  send(): void {\n    console.log(`Sending Push Notification to User ${this.userId} - Title: '${this.title}' - Content: '${this.content}'`);\n  }\n}\n\nfunction NotificationFactory(type: string, options: any): Notification {\n  switch (type) {\n    case 'email':\n      return new EmailNotification(options.recipient, options.subject, options.body);\n    case 'sms':\n      return new SMSNotification(options.phoneNumber, options.message);\n    case 'push':\n      return new PushNotification(options.userId, options.title, options.content);\n    default:\n      throw new Error(`Unknown notification type: ${type}`);\n  }\n}\n\n// Demonstrate Factory usage\nconst emailNotif = NotificationFactory('email', { recipient: 'user@example.com', subject: 'Welcome!', body: 'Thank you for signing up.' });\nemailNotif.send();\n// Expected: Sending Email to user@example.com - Subject: 'Welcome!' - Body: 'Thank you for signing up.'\n\nconst smsNotif = NotificationFactory('sms', { phoneNumber: '+1-555-123-4567', message: 'Your verification code is 89012.' });\nsmsNotif.send();\n// Expected: Sending SMS to +1-555-123-4567 - Message: 'Your verification code is 89012.'\n\nconst pushNotif = NotificationFactory('push', { userId: 'abc123xyz', title: 'New Message', content: 'You have a new unread message!' });\npushNotif.send();\n// Expected: Sending Push Notification to User abc123xyz - Title: 'New Message' - Content: 'You have a new unread message!'\n\ntry {\n  NotificationFactory('fax', { recipient: 'old-school' });\n} catch (e: any) {\n  console.error(e.message);\n  // Expected: Unknown notification type: fax\n}\n\n// Verify polymorphism: all returned objects have a 'send' method.\nconst notifications: Notification[] = [\n    NotificationFactory('email', { recipient: 'poly@example.com', subject: 'Poly', body: 'Morph' }),\n    NotificationFactory('sms', { phoneNumber: '987654321', message: 'Poly' })\n];\n\nnotifications.forEach(n => n.send());\n",
        "learningPath": "intermediate",
        "id": "task_implement_notification_factory",
        "interviewRelevance": 8,
        "hints": [
          "Define an interface/type for `Notification` first to ensure consistency.",
          "Use a `switch` statement or an object lookup inside the factory function to map types to constructors.",
          "The factory function should return an *instance* of the notification, not the class itself.",
          "Remember to handle unknown or unsupported notification types gracefully, typically by throwing an error."
        ],
        "startingCode": "interface Notification {\n  send(): void;\n}\n\n// TODO: Implement concrete notification classes/objects\n\n// TODO: Implement NotificationFactory function\n\n// Example Usage (after implementing):\n// const emailNotif = NotificationFactory('email', { recipient: 'user@example.com', subject: 'Hello', body: 'Test' });\n// emailNotif.send();\n\n// const smsNotif = NotificationFactory('sms', { phoneNumber: '+1234567890', message: 'Your code is 12345' });\n// smsNotif.send();\n\n// try {\n//   NotificationFactory('unknown', {});\n// } catch (e) {\n//   console.error(e.message);\n// }\n",
        "title": "Implement a Notification Factory"
      }
    ],
    "endLine": 200,
    "processedDate": "2025-06-15T08:53:25.240Z",
    "theory": [
      {
        "examples": [
          {
            "language": "typescript",
            "explanation": "This example illustrates the complete flow: all synchronous code executes first. Then, all microtasks (Promises) are processed. Finally, macrotasks (setTimouts) are processed one by one in subsequent event loop iterations.",
            "title": "Basic Event Loop Flow",
            "code": "console.log('Synchronous 1');\n\nsetTimeout(() => {\n  console.log('Timeout 1 (Macrotask)');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise 1 (Microtask)');\n});\n\nconsole.log('Synchronous 2');\n\nsetTimeout(() => {\n  console.log('Timeout 2 (Macrotask)');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise 2 (Microtask)');\n});\n\nconsole.log('Synchronous 3');\n\n// Expected Output:\n// Synchronous 1\n// Synchronous 2\n// Synchronous 3\n// Promise 1 (Microtask)\n// Promise 2 (Microtask)\n// Timeout 1 (Macrotask)\n// Timeout 2 (Macrotask)",
            "id": "example_event_loop_basic"
          },
          {
            "language": "typescript",
            "title": "Async/Await and Event Loop",
            "code": "async function asyncFunction() {\n  console.log('Async function start');\n  await Promise.resolve(); // Await pauses execution, puts rest of function in microtask queue\n  console.log('Async function end (Microtask)');\n}\n\nconsole.log('Script start');\n\nsetTimeout(() => {\n  console.log('Timeout (Macrotask)');\n}, 0);\n\nasyncFunction();\n\nPromise.resolve().then(() => {\n  console.log('Promise outside (Microtask)');\n});\n\nconsole.log('Script end');\n\n// Expected Output:\n// Script start\n// Async function start\n// Script end\n// Promise outside (Microtask)\n// Async function end (Microtask)\n// Timeout (Macrotask)",
            "explanation": "When `await Promise.resolve()` is encountered, the execution of `asyncFunction` is paused, and the remainder of the function (`console.log('Async function end')`) is placed into the Microtask Queue. This demonstrates that `await` essentially creates a microtask.",
            "id": "example_event_loop_async_await"
          }
        ],
        "title": "JavaScript Event Loop Fundamentals and Asynchronous Execution",
        "interviewRelevance": 10,
        "requiredFor": [
          "advanced_async_patterns",
          "web_performance_optimization"
        ],
        "technology": "JavaScript",
        "prerequisites": [
          "javascript_synchronous_execution",
          "javascript_functions"
        ],
        "content": "The JavaScript Event Loop is a crucial concept for understanding how JavaScript, a single-threaded language, handles asynchronous operations without blocking the main thread. It orchestrates the execution flow between the Call Stack, Web APIs, and different queues (Microtask Queue and Callback/Task Queue).\n\n## Key Components of the JavaScript Runtime\n\n### 1. Call Stack\n\nThe Call Stack is a LIFO (Last-In, First-Out) data structure that keeps track of the execution context of a program. When a function is called, it's pushed onto the stack. When it returns, it's popped off. All synchronous code runs directly on the Call Stack.\n\n![JavaScript Call Stack 1](images/event_loop_2.jpeg)\n![JavaScript Call Stack 2](images/event_loop_3.jpeg)\n![JavaScript Call Stack 3](images/event_loop_4.jpeg)\n![JavaScript Call Stack 4](images/event_loop_5.jpeg)\n\nThe sequence above shows how functions enter and exit the call stack, and how asynchronous callbacks are processed.\n\n### 2. Web APIs (Browser APIs)\n\nWeb APIs are functionalities provided by the browser environment (not JavaScript itself) that allow JavaScript to perform asynchronous operations. These include:\n*   **DOM (Document Object Model):** For manipulating HTML and CSS.\n*   **AJAX (Asynchronous JavaScript and XML):** For making network requests (e.g., `fetch`, `XMLHttpRequest`).\n*   **Timers:** `setTimeout()` and `setInterval()` for delayed or periodic execution.\n*   **Event Listeners:** For handling user interactions (clicks, keyboard input, etc.).\n\nWhen an asynchronous operation (like `setTimeout` or `fetch`) is encountered, JavaScript offloads it to the respective Web API. The Web API then performs the operation in the background.\n\n### 3. Callback Queue (Task Queue / MacroTask Queue)\n\nOnce a Web API operation completes (e.g., `setTimeout` timer expires, `fetch` request receives a response), its associated callback function is placed into the Callback Queue. This queue holds 'macrotasks' like `setTimeout`, `setInterval`, I/O operations, UI rendering, etc.\n\n### 4. Microtask Queue\n\nThe Microtask Queue is a higher-priority queue compared to the Callback Queue. It holds 'microtasks' such as:\n*   Promises (`.then()`, `.catch()`, `.finally()`)\n*   `MutationObserver` callbacks\n*   `queueMicrotask()`\n\nMicrotasks are always executed before macrotasks from the Callback Queue, as long as the Call Stack is empty.\n\n### 5. Event Loop\n\nThe Event Loop is the mechanism that constantly monitors the Call Stack and the queues. Its primary role is to push callbacks from the queues onto the Call Stack for execution when the Call Stack is empty. It ensures that JavaScript's single thread doesn't block while waiting for asynchronous operations.\n\n![JavaScript Event Loop 7](images/event_loop_6.jpeg)\nThe above diagram shows how the Event Loop connects the Call Stack, Web APIs, and Callback Queue.\n\n![JavaScript Event Loop Processing](images/event_loop_1.png)\nThis visualization demonstrates how asynchronous operations flow through the JavaScript runtime.\n\n![JavaScript Processing Model](images/event_loop_6.jpeg)\n\n## Event Loop Algorithm\n\nThe Event Loop follows a specific algorithm to determine the order of execution:\n\n1.  **Execute Code in the Call Stack:** Synchronous code runs first until the Call Stack becomes empty.\n2.  **Check Microtask Queue:** If the Call Stack is empty, the Event Loop checks the Microtask Queue and executes *all* tasks within it, one by one, until it's empty.\n3.  **Render UI Updates (if needed):** After emptying the Microtask Queue, the browser may render UI updates (repaint, reflow).\n4.  **Check Callback Queue:** If the Microtask Queue is empty, the Event Loop checks the Callback Queue and pushes the *oldest* task (macrotask) to the Call Stack.\n5.  **Repeat:** The process then repeats from step 1, continuously checking the Call Stack, then Microtask Queue, then Callback Queue.\n\n## Common Event Loop Example\n\nThis example demonstrates the typical execution order involving synchronous code, microtasks, and macrotasks.\n\n```typescript\nconsole.log('Start'); // 1. Synchronous execution\n\nsetTimeout(() => {\n  console.log('Timeout callback'); // 4. Macrotask, pushed to Callback Queue\n}, 0); // 0ms delay, but still asynchronous\n\nPromise.resolve().then(() => {\n  console.log('Promise callback'); // 3. Microtask, pushed to Microtask Queue\n});\n\nconsole.log('End'); // 2. Synchronous execution\n\n// Expected Output Order:\n// 'Start'\n// 'End'\n// 'Promise callback' (Microtask queue is processed before Callback queue)\n// 'Timeout callback' (Callback queue is processed after Microtask queue and stack is empty)\n```",
        "tags": [
          "Event Loop",
          "Asynchronous JavaScript",
          "Call Stack",
          "Web APIs",
          "Microtask Queue",
          "Callback Queue",
          "Promises",
          "setTimeout",
          "Frontend Interview"
        ],
        "id": "theory_event_loop_fundamentals",
        "complexity": 7,
        "relatedQuestions": [
          "question_event_loop_order",
          "question_microtask_vs_macrotask",
          "question_event_loop_definition",
          "question_event_loop_components",
          "question_event_loop_async_await_flow",
          "question_event_loop_dom_update"
        ],
        "relatedTasks": [
          "task_predict_event_loop_output",
          "task_control_async_timing"
        ],
        "learningPath": "intermediate"
      },
      {
        "technology": "TypeScript",
        "learningPath": "intermediate",
        "id": "theory_js_design_patterns_creational",
        "tags": [
          "Design Patterns",
          "Creational Patterns",
          "Constructor Pattern",
          "Factory Pattern",
          "Object-Oriented Programming",
          "JavaScript",
          "Frontend Interview"
        ],
        "requiredFor": [
          "scalable_frontend_architecture",
          "framework_understanding"
        ],
        "content": "Design patterns are reusable solutions to common problems in software design. They are not direct libraries or frameworks, but rather guidelines and best practices for structuring code. Creational patterns, specifically, deal with object creation mechanisms, trying to create objects in a manner suitable for the situation.\n\n## Creational Patterns\n\nCreational patterns abstract the instantiation process, making the system independent of how its objects are created, composed, and represented.\n\n### 1. Constructor Pattern\n\nThe Constructor Pattern is one of the simplest ways to create objects in JavaScript. It involves using a regular function with the `new` keyword to create instances. These functions are conventionally named starting with an uppercase letter to distinguish them from regular functions.\n\n**Purpose:** To create multiple instances of objects with similar properties and methods.\n\n**Characteristics:**\n*   Uses `this` keyword inside the constructor to refer to the instance being created.\n*   Methods can be defined directly on `this` (creating a new function for each instance, which is memory inefficient for shared methods).\n*   For shared methods, they should be defined on the constructor's `prototype` to save memory and allow all instances to share the same method reference.\n\n```typescript\n// Constructor Pattern\nfunction Person(name: string, age: number) {\n  this.name = name;\n  this.age = age;\n  \n  // Method defined directly on the instance (less efficient for shared methods)\n  this.greet = function() {\n    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);\n  };\n}\n\n// Better: Method defined on the prototype for memory efficiency\nPerson.prototype.sayHello = function() {\n  console.log(`Hello, my name is ${this.name}`);\n};\n\nconst john = new Person('John', 30);\njohn.sayHello(); // Hello, my name is John\njohn.greet();    // Hello, my name is John and I am 30 years old.\n\nconst jane = new Person('Jane', 25);\njane.sayHello(); // Hello, my name is Jane\n\nconsole.log(john.sayHello === jane.sayHello); // true (if on prototype), false (if on instance)\n```\n\n### 2. Factory Pattern\n\nThe Factory Pattern provides an interface for creating objects in a superclass but allows subclasses to alter the type of objects that will be created. In JavaScript, it often involves a function that returns new objects, abstracting away the instantiation logic and allowing for flexible object creation based on input parameters.\n\n**Purpose:** To create objects without exposing the instantiation logic to the client. It provides a generalized way to create objects of various types without specifying the exact constructor.\n\n**Characteristics:**\n*   A factory function (or method) is responsible for creating and returning objects.\n*   It can hide the `new` keyword and the specific constructor being used.\n*   Useful when creating different types of objects that share a common interface but have distinct implementations, or when the object creation process is complex.\n\n```typescript\n// Factory Pattern\ninterface User {\n  name: string;\n  permissions: string[];\n  role: string;\n}\n\nfunction createUser(type: 'admin' | 'user' | 'guest'): User {\n  switch (type) {\n    case 'admin':\n      return {\n        name: 'Administrator',\n        permissions: ['read', 'write', 'delete'],\n        role: 'admin'\n      };\n    case 'user':\n      return {\n        name: 'Standard User',\n        permissions: ['read'],\n        role: 'user'\n      };\n    case 'guest':\n      return {\n        name: 'Guest User',\n        permissions: [],\n        role: 'guest'\n      };\n    default:\n      throw new Error('Invalid user type');\n  }\n}\n\nconst admin = createUser('admin');\nconsole.log(admin); // { name: 'Administrator', permissions: [ 'read', 'write', 'delete' ], role: 'admin' }\n\nconst regularUser = createUser('user');\nconsole.log(regularUser); // { name: 'Standard User', permissions: [ 'read' ], role: 'user' }\n\nconst guest = createUser('guest');\nconsole.log(guest); // { name: 'Guest User', permissions: [], role: 'guest' }\n\n// Example of more complex factory logic\ninterface Vehicle {\n    type: string;\n    wheels: number;\n    start(): string;\n}\n\nfunction vehicleFactory(vehicleType: 'car' | 'bike'): Vehicle {\n    if (vehicleType === 'car') {\n        return {\n            type: 'car',\n            wheels: 4,\n            start: () => 'Car engine started!'\n        };\n    } else if (vehicleType === 'bike') {\n        return {\n            type: 'bike',\n            wheels: 2,\n            start: () => 'Bike engine started!'\n        };\n    } else {\n        throw new Error('Unknown vehicle type');\n    }\n}\n\nconst myCar = vehicleFactory('car');\nconsole.log(myCar.start()); // Car engine started!\n\nconst myBike = vehicleFactory('bike');\nconsole.log(myBike.start()); // Bike engine started!\n```",
        "title": "JavaScript Design Patterns: Creational Patterns (Constructor & Factory)",
        "prerequisites": [
          "javascript_objects",
          "javascript_functions",
          "javascript_prototypes"
        ],
        "relatedQuestions": [
          "question_constructor_vs_factory",
          "question_constructor_prototype",
          "question_factory_use_cases",
          "question_creational_patterns_definition",
          "question_constructor_memory",
          "question_factory_abstraction"
        ],
        "relatedTasks": [
          "task_implement_user_management_constructor",
          "task_implement_notification_factory"
        ],
        "interviewRelevance": 8,
        "examples": [
          {
            "explanation": "This example demonstrates how to use the Constructor Pattern along with prototype inheritance (`Object.create` and `call`) to create a more robust object hierarchy. Methods defined on the prototype are shared among all instances, promoting memory efficiency.",
            "title": "Constructor Pattern with Prototype Inheritance",
            "id": "example_constructor_pattern_advanced",
            "code": "function Animal(name: string) {\n  this.name = name;\n}\n\nAnimal.prototype.speak = function() {\n  return `I am a ${this.name}.`;\n};\n\nfunction Dog(name: string, breed: string) {\n  Animal.call(this, name); // Call super constructor\n  this.breed = breed;\n}\n\n// Inherit prototype methods\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog;\n\nDog.prototype.bark = function() {\n  return `Woof woof! I am a ${this.breed} named ${this.name}.`;\n};\n\nconst myDog = new Dog('Buddy', 'Golden Retriever');\nconsole.log(myDog.speak()); // I am a Buddy.\nconsole.log(myDog.bark());  // Woof woof! I am a Golden Retriever named Buddy.",
            "language": "typescript"
          },
          {
            "explanation": "This advanced example shows the Factory Pattern creating different `Shape` objects (Circle or Rectangle) based on input, demonstrating polymorphism. The client code interacts with the `ShapeFactory` without needing to know the specific class constructors, promoting loose coupling.",
            "code": "interface Shape {\n  draw(): string;\n  area(): number;\n}\n\nclass Circle implements Shape {\n  constructor(private radius: number) {}\n  draw(): string { return `Drawing a Circle with radius ${this.radius}`; }\n  area(): number { return Math.PI * this.radius * this.radius; }\n}\n\nclass Rectangle implements Shape {\n  constructor(private width: number, private height: number) {}\n  draw(): string { return `Drawing a Rectangle with width ${this.width} and height ${this.height}`; }\n  area(): number { return this.width * this.height; }\n}\n\nfunction ShapeFactory(type: 'circle' | 'rectangle', ...args: number[]): Shape {\n  if (type === 'circle') {\n    return new Circle(args[0]);\n  } else if (type === 'rectangle') {\n    return new Rectangle(args[0], args[1]);\n  } else {\n    throw new Error('Unknown shape type');\n  }\n}\n\nconst myCircle = ShapeFactory('circle', 5);\nconsole.log(myCircle.draw()); // Drawing a Circle with radius 5\nconsole.log(myCircle.area());  // 78.5398...\n\nconst myRectangle = ShapeFactory('rectangle', 4, 6);\nconsole.log(myRectangle.draw()); // Drawing a Rectangle with width 4 and height 6\nconsole.log(myRectangle.area()); // 24",
            "language": "typescript",
            "id": "example_factory_pattern_polymorphism",
            "title": "Factory Pattern for Polymorphic Object Creation"
          }
        ],
        "complexity": 6
      }
    ]
  },
  {
    "tasks": [
      {
        "prerequisites": [
          "javascript_closures",
          "javascript_iife"
        ],
        "solutionCode": "const LoggerSingleton = (function() {\n  let instance;\n  let logs: string[] = [];\n\n  function createInstance() {\n    return {\n      log: function(message: string): void {\n        const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19);\n        const logEntry = `[${timestamp}] ${message}`;\n        logs.push(logEntry);\n        console.log(logEntry); // Also log to console for visibility\n      },\n      getLogs: function(): string[] {\n        return [...logs]; // Return a copy to prevent external modification\n      },\n      clearLogs: function(): void {\n        logs = [];\n      }\n    };\n  }\n\n  return {\n    getInstance: function() {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return instance;\n    }\n  };\n})();\n\n// Example Usage & Test Cases:\nconst logger1 = LoggerSingleton.getInstance();\nconst logger2 = LoggerSingleton.getInstance();\n\n// Test Case 1: Ensure it's a Singleton\nconsole.assert(logger1 === logger2, \"Test 1 Failed: Instances are not the same.\");\nconsole.log(\"Test 1 Passed: Instances are the same.\");\n\n// Test Case 2: Logging and retrieval\nlogger1.log('Application started.');\nlogger2.log('User logged in.');\n\nconst retrievedLogs = logger1.getLogs();\nconsole.assert(retrievedLogs.length === 2, `Test 2 Failed: Expected 2 logs, got ${retrievedLogs.length}.`);\nconsole.assert(retrievedLogs[0].includes('Application started.'), \"Test 2 Failed: First log message incorrect.\");\nconsole.assert(retrievedLogs[1].includes('User logged in.'), \"Test 2 Failed: Second log message incorrect.\");\nconsole.assert(retrievedLogs[0].startsWith('['), \"Test 2 Failed: First log missing timestamp.\");\nconsole.log(\"Test 2 Passed: Logging and retrieval work.\");\n\n// Test Case 3: Verify logs are shared between instances\nconst logger3 = LoggerSingleton.getInstance();\nlogger3.log('Data processed.');\nconsole.assert(logger1.getLogs().length === 3, `Test 3 Failed: Expected 3 logs from logger1, got ${logger1.getLogs().length}.`);\nconsole.log(\"Test 3 Passed: Logs are shared across instances.\");\n\n// Test Case 4: Clear logs\nlogger1.clearLogs();\nconsole.assert(logger2.getLogs().length === 0, \"Test 4 Failed: Logs not cleared.\");\nconsole.log(\"Test 4 Passed: Logs can be cleared.\");",
        "tags": [
          "singleton",
          "design-patterns",
          "javascript",
          "oop",
          "logger"
        ],
        "testCases": [
          "Calling `LoggerSingleton.getInstance()` multiple times should always return the same object.",
          "Messages logged by `logger1.log()` should be retrievable by `logger2.getLogs()` (and vice versa) due to shared state.",
          "Each log entry returned by `getLogs()` should contain a timestamp.",
          "Test for empty messages or special characters in messages.",
          "Verify `getLogs()` returns a copy of the array, not the direct reference."
        ],
        "learningPath": "intermediate",
        "title": "Implement a Singleton Logger",
        "description": "\nImplement a `Logger` class using the Singleton pattern. The logger should have a method `log(message: string)` that records the message along with a timestamp. Ensure that only one instance of the `Logger` can exist globally.\n\n**Requirements:**\n1.  The `Logger` must be a Singleton.\n2.  It should have a `log(message: string)` method.\n3.  It should store log entries internally.\n4.  It should have a `getLogs(): string[]` method to retrieve all logged messages.\n5.  Each log entry should include a timestamp (e.g., `[YYYY-MM-DD HH:MM:SS] Message`).\n",
        "id": "task_singleton_logger",
        "relatedConcepts": [
          "global_state",
          "dependency_injection"
        ],
        "interviewRelevance": 8,
        "startingCode": "class LoggerSingleton {\n  // Private constructor or other mechanism to prevent direct instantiation\n  // ...\n  \n  // Method to get the single instance\n  static getInstance() {\n    // TODO: Implement Singleton logic\n    return null; \n  }\n  \n  // Method to log messages\n  log(message: string): void {\n    // TODO: Implement logging with timestamp\n  }\n  \n  // Method to retrieve all logs\n  getLogs(): string[] {\n    // TODO: Implement log retrieval\n    return [];\n  }\n}\n\n// Example usage:\n// const logger1 = LoggerSingleton.getInstance();\n// const logger2 = LoggerSingleton.getInstance();\n// console.log(logger1 === logger2); // Should be true\n// logger1.log('Application started.');\n// logger2.log('User logged in.');\n// console.log(logger1.getLogs()); // Should contain both messages with timestamps\n",
        "timeEstimate": 45,
        "complexity": 7,
        "difficulty": "medium",
        "hints": [
          "Use an IIFE to create a private scope for your `instance` variable.",
          "The `getInstance` method should check if the `instance` is already defined.",
          "Use `new Date().toISOString()` to easily get a formatted timestamp."
        ]
      },
      {
        "title": "Build a Configuration Manager Singleton",
        "description": "\nCreate a `ConfigManager` using the Singleton pattern that can load and provide application settings. The settings should be mutable through the manager, and all parts of the application should access the same configuration.\n\n**Requirements:**\n1.  The `ConfigManager` must be a Singleton.\n2.  It should have an `init(settings: Record<string, any>): void` method to load initial settings. This method should only work on the first call after instance creation.\n3.  It should have a `get(key: string): any` method to retrieve a setting.\n4.  It should have a `set(key: string, value: any): void` method to update a setting.\n5.  Settings should be stored privately.\n",
        "testCases": [
          "Multiple calls to `getInstance()` should return the same object.",
          "The `init()` method should only execute its logic once, subsequent calls should be ignored or warn.",
          "Settings set via `set()` method on one instance should be retrievable via `get()` on any other instance (verifying shared state).",
          "Retrieving a non-existent key should return `undefined`.",
          "Verify `getAll()` returns a copy of the settings to prevent external modification."
        ],
        "hints": [
          "A private `_isInitialized` flag can control the `init` method's behavior.",
          "Store settings in a private object (e.g., `_settings`).",
          "Consider using `Object.assign({}, settings)` or the spread operator `{...settings}` for copying settings to prevent direct mutation of the input object.",
          "Ensure `get` and `set` operate on the shared private `_settings` object."
        ],
        "interviewRelevance": 8,
        "tags": [
          "singleton",
          "design-patterns",
          "configuration",
          "javascript"
        ],
        "relatedConcepts": [
          "global_state",
          "application_settings",
          "module_pattern"
        ],
        "solutionCode": "const ConfigManagerSingleton = (function() {\n  let instance;\n  let _settings: Record<string, any> = {};\n  let _isInitialized: boolean = false;\n\n  function createInstance() {\n    return {\n      init: function(settings: Record<string, any>): void {\n        if (!_isInitialized) {\n          _settings = { ...settings }; // Deep copy if settings can be nested objects\n          _isInitialized = true;\n          console.log(\"ConfigManager: Initialized with\", _settings);\n        } else {\n          console.warn(\"ConfigManager: Already initialized. Call to init() ignored.\");\n        }\n      },\n      get: function(key: string): any {\n        return _settings[key];\n      },\n      set: function(key: string, value: any): void {\n        _settings[key] = value;\n        console.log(`ConfigManager: Set ${key} to ${value}`);\n      },\n      getAll: function(): Record<string, any> {\n        return { ..._settings }; // Return a copy\n      }\n    };\n  }\n\n  return {\n    getInstance: function() {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return instance;\n    }\n  };\n})();\n\n// Example Usage & Test Cases:\nconst config1 = ConfigManagerSingleton.getInstance();\n\n// Test Case 1: Initialisation\nconfig1.init({ apiUrl: 'https://api.example.com/v1', timeout: 5000, debug: true });\nconsole.assert(config1.get('apiUrl') === 'https://api.example.com/v1', \"Test 1 Failed: Initial API URL incorrect.\");\nconsole.assert(config1.get('debug') === true, \"Test 1 Failed: Initial debug mode incorrect.\");\nconsole.log(\"Test 1 Passed: Initialisation works.\");\n\n// Test Case 2: Second init() call should be ignored\nconst initialApiUrl = config1.get('apiUrl');\nconfig1.init({ apiUrl: 'https://api.another.com' }); // Should warn and not change\nconsole.assert(config1.get('apiUrl') === initialApiUrl, \"Test 2 Failed: Second init() call should be ignored.\");\nconsole.log(\"Test 2 Passed: Second init() call ignored.\");\n\n// Test Case 3: Get the same instance from another variable\nconst config2 = ConfigManagerSingleton.getInstance();\nconsole.assert(config1 === config2, \"Test 3 Failed: Instances are not the same.\");\nconsole.log(\"Test 3 Passed: Instances are the same.\");\n\n// Test Case 4: Set and Get from different instances, verify shared state\nconfig1.set('debug', false);\nconsole.assert(config2.get('debug') === false, \"Test 4 Failed: Shared state not working for set/get.\");\nconfig2.set('timeout', 10000);\nconsole.assert(config1.get('timeout') === 10000, \"Test 4 Failed: Shared state not working for set/get from other instance.\");\nconsole.log(\"Test 4 Passed: Set and Get work, state is shared.\");\n\n// Test Case 5: Get a non-existent key\nconsole.assert(config1.get('nonExistentKey') === undefined, \"Test 5 Failed: Non-existent key should return undefined.\");\nconsole.log(\"Test 5 Passed: Non-existent key handled.\");\n\n// Test Case 6: Immutability of returned settings object from getAll()\nconst allSettings = config1.getAll();\nallSettings['newKey'] = 'newValue';\nconsole.assert(config1.get('newKey') === undefined, \"Test 6 Failed: getAll() did not return a copy.\");\nconsole.log(\"Test 6 Passed: getAll() returns a copy.\");",
        "startingCode": "class ConfigManagerSingleton {\n  // TODO: Implement Singleton logic and methods\n  \n  static getInstance() {\n    return null;\n  }\n  \n  init(settings: Record<string, any>): void {\n    // Only allow initialization once\n  }\n  \n  get(key: string): any {\n    return undefined;\n  }\n  \n  set(key: string, value: any): void {\n    // ...\n  }\n}\n\n// Example usage:\n// const config1 = ConfigManagerSingleton.getInstance();\n// config1.init({ apiUrl: '/api/v1', debugMode: true });\n// const config2 = ConfigManagerSingleton.getInstance();\n// console.log(config2.get('apiUrl')); // Should be '/api/v1'\n// config1.set('debugMode', false);\n// console.log(config2.get('debugMode')); // Should be false\n",
        "difficulty": "medium",
        "complexity": 7,
        "prerequisites": [
          "javascript_objects",
          "javascript_closures"
        ],
        "timeEstimate": 60,
        "id": "task_singleton_config_manager",
        "learningPath": "intermediate"
      },
      {
        "prerequisites": [
          "typescript_interfaces",
          "javascript_array_methods",
          "object_destructuring"
        ],
        "startingCode": "interface LegacyUser {\n  id: number;\n  userName: string;\n  emailAddress: string;\n}\n\ninterface NewApiUser {\n  uid: string;\n  name: string;\n  contactEmail?: string; // Optional field\n}\n\nclass UserApiAdapter {\n  // TODO: Implement the adapt method\n  adapt(newApiUserData: NewApiUser[]): LegacyUser[] {\n    return [];\n  }\n}\n\n// Example Usage:\n// const newUsers: NewApiUser[] = [\n//   { uid: 'abc-123', name: 'John Doe', contactEmail: 'john@example.com' },\n//   { uid: 'def-456', name: 'Jane Smith' } // Missing email\n// ];\n// const adapter = new UserApiAdapter();\n// const legacyUsers = adapter.adapt(newUsers);\n// console.log(legacyUsers);\n// Expected: \n// [\n//   { id: 123, userName: 'John Doe', emailAddress: 'john@example.com' },\n//   { id: 456, userName: 'Jane Smith', emailAddress: '' }\n// ]\n",
        "id": "task_api_adapter",
        "hints": [
          "The `map` array method is suitable for transforming each object in an array.",
          "Use optional chaining (`?.`) or logical OR (`||`) for gracefully handling missing `contactEmail`.",
          "For the `id` field, you might need to parse the `uid` string (e.g., using regular expressions to extract the number)."
        ],
        "solutionCode": "interface LegacyUser {\n  id: number;\n  userName: string;\n  emailAddress: string;\n}\n\ninterface NewApiUser {\n  uid: string;\n  name: string;\n  contactEmail?: string; // Optional field\n}\n\nclass UserApiAdapter {\n  adapt(newApiUserData: NewApiUser[]): LegacyUser[] {\n    if (!Array.isArray(newApiUserData)) {\n      console.error(\"UserApiAdapter: Input is not an array.\");\n      return [];\n    }\n\n    return newApiUserData.map(newUser => {\n      // Basic transformation logic\n      // For 'id', we can extract the numeric part from 'uid' (e.g., 'abc-123' -> 123)\n      const idMatch = newUser.uid.match(/\\d+/);\n      const id = idMatch ? parseInt(idMatch[0], 10) : 0; // Default to 0 or throw error\n\n      return {\n        id: id,\n        userName: newUser.name || 'Unknown User',\n        emailAddress: newUser.contactEmail || '' // Handle missing field gracefully\n      };\n    });\n  }\n}\n\n// Example Usage & Test Cases:\nconst adapter = new UserApiAdapter();\n\n// Test Case 1: Standard valid data\nconst newUsers1: NewApiUser[] = [\n  { uid: 'user-101', name: 'Alice', contactEmail: 'alice@example.com' },\n  { uid: 'user-102', name: 'Bob', contactEmail: 'bob@example.com' }\n];\nconst legacyUsers1 = adapter.adapt(newUsers1);\nconsole.assert(legacyUsers1.length === 2, `Test 1 Failed: Expected 2 users, got ${legacyUsers1.length}.`);\nconsole.assert(legacyUsers1[0].id === 101, \"Test 1 Failed: First user ID incorrect.\");\nconsole.assert(legacyUsers1[0].userName === 'Alice', \"Test 1 Failed: First user name incorrect.\");\nconsole.assert(legacyUsers1[0].emailAddress === 'alice@example.com', \"Test 1 Failed: First user email incorrect.\");\nconsole.log(\"Test 1 Passed: Standard data conversion works.\");\n\n// Test Case 2: Missing optional field (contactEmail)\nconst newUsers2: NewApiUser[] = [\n  { uid: 'user-103', name: 'Charlie' }\n];\nconst legacyUsers2 = adapter.adapt(newUsers2);\nconsole.assert(legacyUsers2.length === 1, `Test 2 Failed: Expected 1 user, got ${legacyUsers2.length}.`);\nconsole.assert(legacyUsers2[0].id === 103, \"Test 2 Failed: User ID for missing email incorrect.\");\nconsole.assert(legacyUsers2[0].emailAddress === '', \"Test 2 Failed: Missing email not handled gracefully.\");\nconsole.log(\"Test 2 Passed: Missing optional field handled.\");\n\n// Test Case 3: Empty input array\nconst newUsers3: NewApiUser[] = [];\nconst legacyUsers3 = adapter.adapt(newUsers3);\nconsole.assert(legacyUsers3.length === 0, \"Test 3 Failed: Empty array input should return empty array.\");\nconsole.log(\"Test 3 Passed: Empty array input handled.\");\n\n// Test Case 4: Invalid input (non-array)\nconst newUsers4: any = null;\nconst legacyUsers4 = adapter.adapt(newUsers4);\nconsole.assert(legacyUsers4.length === 0, \"Test 4 Failed: Invalid input should return empty array.\");\nconsole.log(\"Test 4 Passed: Invalid input handled.\");\n\n// Test Case 5: UID without number\nconst newUsers5: NewApiUser[] = [\n  { uid: 'invalid-uid', name: 'David' }\n];\nconst legacyUsers5 = adapter.adapt(newUsers5);\nconsole.assert(legacyUsers5.length === 1, \"Test 5 Failed: Expected 1 user, got invalid UID.\");\nconsole.assert(legacyUsers5[0].id === 0, \"Test 5 Failed: UID without number not handled correctly.\");\nconsole.log(\"Test 5 Passed: UID without number handled.\");\n",
        "title": "Implement an API Data Adapter",
        "difficulty": "medium",
        "learningPath": "intermediate",
        "complexity": 7,
        "relatedConcepts": [
          "data_modeling",
          "api_design",
          "legacy_system_integration"
        ],
        "timeEstimate": 60,
        "interviewRelevance": 9,
        "description": "\nYou are working with a legacy frontend that expects user data in a specific format (`{ id: number, userName: string, emailAddress: string }`). However, a new backend API provides user data in a different format (`{ uid: string, name: string, contactEmail: string }`).\n\nImplement an `UserApiAdapter` that converts the new API's user data format into the format expected by the legacy frontend.\n\n**Requirements:**\n1.  Create a `LegacyUser` interface/type for the expected format.\n2.  Create a `NewApiUser` interface/type for the new API format.\n3.  Implement a `UserApiAdapter` class with a method `adapt(newApiUserData: NewApiUser[]): LegacyUser[]`.\n4.  The `adapt` method should transform an array of `NewApiUser` objects into an array of `LegacyUser` objects.\n5.  Handle potential missing fields gracefully (e.g., if `contactEmail` is missing, `emailAddress` could be an empty string or null).\n",
        "tags": [
          "adapter",
          "design-patterns",
          "api-integration",
          "data-transformation",
          "typescript"
        ],
        "testCases": [
          "Converting a list of `NewApiUser` with all fields present.",
          "Converting a list where `contactEmail` is missing for some users.",
          "Handling an empty array as input.",
          "Handling invalid input (e.g., `null` or `undefined` instead of an array).",
          "Edge case for `uid` parsing (e.g., `uid` without a number, or `uid` being an empty string)."
        ]
      },
      {
        "learningPath": "advanced",
        "description": "\nDevelop an `DateFormatAdapter` that can convert dates from one string format to another. This is common when consuming data from different sources (e.g., backend APIs, user input).\n\n**Requirements:**\n1.  Implement `DateFormatAdapter` class.\n2.  It should have a method `toStandard(dateString: string, originalFormat: string): Date` that converts a date string from `originalFormat` to a `Date` object.\n3.  It should have a method `fromStandard(date: Date, targetFormat: string): string` that converts a `Date` object to a string in `targetFormat`.\n4.  Support at least two common input formats (e.g., 'YYYY-MM-DD', 'MM/DD/YYYY') and two output formats.\n5.  Use a third-party library like `moment.js` or `date-fns` for robust date parsing/formatting if permitted, otherwise implement basic parsing.\n",
        "hints": [
          "For robust date handling, `date-fns` is a modern and lightweight choice over `moment.js`.",
          "Pay attention to the format strings for `parse` and `format` functions; they need to match the actual date string structure.",
          "Remember to check if the `Date` object returned by parsing is valid (`isNaN(date.getTime())`)."
        ],
        "timeEstimate": 90,
        "complexity": 8,
        "tags": [
          "adapter",
          "design-patterns",
          "date-handling",
          "data-transformation",
          "typescript",
          "libraries"
        ],
        "relatedConcepts": [
          "i18n",
          "l10n",
          "parsing"
        ],
        "prerequisites": [
          "typescript_classes",
          "javascript_dates",
          "third_party_libraries_usage"
        ],
        "startingCode": "// You might need to install 'date-fns' or 'moment' if allowed, or implement parsing manually.\n// npm install date-fns\n// import { parse, format } from 'date-fns';\n\nclass DateFormatAdapter {\n  /**\n   * Converts a date string from a specific format to a Date object.\n   * @param dateString The date string to convert.\n   * @param originalFormat The format of the input date string (e.g., 'yyyy-MM-dd').\n   * @returns A Date object, or null if parsing fails.\n   */\n  toStandard(dateString: string, originalFormat: string): Date | null {\n    // TODO: Implement conversion\n    return null;\n  }\n\n  /**\n   * Converts a Date object to a date string in a specific format.\n   * @param date The Date object to convert.\n   * @param targetFormat The desired output format (e.g., 'MM/dd/yyyy').\n   * @returns The formatted date string, or an empty string if date is invalid.\n   */\n  fromStandard(date: Date | null, targetFormat: string): string {\n    // TODO: Implement conversion\n    return '';\n  }\n}\n\n// Example Usage:\n// const adapter = new DateFormatAdapter();\n// const dateFromApi = '2023-10-27';\n// const standardDate = adapter.toStandard(dateFromApi, 'YYYY-MM-DD');\n// console.log(standardDate);\n// const formattedDate = adapter.fromStandard(standardDate, 'MM/DD/YYYY');\n// console.log(formattedDate); // Expected: '10/27/2023'\n",
        "interviewRelevance": 8,
        "testCases": [
          "Convert from 'YYYY-MM-DD' to `Date` object.",
          "Convert from `Date` object to 'MM/DD/YYYY' string.",
          "Convert from 'DD.MM.YYYY' to `Date` object.",
          "Handle invalid date string input (should return `null` or throw error).",
          "Handle `null` or invalid `Date` object input for `fromStandard` (should return empty string).",
          "Test different timezones if applicable (using `new Date()` can be timezone sensitive).",
          "Test with full datetime strings including hours, minutes, seconds."
        ],
        "difficulty": "hard",
        "solutionCode": "import { parse, format } from 'date-fns';\n\n// Define common formats for clarity\nconst DateFormats = {\n  YYYY_MM_DD: 'yyyy-MM-dd',\n  MM_DD_YYYY: 'MM/dd/yyyy',\n  DD_MM_YYYY: 'dd.MM.yyyy',\n  FULL_DATETIME: 'yyyy-MM-dd HH:mm:ss'\n};\n\nclass DateFormatAdapter {\n  /**\n   * Converts a date string from a specific format to a Date object.\n   * @param dateString The date string to convert.\n   * @param originalFormat The format of the input date string (e.g., 'yyyy-MM-dd').\n   * @returns A Date object, or null if parsing fails.\n   */\n  toStandard(dateString: string, originalFormat: string): Date | null {\n    try {\n      const parsedDate = parse(dateString, originalFormat, new Date());\n      // Check if parsed date is valid (date-fns returns 'Invalid Date' object for failures)\n      if (isNaN(parsedDate.getTime())) {\n        console.warn(`DateFormatAdapter: Failed to parse date string '${dateString}' with format '${originalFormat}'.`);\n        return null;\n      }\n      return parsedDate;\n    } catch (error) {\n      console.error(\"DateFormatAdapter Error during parsing:\", error);\n      return null;\n    }\n  }\n\n  /**\n   * Converts a Date object to a date string in a specific format.\n   * @param date The Date object to convert.\n   * @param targetFormat The desired output format (e.g., 'MM/dd/yyyy').\n   * @returns The formatted date string, or an empty string if date is invalid.\n   */\n  fromStandard(date: Date | null, targetFormat: string): string {\n    if (!date || isNaN(date.getTime())) {\n      console.warn(\"DateFormatAdapter: Invalid Date object provided for formatting.\");\n      return '';\n    }\n    try {\n      return format(date, targetFormat);\n    } catch (error) {\n      console.error(\"DateFormatAdapter Error during formatting:\", error);\n      return '';\n    }\n  }\n}\n\n// Example Usage & Test Cases:\nconst adapter = new DateFormatAdapter();\n\n// Test Case 1: YYYY-MM-DD to standard Date\nconst dateString1 = '2023-10-27';\nconst standardDate1 = adapter.toStandard(dateString1, DateFormats.YYYY_MM_DD);\nconsole.assert(standardDate1 instanceof Date && !isNaN(standardDate1.getTime()), `Test 1 Failed: Expected valid Date object, got ${standardDate1}.`);\nconsole.assert(standardDate1?.getFullYear() === 2023 && standardDate1?.getMonth() === 9 && standardDate1?.getDate() === 27, \"Test 1 Failed: Parsed date incorrect.\");\nconsole.log(\"Test 1 Passed: YYYY-MM-DD to Date conversion.\");\n\n// Test Case 2: Standard Date to MM/DD/YYYY\nconst formattedDate1 = adapter.fromStandard(standardDate1, DateFormats.MM_DD_YYYY);\nconsole.assert(formattedDate1 === '10/27/2023', `Test 2 Failed: Expected '10/27/2023', got '${formattedDate1}'.`);\nconsole.log(\"Test 2 Passed: Date to MM/DD/YYYY conversion.\");\n\n// Test Case 3: DD.MM.YYYY to standard Date\nconst dateString2 = '15.03.2024';\nconst standardDate2 = adapter.toStandard(dateString2, DateFormats.DD_MM_YYYY);\nconsole.assert(standardDate2 instanceof Date && !isNaN(standardDate2.getTime()), `Test 3 Failed: Expected valid Date object, got ${standardDate2}.`);\nconsole.assert(standardDate2?.getFullYear() === 2024 && standardDate2?.getMonth() === 2 && standardDate2?.getDate() === 15, \"Test 3 Failed: Parsed date incorrect for DD.MM.YYYY.\");\nconsole.log(\"Test 3 Passed: DD.MM.YYYY to Date conversion.\");\n\n// Test Case 4: Invalid date string input\nconst invalidDateString = 'not-a-date';\nconst invalidStandardDate = adapter.toStandard(invalidDateString, DateFormats.YYYY_MM_DD);\nconsole.assert(invalidStandardDate === null, \"Test 4 Failed: Invalid date string should return null.\");\nconsole.log(\"Test 4 Passed: Invalid date string handled.\");\n\n// Test Case 5: Invalid Date object input for formatting\nconst formattedInvalidDate = adapter.fromStandard(null, DateFormats.MM_DD_YYYY);\nconsole.assert(formattedInvalidDate === '', \"Test 5 Failed: Invalid Date object for formatting should return empty string.\");\nconsole.log(\"Test 5 Passed: Invalid Date object for formatting handled.\");\n\n// Test Case 6: Full datetime format\nconst dateTimeString = '2023-11-01 14:30:00';\nconst standardDateTime = adapter.toStandard(dateTimeString, DateFormats.FULL_DATETIME);\nconsole.assert(standardDateTime?.getHours() === 14 && standardDateTime?.getMinutes() === 30, \"Test 6 Failed: Full datetime parsing incorrect.\");\nconst formattedDateTime = adapter.fromStandard(standardDateTime, 'HH:mm');\nconsole.assert(formattedDateTime === '14:30', \"Test 6 Failed: Full datetime formatting incorrect.\");\nconsole.log(\"Test 6 Passed: Full datetime format conversion.\");",
        "title": "Create a Date Format Adapter",
        "id": "task_data_format_adapter"
      },
      {
        "learningPath": "advanced",
        "startingCode": "function logExecution<T extends (...args: any[]) => any>(fn: T): T {\n  // TODO: Implement the decorator logic\n  return function(this: any, ...args: Parameters<T>): ReturnType<T> {\n    console.log(`Calling ${fn.name || 'anonymous function'} with arguments:`, args);\n    const result = fn.apply(this, args);\n    console.log(`${fn.name || 'anonymous function'} returned:`, result);\n    return result;\n  } as T;\n}\n\n// Example Usage:\n// @logExecution // (if using TypeScript decorators syntax with tsconfig.json 'experimentalDecorators': true)\n// function add(a: number, b: number): number {\n//   return a + b;\n// }\n// const decoratedAdd = logExecution(add);\n// decoratedAdd(5, 3); \n// Expected console output:\n// Calling add with arguments: [5, 3]\n// add returned: 8\n\n// class MyClass {\n//   @logExecution\n//   greet(name: string): string {\n//     return `Hello, ${name}!`;\n//   }\n// }\n// const instance = new MyClass();\n// instance.greet('World');\n",
        "interviewRelevance": 9,
        "difficulty": "medium",
        "description": "\nCreate a decorator function that adds logging capabilities to any given function. The decorator should log the function's arguments before execution and its return value after execution.\n\n**Requirements:**\n1.  Define a `logExecution` decorator function.\n2.  `logExecution` should take a target function as an argument and return a new function.\n3.  The new function should log a message like `Calling [functionName] with arguments: [args]` before calling the original function.\n4.  After the original function executes, it should log `[functionName] returned: [returnValue]`.\n5.  The decorator must preserve the original function's `this` context and arguments.\n",
        "testCases": [
          "Decorate a simple function with arguments and a return value.",
          "Decorate a function with no arguments and no explicit return value (void).",
          "Decorate a method of a class to ensure `this` context is correctly preserved.",
          "Decorate a function that throws an error (the decorator should re-throw the error).",
          "Decorate an anonymous arrow function."
        ],
        "prerequisites": [
          "javascript_functions",
          "this_keyword",
          "typescript_generics"
        ],
        "id": "task_decorator_logging",
        "relatedConcepts": [
          "aspect_oriented_programming",
          "middleware",
          "proxies"
        ],
        "timeEstimate": 75,
        "hints": [
          "The `apply()` method is crucial for invoking the original function with the correct `this` context and arguments.",
          "Use `fn.name` to get the function's name for logging; provide a fallback for anonymous functions.",
          "Wrap the function call in a `try...catch` block to handle errors gracefully and re-throw them."
        ],
        "solutionCode": "function logExecution<T extends (...args: any[]) => any>(fn: T): T {\n  return function(this: any, ...args: Parameters<T>): ReturnType<T> {\n    const functionName = fn.name || 'anonymous function';\n    console.log(`Calling ${functionName} with arguments:`, args);\n    try {\n      const result = fn.apply(this, args); // Preserve 'this' context and arguments\n      console.log(`${functionName} returned:`, result);\n      return result;\n    } catch (error) {\n      console.error(`${functionName} threw an error:`, error);\n      throw error; // Re-throw the error to not alter original function's behavior\n    }\n  } as T; // Type assertion to ensure the returned function matches the input function's type\n}\n\n// Example Usage & Test Cases:\n\n// Test Case 1: Simple function decoration\nfunction add(a: number, b: number): number {\n  return a + b;\n}\nconst decoratedAdd = logExecution(add);\nconsole.log(\"--- Testing decoratedAdd ---\");\nconst addResult = decoratedAdd(5, 3);\nconsole.assert(addResult === 8, `Test 1 Failed: Expected 8, got ${addResult}.`);\nconsole.log(\"Test 1 Passed: Basic decoration works.\");\n\n// Test Case 2: Function with no arguments and no return value\nfunction sayHello(): void {\n  console.log('Hello!');\n}\nconst decoratedSayHello = logExecution(sayHello);\nconsole.log(\"--- Testing decoratedSayHello ---\");\ndecoratedSayHello();\nconsole.log(\"Test 2 Passed: No arguments/return value handled.\");\n\n// Test Case 3: Function with 'this' context\nclass Calculator {\n  private factor: number;\n  constructor(factor: number) {\n    this.factor = factor;\n  }\n  multiply(a: number): number {\n    return a * this.factor;\n  }\n}\nconst calc = new Calculator(10);\nconst decoratedMultiply = logExecution(calc.multiply); // Note: 'this' will be lost here if not bound\n// To preserve 'this' when decorating a method, one common way is to decorate the instance method directly:\ncalc.multiply = logExecution(calc.multiply);\n\nconsole.log(\"--- Testing decoratedMultiply (method) ---\");\nconst multiplyResult = calc.multiply(7);\nconsole.assert(multiplyResult === 70, `Test 3 Failed: Expected 70, got ${multiplyResult}.`);\nconsole.log(\"Test 3 Passed: 'this' context preserved for method.\");\n\n// Test Case 4: Function that throws an error\nfunction divide(a: number, b: number): number {\n  if (b === 0) {\n    throw new Error('Division by zero!');\n  }\n  return a / b;\n}\nconst decoratedDivide = logExecution(divide);\nconsole.log(\"--- Testing decoratedDivide (error) ---\");\ntry {\n  decoratedDivide(10, 0);\n  console.assert(false, \"Test 4 Failed: Expected an error, but none was thrown.\");\n} catch (e: any) {\n  console.assert(e.message === 'Division by zero!', \"Test 4 Failed: Incorrect error message.\");\n  console.log(\"Test 4 Passed: Error handling works.\");\n}\n\n// Test Case 5: Arrow function (anonymous)\nconst subtract = (a: number, b: number) => a - b;\nconst decoratedSubtract = logExecution(subtract);\nconsole.log(\"--- Testing decoratedSubtract (anonymous) ---\");\nconst subtractResult = decoratedSubtract(10, 3);\nconsole.assert(subtractResult === 7, `Test 5 Failed: Expected 7, got ${subtractResult}.`);\nconsole.log(\"Test 5 Passed: Anonymous function handling works.\");",
        "tags": [
          "decorator",
          "design-patterns",
          "higher-order-functions",
          "logging",
          "javascript",
          "typescript"
        ],
        "complexity": 8,
        "title": "Implement a Logging Decorator for a Function"
      },
      {
        "solutionCode": "interface ButtonComponent {\n  render(): string;\n}\n\nclass BasicButton implements ButtonComponent {\n  constructor(private text: string) {}\n\n  render(): string {\n    return `<button>${this.text}</button>`;\n  }\n}\n\n// Decorator functions\nfunction withPrimaryStyle(button: ButtonComponent): ButtonComponent {\n  return {\n    render: () => {\n      const originalRender = button.render();\n      return originalRender.replace('<button', '<button class=\"btn-primary\"');\n    }\n  };\n}\n\nfunction withDisabledState(button: ButtonComponent): ButtonComponent {\n  return {\n    render: () => {\n      const originalRender = button.render();\n      return originalRender.replace('<button', '<button disabled');\n    }\n  };\n}\n\nfunction withLoadingState(button: ButtonComponent): ButtonComponent {\n  return {\n    render: () => {\n      const originalRender = button.render();\n      // Add aria-busy for accessibility, and potentially a 'loading' class\n      return originalRender.replace('<button', '<button aria-busy=\"true\" class=\"is-loading\"');\n    }\n  };\n}\n\n// Helper to clean up HTML for assertions (removes multiple spaces/newlines)\nconst cleanHtml = (html: string) => html.replace(/\\s+/g, ' ').trim();\n\n// Example Usage & Test Cases:\n\n// Test Case 1: Basic Button\nconst basicBtn = new BasicButton('Click Me');\nconsole.assert(cleanHtml(basicBtn.render()) === '<button>Click Me</button>', \"Test 1 Failed: Basic button render incorrect.\");\nconsole.log(\"Test 1 Passed: Basic Button.\");\n\n// Test Case 2: Primary Style Decorator\nconst primaryBtn = withPrimaryStyle(new BasicButton('Primary'));\nconsole.assert(cleanHtml(primaryBtn.render()) === '<button class=\"btn-primary\">Primary</button>', \"Test 2 Failed: Primary style incorrect.\");\nconsole.log(\"Test 2 Passed: Primary Style.\");\n\n// Test Case 3: Disabled State Decorator\nconst disabledBtn = withDisabledState(new BasicButton('Disabled'));\nconsole.assert(cleanHtml(disabledBtn.render()) === '<button disabled>Disabled</button>', \"Test 3 Failed: Disabled state incorrect.\");\nconsole.log(\"Test 3 Passed: Disabled State.\");\n\n// Test Case 4: Loading State Decorator\nconst loadingBtn = withLoadingState(new BasicButton('Loading'));\n// Note: This decorator also adds 'class=\"is-loading\"' along with aria-busy\nconsole.assert(cleanHtml(loadingBtn.render()) === '<button aria-busy=\"true\" class=\"is-loading\">Loading</button>', \"Test 4 Failed: Loading state incorrect.\");\nconsole.log(\"Test 4 Passed: Loading State.\");\n\n// Test Case 5: Chaining Decorators (Primary & Disabled)\nconst primaryDisabledBtn = withDisabledState(withPrimaryStyle(new BasicButton('Submit')));\n// Order of classes and attributes might vary based on implementation. Focus on presence.\nconst expectedPrimaryDisabled = '<button class=\"btn-primary\" disabled>Submit</button>';\nconst actualPrimaryDisabled = cleanHtml(primaryDisabledBtn.render());\nconsole.assert(actualPrimaryDisabled.includes('class=\"btn-primary\"') && actualPrimaryDisabled.includes('disabled') && actualPrimaryDisabled.includes('>Submit</button>'), `Test 5 Failed: Chained Primary & Disabled incorrect. Got '${actualPrimaryDisabled}'`);\nconsole.log(\"Test 5 Passed: Chained Primary & Disabled.\");\n\n// Test Case 6: Chaining All Decorators\nconst allDecoratedBtn = withLoadingState(withDisabledState(withPrimaryStyle(new BasicButton('Final'))));\nconst actualAllDecorated = cleanHtml(allDecoratedBtn.render());\nconsole.assert(actualAllDecorated.includes('class=\"btn-primary is-loading\"') && actualAllDecorated.includes('disabled') && actualAllDecorated.includes('aria-busy=\"true\"') && actualAllDecorated.includes('>Final</button>'), `Test 6 Failed: Chained All incorrect. Got '${actualAllDecorated}'`);\nconsole.log(\"Test 6 Passed: Chained All Decorators.\");\n\n// Test Case 7: Order of decorators matters for class attribute (if not merged intelligently)\n// This simple implementation will overwrite 'class' if not careful. \n// A more robust solution would parse attributes, merge classes.\n// For this task, we can accept if 'class' is overwritten by subsequent decorators.\nconst loadingThenPrimary = withPrimaryStyle(withLoadingState(new BasicButton('Order Test')));\nconst actualLoadingThenPrimary = cleanHtml(loadingThenPrimary.render());\nconsole.assert(actualLoadingThenPrimary.includes('class=\"btn-primary\"') && !actualLoadingThenPrimary.includes('is-loading'), \"Test 7 Failed: Class overwriting not as expected.\");\nconsole.log(\"Test 7 Passed: Order of decorators (class overwriting) noted.\");",
        "description": "\nImagine you have a basic `Button` component. You need to dynamically add different styling properties (e.g., `primary`, `disabled`, `loading`) without creating a separate component for each combination. Implement a `createButton` factory function and then create decorator functions to apply these styles.\n\n**Requirements:**\n1.  Define a `ButtonComponent` interface with a `render(): string` method (which returns an HTML string for simplicity).\n2.  Implement a `BasicButton` class that implements `ButtonComponent` and renders a simple button HTML.\n3.  Create decorator functions: `withPrimaryStyle`, `withDisabledState`, `withLoadingState`.\n4.  Each decorator should take a `ButtonComponent` instance and return a *new* `ButtonComponent` instance that wraps the original, adding or modifying its `render` output to include specific styles or attributes (e.g., adding classes, setting `disabled` attribute).\n5.  Demonstrate combining multiple decorators.\n",
        "learningPath": "advanced",
        "tags": [
          "decorator",
          "design-patterns",
          "ui-components",
          "frontend",
          "javascript",
          "typescript",
          "html-manipulation"
        ],
        "hints": [
          "Each decorator function should return a *new* object that implements `ButtonComponent`.",
          "Inside the decorator's `render` method, call `button.render()` to get the current HTML, then use string manipulation (`replace`, regex) to add attributes/classes.",
          "For handling `class` attributes more robustly, you might parse the HTML string, extract existing classes, add new ones, and then rebuild the tag, but simple `replace` is sufficient for this task's scope.",
          "Ensure the returned object maintains the `ButtonComponent` interface, even if it's an anonymous object literal with just a `render` method."
        ],
        "complexity": 9,
        "relatedConcepts": [
          "hoc",
          "render_props",
          "component_composition"
        ],
        "timeEstimate": 90,
        "testCases": [
          "Render `BasicButton` without decorators.",
          "Apply `withPrimaryStyle` and check the output HTML for the correct class.",
          "Apply `withDisabledState` and check for the `disabled` attribute.",
          "Apply `withLoadingState` and check for `aria-busy` and loading class.",
          "Chain `withPrimaryStyle` and `withDisabledState` and verify both attributes are present.",
          "Chain all three decorators (`withPrimaryStyle`, `withDisabledState`, `withLoadingState`) and verify all expected attributes/classes are present.",
          "Test for immutability: ensure applying a decorator to one button instance doesn't affect other instances of `BasicButton` or previously decorated buttons.",
          "Consider how `class` attributes are handled when multiple decorators add classes (e.g., simple string replacement might overwrite existing classes; a more advanced solution would merge them)."
        ],
        "title": "Decorate a UI Component with Dynamic Styles",
        "startingCode": "interface ButtonComponent {\n  render(): string;\n}\n\nclass BasicButton implements ButtonComponent {\n  constructor(private text: string) {}\n\n  render(): string {\n    return `<button>${this.text}</button>`;\n  }\n}\n\n// Decorator functions (TODO: Implement these)\n// function withPrimaryStyle(button: ButtonComponent): ButtonComponent { /* ... */ }\n// function withDisabledState(button: ButtonComponent): ButtonComponent { /* ... */ }\n// function withLoadingState(button: ButtonComponent): ButtonComponent { /* ... */ }\n\n// Example Usage:\n// const myButton = new BasicButton('Click Me');\n// console.log(myButton.render()); // <button>Click Me</button>\n\n// const primaryButton = withPrimaryStyle(myButton);\n// console.log(primaryButton.render()); // <button class=\"btn-primary\">Click Me</button>\n\n// const primaryDisabledLoadingButton = withLoadingState(withDisabledState(withPrimaryStyle(new BasicButton('Submit'))));\n// console.log(primaryDisabledLoadingButton.render()); // <button class=\"btn-primary\" disabled aria-busy=\"true\">Submit</button>\n",
        "id": "task_decorator_ui_component",
        "interviewRelevance": 9,
        "difficulty": "hard",
        "prerequisites": [
          "object_oriented_programming",
          "typescript_interfaces",
          "string_manipulation"
        ]
      }
    ],
    "endLine": 300,
    "processedDate": "2025-06-15T08:55:21.333Z",
    "id": "chunk_200_299_1749977721335",
    "completed": false,
    "theory": [
      {
        "examples": [
          {
            "id": "example_singleton_1",
            "language": "typescript",
            "code": "const Singleton = (function() {\n  let instance;\n  \n  function createInstance() {\n    // Private methods and properties for the singleton instance\n    return {\n      data: [],\n      addItem: function(item) {\n        this.data.push(item);\n      },\n      getData: function() {\n        return [...this.data]; // Return a copy to prevent external modification of the internal array\n      }\n    };\n  }\n  \n  return {\n    getInstance: function() {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return instance;\n    }\n  };\n})();\n\n// Usage\nconst instance1 = Singleton.getInstance();\nconst instance2 = Singleton.getInstance();\n\nconsole.log(instance1 === instance2); // true\n\ninstance1.addItem('item A');\ninstance2.addItem('item B'); // Both instances reference the same underlying data\nconsole.log(instance1.getData()); // ['item A', 'item B']\nconsole.log(instance2.getData()); // ['item A', 'item B']",
            "title": "Basic Singleton Implementation",
            "explanation": "This example demonstrates the classic JavaScript Singleton pattern using an IIFE. The `createInstance` function defines the actual singleton object's structure. The `getInstance` method acts as the gatekeeper, ensuring that `createInstance` is called only once. Subsequent calls to `getInstance` return the same previously created object, as confirmed by `instance1 === instance2` evaluating to `true`."
          }
        ],
        "content": "The Singleton pattern is a creational design pattern that ensures a class has only one instance and provides a global point of access to that instance. It is particularly useful when exactly one object is needed to coordinate actions across the system, such as a logger, configuration manager, or a database connection pool.\n\n## Key Concepts\n- **Single Instance**: Guarantees that only one instance of the class can be created.\n- **Global Access**: Provides a well-known global point of access to that single instance.\n- **Lazy Initialization**: The instance is often created only when it's requested for the first time (lazy loading), rather than at application startup.\n\n## Implementation Details\nIn JavaScript, the Singleton pattern is commonly implemented using a closure and an Immediately Invoked Function Expression (IIFE). The IIFE creates a private scope for the `instance` variable, ensuring it cannot be accessed directly from outside. The `getInstance` method checks if `instance` already exists. If not, it creates a new one; otherwise, it returns the existing one.\n\nThis approach prevents multiple instantiations and provides a single, consistent object across the application lifecycle. While effective, it's important to consider potential issues like testability and global state management.\n",
        "learningPath": "intermediate",
        "prerequisites": [
          "javascript_closures",
          "javascript_iife",
          "object_oriented_programming"
        ],
        "complexity": 7,
        "technology": "JavaScript",
        "tags": [
          "design-patterns",
          "creational",
          "singleton",
          "javascript",
          "iife",
          "closures"
        ],
        "requiredFor": [
          "advanced_design_patterns",
          "system_architecture"
        ],
        "id": "theory_singleton_pattern",
        "interviewRelevance": 8,
        "relatedQuestions": [
          "question_singleton_1",
          "question_singleton_2",
          "question_singleton_3",
          "question_singleton_4"
        ],
        "title": "Singleton Pattern",
        "relatedTasks": [
          "task_singleton_logger",
          "task_singleton_config_manager"
        ]
      },
      {
        "tags": [
          "design-patterns",
          "structural",
          "adapter",
          "javascript",
          "oop"
        ],
        "relatedTasks": [
          "task_api_adapter",
          "task_data_format_adapter"
        ],
        "relatedQuestions": [
          "question_adapter_1",
          "question_adapter_2",
          "question_adapter_3",
          "question_adapter_4"
        ],
        "prerequisites": [
          "object_oriented_programming",
          "interfaces_concepts"
        ],
        "interviewRelevance": 8,
        "examples": [
          {
            "explanation": "This example showcases how `CalcAdapter` bridges the `OldCalculator`'s `operate` interface (which takes `term1`, `term2`, and `operation` as a string) with `NewCalculator`'s separate `add` and `sub` methods. The `CalcAdapter` translates the `operation` string into the appropriate method call on the `NewCalculator` instance it holds, allowing code written for `OldCalculator` to seamlessly interact with `NewCalculator` through the adapter.",
            "code": "class OldCalculator {\n  operate(term1, term2, operation) {\n    switch(operation) {\n      case 'add': return term1 + term2;\n      case 'sub': return term1 - term2;\n      default: return NaN;\n    }\n  }\n}\n\nclass NewCalculator {\n  add(term1, term2) {\n    return term1 + term2;\n  }\n  \n  sub(term1, term2) {\n    return term1 - term2;\n  }\n}\n\n// Adapter\nclass CalcAdapter {\n  constructor() {\n    this.calc = new NewCalculator();\n  }\n  \n  operate(term1, term2, operation) {\n    switch(operation) {\n      case 'add': return this.calc.add(term1, term2);\n      case 'sub': return this.calc.sub(term1, term2);\n      default: return NaN;\n    }\n  }\n}\n\n// Usage with OldCalculator\nconst oldCalc = new OldCalculator();\nconsole.log(oldCalc.operate(10, 5, 'add')); // 15\n\n// Usage with Adapter for NewCalculator\nconst newCalcAdapter = new CalcAdapter();\nconsole.log(newCalcAdapter.operate(10, 5, 'add')); // 15\nconsole.log(newCalcAdapter.operate(10, 5, 'sub')); // 5\nconsole.log(newCalcAdapter.operate(10, 5, 'mul')); // NaN (as per current adapter logic)",
            "id": "example_adapter_1",
            "title": "Calculator Adapter",
            "language": "typescript"
          }
        ],
        "complexity": 7,
        "title": "Adapter Pattern",
        "technology": "JavaScript",
        "content": "The Adapter pattern is a structural design pattern that allows objects with incompatible interfaces to collaborate. It acts as a bridge between two incompatible interfaces, translating the interface of one class into another interface that a client expects. This pattern is particularly useful when you need to integrate existing classes that cannot be modified (e.g., third-party libraries, legacy code) with new code that expects a different interface.\n\n## Key Concepts\n- **Target Interface**: The interface that the client expects.\n- **Adaptee**: The existing class with the incompatible interface.\n- **Adapter**: The class that implements the target interface and wraps the adaptee, translating client requests into calls that the adaptee can understand.\n\n## Implementation Details\nAn adapter works by wrapping an instance of the Adaptee class and then implementing the Target interface. When a client calls a method on the adapter (using the Target interface), the adapter translates this call into one or more calls to the Adaptee's methods, effectively making the Adaptee compatible with the Target interface.\n\nThere are two main types:\n1.  **Object Adapter**: The adapter holds an instance of the adaptee (composition).\n2.  **Class Adapter**: The adapter inherits from both the adaptee and the target interface (not directly supported in JavaScript classes in the same way as classical OOP languages, but composition is the common approach).\n\nThe provided example uses an Object Adapter, where `CalcAdapter` contains an instance of `NewCalculator`.\n",
        "id": "theory_adapter_pattern",
        "learningPath": "intermediate",
        "requiredFor": [
          "integration_patterns",
          "legacy_system_integration"
        ]
      },
      {
        "examples": [
          {
            "id": "example_decorator_1",
            "language": "typescript",
            "title": "Coffee Shop Decorator",
            "explanation": "This example illustrates the Decorator pattern by allowing dynamic additions to a `Coffee` object. The `Milk` and `Whip` functions are decorators. They take a `coffee` object, capture its current cost and description, and then redefine the `cost` and `getDescription` methods to include their own specific additions. This way, you can compose different 'toppings' onto a coffee dynamically, building up its total cost and description without modifying the base `Coffee` class or creating a complex inheritance hierarchy (e.g., `MilkCoffee`, `WhipCoffee`, `MilkWhipCoffee`).",
            "code": "function Coffee() {\n  this.cost = function() {\n    return 5;\n  };\n  this.getDescription = function() {\n    return \"Simple Coffee\";\n  };\n}\n\nfunction Milk(coffee) {\n  const originalCost = coffee.cost();\n  const originalGetDescription = coffee.getDescription();\n  coffee.cost = function() {\n    return originalCost + 1; // Add cost of milk\n  };\n  coffee.getDescription = function() {\n    return originalGetDescription + \", Milk\"; // Add description of milk\n  };\n}\n\nfunction Whip(coffee) {\n  const originalCost = coffee.cost();\n  const originalGetDescription = coffee.getDescription();\n  coffee.cost = function() {\n    return originalCost + 0.5; // Add cost of whip\n  };\n  coffee.getDescription = function() {\n    return originalGetDescription + \", Whip\"; // Add description of whip\n  };\n}\n\n// Usage\nconst myCoffee = new Coffee();\nconsole.log(`Cost: ${myCoffee.cost()}, Description: ${myCoffee.getDescription()}`); // Cost: 5, Description: Simple Coffee\n\nMilk(myCoffee); // Decorate with Milk\nconsole.log(`Cost: ${myCoffee.cost()}, Description: ${myCoffee.getDescription()}`); // Cost: 6, Description: Simple Coffee, Milk\n\nWhip(myCoffee); // Decorate with Whip\nconsole.log(`Cost: ${myCoffee.cost()}, Description: ${myCoffee.getDescription()}`); // Cost: 6.5, Description: Simple Coffee, Milk, Whip"
          }
        ],
        "content": "The Decorator pattern is a structural design pattern that allows behavior to be added to an individual object, dynamically, without affecting the behavior of other objects from the same class. It provides a flexible alternative to subclassing for extending functionality.\n\n## Key Concepts\n- **Component**: The interface or abstract class defining operations that can be decorated. This is the core object being enhanced.\n- **Concrete Component**: A concrete implementation of the Component, the actual object being decorated.\n- **Decorator**: An abstract class or interface that maintains a reference to a Component object and conforms to the Component's interface. It forwards requests to the Component.\n- **Concrete Decorator**: Specific decorator implementations that add responsibilities to the component.\n\n## Implementation Details\nIn JavaScript, decorators are often implemented using functions that take an object, add new properties or modify existing ones (like methods), and then return the modified object. This is a form of functional composition or dynamic monkey-patching. The key idea is to wrap an object with other objects that add new functionalities, without changing the original object's class or deeply modifying its structure.\n\nThis pattern is very powerful for adding features like logging, caching, authentication, or even UI enhancements (e.g., adding scrollbars or borders dynamically) without creating a complex hierarchy of subclasses. It adheres to the Open/Closed Principle (open for extension, closed for modification).\n",
        "id": "theory_decorator_pattern",
        "title": "Decorator Pattern",
        "requiredFor": [
          "middleware_development",
          "aspect_oriented_programming_concepts"
        ],
        "complexity": 8,
        "relatedQuestions": [
          "question_decorator_1",
          "question_decorator_2",
          "question_decorator_3",
          "question_decorator_4"
        ],
        "prerequisites": [
          "object_oriented_programming",
          "javascript_functions_as_first_class_citizens"
        ],
        "technology": "JavaScript",
        "relatedTasks": [
          "task_decorator_logging",
          "task_decorator_ui_component"
        ],
        "tags": [
          "design-patterns",
          "structural",
          "decorator",
          "javascript",
          "oop",
          "functional-programming"
        ],
        "interviewRelevance": 8,
        "learningPath": "intermediate"
      }
    ],
    "questions": [
      {
        "options": [
          "To ensure that a class has only one instance and provides a global point of access to it.",
          "To allow an object to alter its behavior when its internal state changes.",
          "To convert the interface of a class into another interface clients expect.",
          "To compose objects into tree structures to represent part-whole hierarchies."
        ],
        "evaluationCriteria": [
          "Understanding of fundamental principles",
          "Ability to distinguish between similar concepts"
        ],
        "tags": [
          "singleton",
          "design-patterns",
          "mcq"
        ],
        "interviewFrequency": 7,
        "id": "question_singleton_1",
        "analysisPoints": [
          "Tests fundamental understanding of Singleton's goal.",
          "Distracters relate to other common design patterns (State, Adapter, Composite).",
          "Highlights the 'single instance' and 'global access' characteristics."
        ],
        "type": "mcq",
        "prerequisites": [
          "object_oriented_programming"
        ],
        "question": "What is the primary purpose of the Singleton design pattern?",
        "learningPath": "beginner",
        "topic": "Singleton Pattern Fundamentals",
        "keyConcepts": [
          "Singleton Pattern",
          "Creational Design Patterns",
          "Unique Instance",
          "Global Access"
        ],
        "complexity": 3,
        "level": "easy",
        "answer": "To ensure that a class has only one instance and provides a global point of access to it."
      },
      {
        "type": "code",
        "learningPath": "intermediate",
        "interviewFrequency": 8,
        "options": [],
        "analysisPoints": [
          "Checks understanding of closure and IIFE in Singleton context.",
          "Requires explanation of state management (`instance` variable).",
          "Evaluates knowledge of JavaScript's module pattern mechanics."
        ],
        "evaluationCriteria": [
          "Understanding of JavaScript scope and closures",
          "Ability to explain design pattern implementation details",
          "Recognition of core components and their roles"
        ],
        "keyConcepts": [
          "Singleton Pattern",
          "JavaScript Closures",
          "IIFE (Immediately Invoked Function Expression)",
          "Scope",
          "Encapsulation"
        ],
        "id": "question_singleton_2",
        "topic": "Singleton Implementation in JavaScript",
        "prerequisites": [
          "javascript_closures",
          "javascript_iife"
        ],
        "complexity": 6,
        "question": "Consider the following JavaScript Singleton implementation. Explain how the `instance` variable ensures only one object is created, and what role the IIFE plays in this pattern.",
        "level": "medium",
        "answer": "The `instance` variable acts as a flag and a container for the single instance. It is initialized to `undefined`. The `getInstance` method checks `if (!instance)`. On the first call, `instance` is `undefined`, so `createInstance()` is called, and its result is assigned to `instance`. On subsequent calls, `instance` will already hold the created object, so the `if` condition evaluates to `false`, and the existing `instance` is directly returned. This prevents `createInstance()` from being called more than once. The IIFE (Immediately Invoked Function Expression) creates a private scope for `instance` and `createInstance()`. This encapsulation prevents `instance` from being accidentally modified or accessed from outside the Singleton module, reinforcing the pattern's guarantee of a single point of access.",
        "example": "```javascript\nconst Singleton = (function() {\n  let instance; // The key to holding the single instance\n  \n  function createInstance() {\n    return { id: Math.random() }; // A unique object\n  }\n  \n  return {\n    getInstance: function() {\n      if (!instance) { // Check if instance already exists\n        instance = createInstance(); // Create only if it doesn't\n      }\n      return instance; // Always return the same instance\n    }\n  };\n})();\n\nconst obj1 = Singleton.getInstance();\nconst obj2 = Singleton.getInstance();\nconsole.log(obj1 === obj2); // Expected: true\n```",
        "tags": [
          "singleton",
          "javascript",
          "closure",
          "iife",
          "open-ended"
        ]
      },
      {
        "answer": "**Use Cases:**\n1.  **Configuration Manager**: An application might need a single, globally accessible object to store and manage configuration settings (e.g., API keys, theme preferences, environment variables). A Singleton ensures all parts of the application read from and write to the same configuration source.\n2.  **Global Event Bus/Logger**: For debugging or inter-component communication, a single instance of an event bus or a logging service ensures that all events are routed through one central point or all log messages are collected by a single entity, making it easier to monitor and debug the application.\n\n**Drawbacks:**\n1.  **Global State and Testability**: Singletons introduce global state, which can make unit testing difficult. Tests might interfere with each other if they modify the same singleton instance. It becomes harder to isolate tests, leading to brittle tests and potential order dependencies.\n2.  **Tight Coupling**: Components that use a Singleton are tightly coupled to that specific singleton implementation. This reduces flexibility, makes it harder to swap out implementations, and can hinder code reusability. Dependency Injection is often preferred to manage dependencies more loosely.\n3.  **Scalability/Concurrency (less critical in single-threaded JS, but still applies conceptually)**: While JavaScript's single-threaded nature in browsers mitigates some multi-threading concerns, managing shared state in complex applications with web workers or async operations can still introduce complexities. Overuse can make code harder to reason about and maintain.\n4.  **Misuse as a Global Variable**: Developers might use Singletons simply as a glorified global variable, leading to a sprawling global state that's hard to track and debug, diminishing the benefits of modularity.",
        "complexity": 8,
        "evaluationCriteria": [
          "Ability to apply concepts to real-world scenarios",
          "Critical thinking about design choices",
          "Knowledge of software quality attributes (testability, maintainability)"
        ],
        "interviewFrequency": 9,
        "options": [],
        "tags": [
          "singleton",
          "design-patterns",
          "open-ended",
          "architecture",
          "trade-offs"
        ],
        "type": "open",
        "prerequisites": [
          "software_design_principles",
          "unit_testing"
        ],
        "level": "hard",
        "question": "Provide two practical use cases for the Singleton pattern in a frontend application. Additionally, discuss at least two potential drawbacks or reasons to avoid the Singleton pattern.",
        "id": "question_singleton_3",
        "keyConcepts": [
          "Singleton Pattern",
          "Global State",
          "Testability",
          "Tight Coupling",
          "Design Principles",
          "Use Cases",
          "Drawbacks"
        ],
        "learningPath": "advanced",
        "analysisPoints": [
          "Tests ability to identify appropriate design pattern applications.",
          "Evaluates critical thinking regarding pattern's disadvantages.",
          "Demonstrates understanding of testability and coupling concerns in software design."
        ],
        "topic": "Singleton Use Cases and Drawbacks"
      },
      {
        "tags": [
          "singleton",
          "javascript",
          "modules",
          "flashcard"
        ],
        "interviewFrequency": 6,
        "question": "What is the key difference between a JavaScript Singleton implemented with an IIFE and simply exporting a plain object literal directly?",
        "options": [],
        "learningPath": "intermediate",
        "evaluationCriteria": [
          "Understanding of JavaScript module system",
          "Ability to compare and contrast design patterns and language features",
          "Recognition of performance considerations"
        ],
        "type": "flashcard",
        "analysisPoints": [
          "Distinguishes between implicit module caching and explicit Singleton pattern.",
          "Highlights the concept of lazy loading as a benefit of explicit Singleton.",
          "Explores nuances of JavaScript module system."
        ],
        "complexity": 7,
        "level": "medium",
        "prerequisites": [
          "javascript_modules"
        ],
        "answer": "A plain object literal exported directly is a form of Singleton by default in JavaScript modules, as modules are cached and initialized only once. However, the IIFE-based Singleton pattern explicitly provides a `getInstance` method that encapsulates the creation logic and ensures lazy instantiation. A plain exported object is instantiated immediately upon module import, whereas the `getInstance` method allows for the instance to be created only when it's first requested. This lazy loading can be beneficial for performance if the singleton's initialization is expensive and not always needed.",
        "id": "question_singleton_4",
        "keyConcepts": [
          "Singleton Pattern",
          "JavaScript Modules",
          "Lazy Loading",
          "IIFE",
          "Object Literals"
        ],
        "topic": "Singleton vs. Plain Object"
      },
      {
        "options": [
          "Integrating an old library with a new codebase that expects a different function signature.",
          "Ensuring only one instance of a class exists throughout the application.",
          "Adding new responsibilities to objects dynamically.",
          "Simplifying the interface to a complex subsystem."
        ],
        "tags": [
          "adapter",
          "design-patterns",
          "mcq"
        ],
        "answer": "Integrating an old library with a new codebase that expects a different function signature.",
        "keyConcepts": [
          "Adapter Pattern",
          "Structural Design Patterns",
          "Interface Compatibility",
          "Legacy Code Integration"
        ],
        "type": "mcq",
        "analysisPoints": [
          "Tests fundamental understanding of Adapter's goal (interface compatibility).",
          "Distracters refer to Singleton, Decorator, and Facade patterns.",
          "Focuses on the 'incompatible interfaces' aspect."
        ],
        "complexity": 3,
        "prerequisites": [
          "object_oriented_programming"
        ],
        "topic": "Adapter Pattern Purpose",
        "interviewFrequency": 7,
        "evaluationCriteria": [
          "Understanding of fundamental principles",
          "Ability to distinguish between similar concepts"
        ],
        "id": "question_adapter_1",
        "question": "Which scenario best describes the primary use case for the Adapter pattern?",
        "learningPath": "beginner",
        "level": "easy"
      },
      {
        "interviewFrequency": 8,
        "complexity": 6,
        "keyConcepts": [
          "Adapter Pattern",
          "Target Interface",
          "Adaptee",
          "Adapter",
          "Object Adapter",
          "Composition"
        ],
        "evaluationCriteria": [
          "Ability to identify pattern components in code",
          "Understanding of how the pattern facilitates interaction"
        ],
        "type": "open",
        "example": "```typescript\n// Original: OldCalculator (Target Interface concept)\nclass OldCalculator {\n  operate(term1, term2, operation) { /* ... */ }\n}\n\n// New: NewCalculator (Adaptee)\nclass NewCalculator {\n  add(term1, term2) { /* ... */ }\n  sub(term1, term2) { /* ... */ }\n}\n\n// Adapter\nclass CalcAdapter {\n  constructor() {\n    this.calc = new NewCalculator(); // Holds Adaptee instance\n  }\n  operate(term1, term2, operation) { // Implements Target Interface\n    switch(operation) {\n      case 'add': return this.calc.add(term1, term2);\n      case 'sub': return this.calc.sub(term1, term2);\n      default: return NaN;\n    }\n  }\n}\n```",
        "level": "medium",
        "tags": [
          "adapter",
          "design-patterns",
          "open-ended",
          "structure"
        ],
        "options": [],
        "prerequisites": [
          "object_oriented_programming"
        ],
        "analysisPoints": [
          "Checks understanding of Adapter pattern roles.",
          "Requires analysis of specific code components.",
          "Evaluates ability to describe interaction flow."
        ],
        "answer": "-   **Target Interface**: The `operate(term1, term2, operation)` method signature, as defined by `OldCalculator` and expected by clients who previously used `OldCalculator`.\n-   **Adaptee**: The `NewCalculator` class, which has `add(term1, term2)` and `sub(term1, term2)` methods, making it incompatible with the `operate` interface.\n-   **Adapter**: The `CalcAdapter` class. It implements the `operate` method (the Target Interface) and internally holds an instance of `NewCalculator` (the Adaptee). When `CalcAdapter.operate` is called, it translates the single `operation` string into the appropriate `add` or `sub` method call on its `NewCalculator` instance, effectively 'adapting' `NewCalculator` to the `OldCalculator`'s interface.",
        "id": "question_adapter_2",
        "question": "In the provided `CalcAdapter` example, identify the 'Target Interface', the 'Adaptee', and the 'Adapter'. Explain how they interact.",
        "learningPath": "intermediate",
        "topic": "Adapter Pattern Structure"
      },
      {
        "level": "hard",
        "options": [
          "The Adapter pattern converts one interface into another, while the Facade pattern provides a simplified, higher-level interface to a complex subsystem.",
          "The Adapter pattern adds new functionalities dynamically, while the Facade pattern ensures only one instance of a class exists.",
          "The Adapter pattern is primarily for legacy code integration, while the Facade pattern is only for new system design.",
          "The Adapter pattern promotes loose coupling, while the Facade pattern inherently creates tight coupling."
        ],
        "analysisPoints": [
          "Requires distinguishing between two similar structural patterns.",
          "Focuses on their core intent rather than implementation details.",
          "Distracters include incorrect descriptions of Adapter/Facade or refer to other patterns."
        ],
        "tags": [
          "adapter",
          "facade",
          "design-patterns",
          "mcq",
          "comparison"
        ],
        "complexity": 7,
        "topic": "Adapter vs. Facade",
        "keyConcepts": [
          "Adapter Pattern",
          "Facade Pattern",
          "Interface Conversion",
          "Subsystem Simplification",
          "Design Pattern Comparison"
        ],
        "question": "While both Adapter and Facade patterns involve simplifying interfaces, what is the fundamental difference in their primary goal?",
        "interviewFrequency": 7,
        "answer": "The Adapter pattern converts one interface into another, while the Facade pattern provides a simplified, higher-level interface to a complex subsystem.",
        "learningPath": "advanced",
        "id": "question_adapter_3",
        "evaluationCriteria": [
          "Ability to differentiate between related design patterns",
          "Understanding of specific use cases for each pattern"
        ],
        "prerequisites": [
          "adapter_pattern",
          "facade_pattern_knowledge"
        ],
        "type": "mcq"
      },
      {
        "topic": "Adapter Pattern Benefits",
        "options": [],
        "prerequisites": [
          "adapter_pattern"
        ],
        "learningPath": "intermediate",
        "level": "medium",
        "tags": [
          "adapter",
          "design-patterns",
          "flashcard"
        ],
        "answer": "1.  **Reusability**: Allows existing classes to be reused with new clients or systems that expect a different interface, without modifying the original class's source code.\n2.  **Flexibility/Interoperability**: Promotes interoperability between independently developed classes or systems by resolving interface mismatches.\n3.  **Encapsulation**: Hides the complexities of the Adaptee's interface from the client.",
        "type": "flashcard",
        "question": "Name two key benefits of using the Adapter pattern.",
        "id": "question_adapter_4",
        "keyConcepts": [
          "Adapter Pattern",
          "Benefits",
          "Code Reusability",
          "Interoperability",
          "Legacy Systems"
        ],
        "complexity": 5,
        "interviewFrequency": 6,
        "analysisPoints": [
          "Tests recall of advantages of the pattern.",
          "Focuses on practical benefits in software development."
        ],
        "evaluationCriteria": [
          "Understanding of practical advantages",
          "Ability to articulate benefits clearly"
        ]
      },
      {
        "type": "mcq",
        "answer": "It allows adding responsibilities to individual objects dynamically, providing more flexibility than static inheritance.",
        "id": "question_decorator_1",
        "keyConcepts": [
          "Decorator Pattern",
          "Structural Design Patterns",
          "Dynamic Behavior",
          "Composition vs. Inheritance",
          "Open/Closed Principle"
        ],
        "level": "easy",
        "evaluationCriteria": [
          "Understanding of fundamental principles",
          "Ability to distinguish between similar concepts and design approaches"
        ],
        "learningPath": "beginner",
        "interviewFrequency": 8,
        "prerequisites": [
          "object_oriented_programming",
          "inheritance"
        ],
        "analysisPoints": [
          "Tests core benefit of Decorator (dynamic, flexible extension).",
          "Distinguishes it from inheritance (static).",
          "Distracters refer to Singleton, Adapter, and Facade patterns."
        ],
        "complexity": 4,
        "options": [
          "It allows adding responsibilities to individual objects dynamically, providing more flexibility than static inheritance.",
          "It ensures that a class has only one instance.",
          "It converts the interface of a class into another interface clients expect.",
          "It simplifies the interface to a complex subsystem."
        ],
        "question": "What is the primary advantage of using the Decorator pattern over traditional inheritance for adding functionality?",
        "topic": "Decorator Pattern Purpose",
        "tags": [
          "decorator",
          "design-patterns",
          "mcq"
        ]
      },
      {
        "learningPath": "intermediate",
        "type": "code",
        "evaluationCriteria": [
          "Ability to explain code behavior",
          "Understanding of JavaScript's dynamic nature",
          "Recognition of how the pattern is applied"
        ],
        "example": "```typescript\nfunction Coffee() { /* ... */ }\nfunction Milk(coffee) {\n  const originalCost = coffee.cost();\n  coffee.cost = function() { return originalCost + 1; }; // Overwrites method\n  // ... similar for getDescription\n}\n\nconst myCoffee = new Coffee();\nMilk(myCoffee); // myCoffee's cost method is now different\n```",
        "level": "medium",
        "keyConcepts": [
          "Decorator Pattern",
          "Dynamic Object Modification",
          "Monkey Patching",
          "Function Composition",
          "JavaScript Functions"
        ],
        "options": [],
        "analysisPoints": [
          "Checks understanding of dynamic object modification in JavaScript.",
          "Requires explanation of how functions alter an object's methods.",
          "Evaluates grasp of composition over inheritance in this context."
        ],
        "prerequisites": [
          "javascript_functions",
          "object_properties"
        ],
        "question": "In the provided `Coffee` decorator example, explain how the `Milk` and `Whip` functions 'decorate' the `Coffee` object. Specifically, how do they alter its behavior without changing its class?",
        "interviewFrequency": 9,
        "answer": "The `Milk` and `Whip` functions act as decorators by taking the `coffee` object as an argument. Inside each decorator function, they first capture the `originalCost` and `originalGetDescription` by calling the `coffee` object's current methods. Then, they *redefine* the `coffee.cost` and `coffee.getDescription` methods directly on the `coffee` object itself. The new method implementations use the captured original values and add their specific enhancements (e.g., `+ 1` for milk cost, `\", Milk\"` for description). This 'monkey-patching' or dynamic augmentation of the object's methods allows new behavior to be injected at runtime without subclassing `Coffee` or modifying its original definition. The decorators wrap the existing functionality with additional logic.",
        "tags": [
          "decorator",
          "javascript",
          "code-analysis",
          "open-ended"
        ],
        "id": "question_decorator_2",
        "topic": "Decorator Pattern Implementation",
        "complexity": 7
      },
      {
        "learningPath": "advanced",
        "tags": [
          "decorator",
          "inheritance",
          "design-patterns",
          "open-ended",
          "architecture",
          "trade-offs"
        ],
        "question": "In what specific scenarios would the Decorator pattern be a more suitable choice than using inheritance to extend functionality? Provide an example.",
        "prerequisites": [
          "object_oriented_design",
          "design_principles"
        ],
        "options": [],
        "analysisPoints": [
          "Tests deep understanding of design pattern trade-offs.",
          "Requires ability to articulate specific advantages and provide a concrete example.",
          "Connects to software design principles like Open/Closed Principle."
        ],
        "level": "hard",
        "id": "question_decorator_3",
        "complexity": 9,
        "keyConcepts": [
          "Decorator Pattern",
          "Inheritance",
          "Composition",
          "Class Explosion",
          "Open/Closed Principle",
          "Dynamic Extension",
          "Design Trade-offs"
        ],
        "topic": "Decorator vs. Inheritance",
        "type": "open",
        "answer": "The Decorator pattern is more suitable than inheritance in scenarios where:\n\n1.  **Dynamic/Runtime Extension**: You need to add or remove responsibilities from objects at runtime. Inheritance defines behavior at compile-time.\n2.  **Avoiding a Class Explosion**: When there are many possible combinations of functionalities, inheritance can lead to a combinatorial explosion of subclasses (e.g., `MilkCoffee`, `WhipCoffee`, `MilkWhipCoffee`, `SugarMilkCoffee`, etc.). Decorators allow combining functionalities flexibly.\n3.  **Maintaining Open/Closed Principle**: You want to extend a class's behavior without modifying its source code. Inheritance often requires knowing and potentially modifying parent classes or creating new ones for every permutation.\n\n**Example Scenario**: A GUI toolkit with various `Window` types (e.g., `SimpleWindow`). You want to add features like `VerticalScrollbar`, `HorizontalScrollbar`, `Border`, `Shadow` to windows. \n\n*   **With Inheritance**: You'd need classes like `WindowWithVScrollbar`, `WindowWithHScrollbar`, `WindowWithVAndHScrollbar`, `WindowWithBorderVScrollbar`, etc., leading to an unmanageable class hierarchy.\n*   **With Decorator**: You'd have `Window`, `VerticalScrollbarDecorator`, `HorizontalScrollbarDecorator`, `BorderDecorator`, `ShadowDecorator`. You can then create a `new BorderDecorator(new VerticalScrollbarDecorator(new SimpleWindow()))` at runtime, composing features as needed. Each decorator adds only its specific functionality, and they can be combined in any order.",
        "evaluationCriteria": [
          "Ability to analyze design decisions",
          "Provision of clear, relevant examples",
          "Demonstrates advanced understanding of OOP principles"
        ],
        "interviewFrequency": 9
      },
      {
        "tags": [
          "decorator",
          "design-patterns",
          "flashcard"
        ],
        "type": "flashcard",
        "prerequisites": [
          "decorator_pattern"
        ],
        "learningPath": "intermediate",
        "answer": "Decorators can complicate object creation and configuration, as they often involve many small objects (decorators) being wrapped around a core object. This can make the code harder to read, debug, and manage if there are too many layers of decoration or if the order of decorators matters significantly.",
        "question": "What is one potential drawback or complexity introduced by using the Decorator pattern?",
        "id": "question_decorator_4",
        "topic": "Decorator Limitations",
        "interviewFrequency": 5,
        "keyConcepts": [
          "Decorator Pattern",
          "Drawbacks",
          "Complexity",
          "Debugging"
        ],
        "evaluationCriteria": [
          "Understanding of practical limitations",
          "Ability to identify potential maintainability issues"
        ],
        "options": [],
        "level": "medium",
        "analysisPoints": [
          "Tests awareness of pattern's potential downsides.",
          "Focuses on practical challenges in implementation or maintenance."
        ],
        "complexity": 6
      }
    ],
    "logicalBlockInfo": {
      "suggestedEndLine": -1
    },
    "displayEndLine": 299,
    "startLine": 200
  },
  {
    "endLine": 600,
    "startLine": 500,
    "id": "chunk_500_599_1749978107428",
    "processedDate": "2025-06-15T09:01:47.423Z",
    "logicalBlockInfo": {
      "suggestedEndLine": -1
    },
    "displayEndLine": 599,
    "questions": [
      {
        "complexity": 7,
        "type": "mcq",
        "analysisPoints": [
          "Understanding the `+` operator's dual behavior (concatenation vs. addition).",
          "Understanding how non-addition arithmetic operators (`-`, `*`, `/`) always attempt numeric coercion.",
          "Knowing how boolean values (`true`/`false`) are coerced to numbers (`1`/`0`) in arithmetic operations."
        ],
        "interviewFrequency": 8,
        "tags": [
          "type-coercion",
          "operators",
          "javascript-fundamentals"
        ],
        "example": null,
        "level": "medium",
        "options": [
          "NaN",
          "50",
          "52",
          "49"
        ],
        "answer": "The correct answer is `50`. \n\n**Breakdown:**\n1.  `\"5\" + 2`: The `+` operator performs string concatenation because one operand is a string. `\"5\"` + `2` results in `\"52\"`.\n2.  `\"52\" - \"3\"`: The `-` operator forces numeric coercion. `\"52\"` becomes `52`, and `\"3\"` becomes `3`. `52 - 3` results in `49`.\n3.  `49 + true`: The `+` operator performs numeric addition because `49` is a number. `true` is coerced to `1`. `49 + 1` results in `50`.",
        "topic": "JavaScript Type Coercion",
        "evaluationCriteria": [
          "Ability to trace type coercion step-by-step.",
          "Correctly identifying operator behavior."
        ],
        "learningPath": "intermediate",
        "question": "What is the result of the following JavaScript expression: `\"5\" + 2 - \"3\" + true`?",
        "id": "question_type_coercion_mcq_1",
        "keyConcepts": [
          "Type Coercion",
          "Operator Precedence",
          "String Concatenation",
          "Numeric Conversion"
        ],
        "prerequisites": [
          "basic_javascript_types",
          "basic_javascript_operators"
        ]
      },
      {
        "example": null,
        "keyConcepts": [
          "Type Coercion",
          "Operator Precedence",
          "Falsy/Truthy Values",
          "NaN Propagation"
        ],
        "prerequisites": [
          "basic_javascript_types",
          "type_coercion_basics"
        ],
        "type": "open",
        "topic": "JavaScript Type Coercion",
        "level": "hard",
        "answer": "Let's break down the expression `[] + {} - [] + ![]` step by step:\n\n1.  `[] + {}`:\n    *   `[]` (empty array) is coerced to an empty string `\"\"` for the `+` operator's string concatenation behavior.\n    *   `{}` (empty object) is coerced to the string `\"[object Object]\"`.\n    *   Result: `\"\" + \"[object Object]\"` evaluates to `\"[object Object]\"` (string concatenation).\n\n2.  `\"[object Object]\" - []`:\n    *   The `-` operator forces numeric coercion.\n    *   `\"[object Object]\"` cannot be meaningfully converted to a number, so it becomes `NaN`.\n    *   `[]` (empty array) is coerced to `\"\"`, and then to `0` for numeric operation.\n    *   Result: `NaN - 0` evaluates to `NaN`.\n\n3.  `NaN + ![]`:\n    *   `![]`: The logical NOT operator (`!`) attempts to convert `[]` (an empty array) to a boolean. An empty array is a truthy value, so `![]` evaluates to `false`.\n    *   `NaN + false`: The `+` operator performs numeric addition. `false` is coerced to `0`.\n    *   Result: `NaN + 0` evaluates to `NaN`.\n\n**Final Result: `NaN`**",
        "learningPath": "advanced",
        "tags": [
          "type-coercion",
          "operators",
          "javascript-gotchas",
          "complex"
        ],
        "complexity": 9,
        "interviewFrequency": 7,
        "question": "Explain the step-by-step evaluation of the expression `[] + {} - [] + ![]` in JavaScript, detailing all type coercions and operator evaluations. What is the final result?",
        "analysisPoints": [
          "Ability to analyze complex type coercion scenarios.",
          "Understanding the string conversion of empty arrays and objects.",
          "Knowledge of how `NaN` propagates through arithmetic operations.",
          "Understanding boolean coercion with the `!` operator."
        ],
        "id": "question_type_coercion_open_1",
        "evaluationCriteria": [
          "Completeness and accuracy of step-by-step breakdown.",
          "Correct identification of intermediate types and values.",
          "Logical explanation of coercion rules for different operators."
        ]
      },
      {
        "level": "medium",
        "id": "question_type_coercion_code_1",
        "prerequisites": [
          "basic_javascript_data_types",
          "basic_javascript_operators"
        ],
        "evaluationCriteria": [
          "Correctly identifying outputs for different inputs.",
          "Clear and concise explanation of the underlying type coercion rules."
        ],
        "keyConcepts": [
          "Type Coercion",
          "Operator Overloading (`+`)",
          "String Conversion"
        ],
        "options": [],
        "complexity": 5,
        "topic": "JavaScript Type Coercion",
        "interviewFrequency": 7,
        "type": "code",
        "example": "\n```typescript\nfunction weirdSum(a: any, b: any): any {\n  return a + b;\n}\n\nconsole.log(weirdSum('10', '20')); // Expected: \"1020\"\nconsole.log(weirdSum(10, '20'));  // Expected: \"1020\"\nconsole.log(weirdSum(10, 20));   // Expected: 30\n```",
        "answer": "1.  `console.log(weirdSum('10', '20'));` outputs `\"1020\"`.\n    *   Reason: Both `a` and `b` are strings. The `+` operator performs string concatenation when both operands are strings.\n\n2.  `console.log(weirdSum(10, '20'));` outputs `\"1020\"`.\n    *   Reason: `a` is a number and `b` is a string. The `+` operator performs string concatenation if at least one operand is a string. The number `10` is coerced to the string `\"10\"` and then concatenated with `\"20\"`.\n\n3.  `console.log(weirdSum(10, 20));` outputs `30`.\n    *   Reason: Both `a` and `b` are numbers. The `+` operator performs numeric addition when both operands are numbers.",
        "tags": [
          "type-coercion",
          "operators",
          "function-behavior",
          "javascript-basics"
        ],
        "question": "Consider the following JavaScript function:\n```javascript\nfunction weirdSum(a, b) {\n  return a + b;\n}\n```\nWhat would be the output of `console.log(weirdSum('10', '20'));` and `console.log(weirdSum(10, '20'));` and `console.log(weirdSum(10, 20));`? Explain the reason for each output.",
        "learningPath": "intermediate",
        "analysisPoints": [
          "Distinguishing between string concatenation and numeric addition with the `+` operator.",
          "Understanding how the type of operands dictates the behavior of the `+` operator.",
          "Ability to predict output based on input types."
        ]
      },
      {
        "topic": "JavaScript Type Coercion",
        "example": null,
        "interviewFrequency": 9,
        "answer": "`==` (loose equality) performs type coercion before comparing values, meaning it tries to convert operands to a common type if they are different. `===` (strict equality) compares both the value and the type without any type coercion. `===` is generally preferred for predictability.",
        "keyConcepts": [
          "Equality Operators",
          "Type Coercion",
          "Strict vs Loose Comparison"
        ],
        "analysisPoints": [],
        "tags": [
          "equality",
          "type-coercion",
          "flashcard"
        ],
        "evaluationCriteria": [],
        "id": "question_type_coercion_flashcard_1",
        "complexity": 3,
        "level": "easy",
        "prerequisites": [
          "basic_javascript_operators"
        ],
        "options": [],
        "learningPath": "beginner",
        "type": "flashcard",
        "question": "What is the primary difference between `==` and `===` in JavaScript?"
      },
      {
        "tags": [
          "hoisting",
          "var",
          "scope",
          "javascript-fundamentals"
        ],
        "evaluationCriteria": [
          "Correctly identifying the hoisted behavior of `var`.",
          "Predicting the value of variables at different points in execution."
        ],
        "learningPath": "intermediate",
        "complexity": 6,
        "options": [
          "ReferenceError then 'Hello, World!'",
          "undefined then undefined",
          "'Hello, World!' then 'Hello, World!'",
          "undefined then 'Hello, World!'"
        ],
        "interviewFrequency": 9,
        "answer": "The correct answer is `undefined` then `Hello, World!`. \n\n**Explanation:**\n1.  Due to `var` hoisting, the declaration `var message;` is moved to the top of the `greet` function's scope. However, the assignment `message = \"Hello, World!\";` remains at its original line.\n2.  When `console.log(message);` is first called, `message` has been declared but not yet assigned a value, so it is `undefined`.\n3.  Then, `message = \"Hello, World!\";` is executed, assigning the string value to `message`.\n4.  The second `console.log(message);` then logs the assigned value `\"Hello, World!\"`.",
        "question": "What will be logged to the console by the following JavaScript code?\n```javascript\nfunction greet() {\n  console.log(message);\n  var message = \"Hello, World!\";\n  console.log(message);\n}\ngreet();\n```",
        "prerequisites": [
          "basic_javascript_variables",
          "javascript_functions"
        ],
        "keyConcepts": [
          "Hoisting",
          "Var Keyword",
          "Function Scope",
          "Variable Lifecycle"
        ],
        "analysisPoints": [
          "Understanding how `var` variables are hoisted (declaration but not initialization).",
          "Knowing the default value of a declared but uninitialized variable (`undefined`).",
          "Tracing the execution flow within a function scope."
        ],
        "topic": "JavaScript Hoisting",
        "level": "medium",
        "type": "mcq",
        "example": "\n```typescript\nfunction greet() {\n  console.log(message); // undefined\n  var message = \"Hello, World!\";\n  console.log(message); // \"Hello, World!\"\n}\ngreet();\n```",
        "id": "question_hoisting_mcq_1"
      },
      {
        "prerequisites": [
          "hoisting_basics",
          "var_let_const_differences"
        ],
        "level": "hard",
        "options": [],
        "id": "question_hoisting_open_1",
        "question": "Explain the concept of the 'Temporal Dead Zone' (TDZ) in JavaScript. Provide a code example that demonstrates its effect and explain why it's different from accessing a `var` variable before its declaration.",
        "type": "open",
        "topic": "Temporal Dead Zone",
        "tags": [
          "hoisting",
          "temporal-dead-zone",
          "let",
          "const",
          "scope",
          "javascript-es6"
        ],
        "complexity": 8,
        "analysisPoints": [
          "Accurate definition of TDZ.",
          "Clear distinction between `var`, `let`, and `const` hoisting behavior.",
          "Correctly identifying the type of error (`ReferenceError` vs. `undefined`).",
          "Providing a relevant and well-explained code example."
        ],
        "answer": "The **Temporal Dead Zone (TDZ)** is a specific period during the execution of JavaScript code where `let` and `const` variables exist but cannot be accessed. It begins from the start of the block scope in which the `let` or `const` variable is declared and ends when the variable's declaration is actually processed.\n\n**Key Characteristics of TDZ:**\n*   **Hoisted but Uninitialized**: `let` and `const` declarations *are* hoisted to the top of their block scope, but unlike `var`, they are *not* initialized with `undefined`.\n*   **ReferenceError**: Attempting to access a `let` or `const` variable within its TDZ (i.e., before its declaration statement has been executed) will result in a `ReferenceError`. This error explicitly indicates that the variable cannot be accessed before initialization.\n\n**Difference from `var`:**\nFor `var` declarations, the variable is also hoisted, but it is automatically initialized to `undefined`. Therefore, accessing a `var` variable before its assignment (but after its declaration has been hoisted) will simply yield `undefined`, not a `ReferenceError`.\n\n**Code Example:**\n\n```javascript\nfunction demonstrateTDZ() {\n  // console.log(a); // ReferenceError: Cannot access 'a' before initialization (TDZ for 'a')\n  let a = 10;\n  console.log(a); // 10\n\n  // console.log(b); // ReferenceError: Cannot access 'b' before initialization (TDZ for 'b')\n  const b = 20;\n  console.log(b); // 20\n\n  console.log(c); // undefined (hoisted var, but not yet assigned)\n  var c = 30;\n  console.log(c); // 30\n}\n\ndemonstrateTDZ();\n```\n\n**Explanation of the example:**\n*   For `let a` and `const b`, if the commented-out `console.log` lines were active, they would throw `ReferenceError` because `a` and `b` are in their Temporal Dead Zone at that point. Their declarations are hoisted, but they are not initialized until their respective lines of code are executed.\n*   For `var c`, `console.log(c)` outputs `undefined` because `c`'s declaration is hoisted to the top of the function, and it is automatically initialized to `undefined`. The assignment `c = 30` happens later.",
        "example": "\n```typescript\nfunction demonstrateTDZ() {\n  // This line would cause a ReferenceError for 'a'\n  // console.log(a);\n  let a = 10;\n  console.log(a); \n\n  // This line would cause a ReferenceError for 'b'\n  // console.log(b);\n  const b = 20;\n  console.log(b); \n\n  console.log(c); // undefined\n  var c = 30;\n  console.log(c); \n}\n\ndemonstrateTDZ();\n```",
        "evaluationCriteria": [
          "Thorough explanation of TDZ mechanism.",
          "Demonstration of practical implications with code.",
          "Ability to compare and contrast with `var` behavior."
        ],
        "learningPath": "advanced",
        "keyConcepts": [
          "Temporal Dead Zone",
          "Hoisting",
          "let",
          "const",
          "var",
          "Scope"
        ],
        "interviewFrequency": 9
      },
      {
        "example": "\n```typescript\nvar favoriteColor = \"blue\";\n\n(function() {\n  console.log(favoriteColor); // undefined\n  var favoriteColor = \"green\";\n  console.log(favoriteColor); // green\n  function favoriteColor() { // This declaration is hoisted, but shadowed by var's effect\n    return \"red\";\n  }\n  console.log(favoriteColor); // green\n})();\n\nconsole.log(favoriteColor); // blue\n```",
        "interviewFrequency": 8,
        "keyConcepts": [
          "Hoisting",
          "Scope (Global, Function)",
          "var",
          "Function Declaration",
          "IIFE",
          "Variable Shadowing"
        ],
        "type": "code",
        "options": [],
        "complexity": 10,
        "level": "hard",
        "analysisPoints": [
          "Deep understanding of hoisting rules for both `var` and function declarations.",
          "Knowledge of how variable assignments interact with hoisted declarations.",
          "Understanding of scope (global vs. function/IIFE scope).",
          "Ability to trace variable values across different scopes and execution phases."
        ],
        "prerequisites": [
          "hoisting_basics",
          "javascript_scopes",
          "iife_basics"
        ],
        "topic": "Hoisting Priority",
        "answer": "The output will be:\n```\nundefined\ngreen\ngreen\nblue\n```\n\n**Explanation:**\n\n1.  **Global Scope:**\n    *   `var favoriteColor = \"blue\";` - In the global scope, `favoriteColor` is declared and initialized to `\"blue\"`.\n\n2.  **Inside the IIFE (Immediately Invoked Function Expression) Scope:**\n    *   **Hoisting Phase within IIFE:**\n        *   The function declaration `function favoriteColor() { return \"red\"; }` is hoisted to the top of the IIFE's scope. Initially, `favoriteColor` refers to this function.\n        *   The variable declaration `var favoriteColor;` is also hoisted. However, a function declaration with the same name takes precedence over a `var` declaration during the initial hoisting. So, at the very beginning of the IIFE's execution, `favoriteColor` refers to the function `favoriteColor() { return \"red\"; }`. \n        *   When `console.log(favoriteColor);` (first inside IIFE) is encountered, `favoriteColor` points to the `var` declaration that has been hoisted and initialized to `undefined`. This happens because the `var` declaration, although initially having lower priority than the function declaration for *declaration*, then asserts its presence by becoming the *actual variable* that will receive an assignment. The variable `favoriteColor` (declared with `var`) shadows the function `favoriteColor` *within this specific execution context*, and because it hasn't been assigned yet, it's `undefined`.\n    *   **Execution Phase within IIFE:**\n        *   `console.log(favoriteColor);` (first inside IIFE): Outputs `undefined` (due to the hoisted `var favoriteColor` not yet having its assignment).\n        *   `var favoriteColor = \"green\";`: This line assigns the string `\"green\"` to the `favoriteColor` variable inside the IIFE.\n        *   `console.log(favoriteColor);` (second inside IIFE): Outputs `green`.\n        *   `function favoriteColor() { ... }`: This function declaration was already processed during the hoisting phase. It doesn't change the current value of the `favoriteColor` variable which is now `\"green\"`.\n        *   `console.log(favoriteColor);` (third inside IIFE): Outputs `green`.\n\n3.  **Global Scope (after IIFE):**\n    *   `console.log(favoriteColor);` (global): The IIFE created its own scope, so the `favoriteColor` variable in the global scope remains untouched. It logs its original value `\"blue\"`.",
        "question": "What will be the output of the following JavaScript code and why?\n```javascript\nvar favoriteColor = \"blue\";\n\n(function() {\n  console.log(favoriteColor);\n  var favoriteColor = \"green\";\n  console.log(favoriteColor);\n  function favoriteColor() {\n    return \"red\";\n  }\n  console.log(favoriteColor);\n})();\n\nconsole.log(favoriteColor);\n```",
        "evaluationCriteria": [
          "Accurate prediction of all console outputs.",
          "Detailed explanation of hoisting and scope rules at each step.",
          "Correctly explaining variable shadowing within the IIFE."
        ],
        "tags": [
          "hoisting",
          "scope",
          "var",
          "function-declaration",
          "iife",
          "difficult"
        ],
        "id": "question_hoisting_code_1",
        "learningPath": "expert"
      },
      {
        "keyConcepts": [
          "Hoisting",
          "let",
          "const",
          "Temporal Dead Zone"
        ],
        "options": [],
        "level": "easy",
        "answer": "Yes, `let` and `const` variables *are* hoisted. However, unlike `var`, they are not initialized. They exist in a 'Temporal Dead Zone' (TDZ) from the beginning of their scope until their declaration, and accessing them during this period will result in a `ReferenceError`.",
        "interviewFrequency": 8,
        "complexity": 4,
        "learningPath": "intermediate",
        "prerequisites": [
          "basic_javascript_variables"
        ],
        "type": "flashcard",
        "topic": "JavaScript Hoisting",
        "analysisPoints": [],
        "tags": [
          "hoisting",
          "let-const",
          "flashcard"
        ],
        "id": "question_hoisting_flashcard_1",
        "question": "Are `let` and `const` variables hoisted?",
        "evaluationCriteria": [],
        "example": null
      },
      {
        "options": [
          "function myFunc() {}",
          "const myFunc = function namedFunc() {};",
          "const myFunc = () => {};",
          "Both B and C"
        ],
        "evaluationCriteria": [
          "Correctly identifying which function types are affected by hoisting differences.",
          "Understanding the implications of function expressions not being fully hoisted."
        ],
        "keyConcepts": [
          "Function Declaration",
          "Function Expression",
          "Arrow Function",
          "Hoisting",
          "Temporal Dead Zone"
        ],
        "learningPath": "intermediate",
        "tags": [
          "functions",
          "hoisting",
          "function-expression",
          "arrow-functions",
          "javascript-fundamentals"
        ],
        "id": "question_functions_mcq_1",
        "topic": "Function Types",
        "answer": "The correct answer is `Both B and C`. \n\n**Explanation:**\n1.  **Function Declaration (`function myFunc() {}`)**: These are fully hoisted, meaning both their name and definition are moved to the top of the scope, allowing them to be called anywhere within that scope.\n2.  **Named Function Expression (`const myFunc = function namedFunc() {};`)**: This is a function expression. Only the `myFunc` variable is hoisted (and for `const`, it's in the TDZ until defined). The function itself is not available until the assignment line is executed.\n3.  **Arrow Function Expression (`const myFunc = () => {};`)**: This is also a function expression. Similar to regular function expressions, only the `myFunc` variable is hoisted, and the function body is not available for execution until its assignment line.",
        "complexity": 7,
        "example": null,
        "question": "Which of the following function definitions is *not* hoisted in a way that allows it to be called before its actual declaration in the code?",
        "type": "mcq",
        "interviewFrequency": 8,
        "prerequisites": [
          "hoisting_basics",
          "function_declarations_basics"
        ],
        "level": "medium",
        "analysisPoints": [
          "Differentiating between function declarations and function expressions.",
          "Understanding the impact of `const` (and `let`) on hoisting behavior.",
          "Recognizing that arrow functions are a form of function expression."
        ]
      },
      {
        "options": [],
        "id": "question_functions_open_1",
        "keyConcepts": [
          "IIFE",
          "Scope",
          "Encapsulation",
          "Module Pattern",
          "Data Privacy"
        ],
        "learningPath": "intermediate",
        "prerequisites": [
          "javascript_functions",
          "javascript_scopes"
        ],
        "level": "medium",
        "evaluationCriteria": [
          "Clarity of IIFE definition.",
          "Breadth and depth of use cases provided.",
          "Understanding of the core problem IIFEs solve (global pollution)."
        ],
        "type": "open",
        "complexity": 7,
        "tags": [
          "iife",
          "functions",
          "scope",
          "design-patterns",
          "javascript-fundamentals"
        ],
        "answer": "An **IIFE (Immediately Invoked Function Expression)** is a JavaScript function that runs as soon as it is defined. It is typically written as an anonymous function wrapped in parentheses, followed immediately by another set of parentheses to invoke it.\n\n**Syntax Example:**\n```javascript\n(function() {\n  // code here\n})();\n```\n\n**Primary Use Cases:**\n1.  **Scope Isolation/Preventing Global Namespace Pollution**: This is the most significant use case. Variables and functions declared inside an IIFE are confined to its private scope, preventing them from colliding with variables in the global scope or other scripts. Before ES6 modules, this was the primary way to achieve encapsulation.\n2.  **Data Privacy (Module Pattern)**: By returning an object from an IIFE that contains references to internal functions and properties, you can create a 'module' where some data remains private (closure over the IIFE's scope) while other parts are exposed publicly. This forms the basis of the 'Module Pattern'.\n3.  **Creating Closures for Loops**: In older JavaScript (or with `var`), IIFEs were often used inside loops to capture the correct value of a loop variable for asynchronous operations or event handlers, effectively creating a new scope for each iteration.\n4.  **One-Time Initialization**: For code that needs to run only once at script load, an IIFE provides a clean way to execute it without polluting the global scope with helper variables or functions.",
        "question": "What is an IIFE (Immediately Invoked Function Expression) and what are its primary use cases in modern JavaScript development?",
        "interviewFrequency": 8,
        "analysisPoints": [
          "Accurate definition and syntax of IIFE.",
          "Comprehensive list of modern use cases.",
          "Clear explanation of why scope isolation is important."
        ],
        "topic": "IIFE",
        "example": "\n```typescript\n// Basic IIFE for scope isolation\n(function() {\n  var myScopedVariable = \"I live in here\";\n  console.log(myScopedVariable);\n})();\n// console.log(myScopedVariable); // ReferenceError\n\n// IIFE for Module Pattern\nconst app = (function() {\n  let privateData = 0;\n\n  function privateMethod() {\n    privateData++;\n    return privateData;\n  }\n\n  return {\n    publicMethod: function() {\n      return privateMethod();\n    },\n    getPrivateData: function() {\n        return privateData; // Illustrative: exposing for test, usually wouldn't expose raw private data\n    }\n  };\n})();\n\nconsole.log(app.publicMethod()); // 1\nconsole.log(app.publicMethod()); // 2\nconsole.log(app.getPrivateData()); // 2\n// console.log(app.privateData); // undefined\n```"
      },
      {
        "learningPath": "intermediate",
        "evaluationCriteria": [
          "Accurate prediction of output/error for each snippet.",
          "Clear and correct explanation based on hoisting rules.",
          "Precise identification of error types."
        ],
        "type": "code",
        "analysisPoints": [
          "Distinguishing between hoisting behavior of function declarations and function expressions.",
          "Understanding the `let`/`const` Temporal Dead Zone vs. `var`'s `undefined` initialization.",
          "Identifying correct error types (`ReferenceError` vs. `TypeError`)."
        ],
        "level": "medium",
        "interviewFrequency": 8,
        "id": "question_functions_code_1",
        "options": [],
        "answer": "**Snippet A:**\n*   **Output:** `Hello`\n*   **Explanation:** `sayHello` is a function declaration. Function declarations are fully hoisted, meaning their entire definition is moved to the top of the current scope during the compilation phase. Therefore, `sayHello()` can be called before its literal declaration in the code.\n\n**Snippet B:**\n*   **Output:** `ReferenceError: Cannot access 'sayHi' before initialization`\n*   **Explanation:** `sayHi` is a function expression assigned to a `const` variable. While `sayHi`'s declaration is hoisted, it's not initialized until its line of code is executed. It enters the Temporal Dead Zone (TDZ) from the beginning of its block scope until its declaration. Attempting to access it within the TDZ results in a `ReferenceError`.\n\n**Snippet C:**\n*   **Output:** `TypeError: sayBye is not a function`\n*   **Explanation:** `sayBye` is an arrow function expression assigned to a `var` variable. The `var` declaration `var sayBye;` is hoisted to the top of the scope and initialized to `undefined`. When `console.log(sayBye());` is called, `sayBye` holds the value `undefined`, and attempting to invoke `undefined` as a function leads to a `TypeError`.",
        "topic": "Function Declaration vs. Expression",
        "keyConcepts": [
          "Hoisting",
          "Function Declaration",
          "Function Expression",
          "Arrow Functions",
          "Temporal Dead Zone",
          "var-let-const Differences"
        ],
        "tags": [
          "functions",
          "hoisting",
          "errors",
          "javascript-fundamentals"
        ],
        "question": "Consider the following code snippets. For each `console.log` statement, predict the output or state if it will throw an error, and explain why.\n\n**Snippet A:**\n```javascript\nconsole.log(sayHello());\nfunction sayHello() {\n  return \"Hello\";\n}\n```\n\n**Snippet B:**\n```javascript\nconsole.log(sayHi());\nconst sayHi = function() {\n  return \"Hi\";\n};\n```\n\n**Snippet C:**\n```javascript\nconsole.log(sayBye());\nvar sayBye = () => {\n  return \"Bye\";\n};\n```",
        "prerequisites": [
          "hoisting_basics",
          "function_types"
        ],
        "complexity": 7,
        "example": "\n```typescript\n// Snippet A\nconsole.log(sayHello()); // Hello\nfunction sayHello() {\n  return \"Hello\";\n}\n\n// Snippet B\n// console.log(sayHi()); // ReferenceError\nconst sayHi = function() {\n  return \"Hi\";\n};\n\n// Snippet C\n// console.log(sayBye()); // TypeError\nvar sayBye = () => {\n  return \"Bye\";\n};\n```"
      },
      {
        "evaluationCriteria": [],
        "options": [],
        "example": null,
        "topic": "IIFE",
        "type": "flashcard",
        "prerequisites": [],
        "id": "question_functions_flashcard_1",
        "answer": "IIFE stands for Immediately Invoked Function Expression.",
        "interviewFrequency": 6,
        "analysisPoints": [],
        "keyConcepts": [
          "IIFE",
          "Acronyms"
        ],
        "learningPath": "beginner",
        "tags": [
          "iife",
          "flashcard",
          "definition"
        ],
        "complexity": 2,
        "question": "What does IIFE stand for?",
        "level": "easy"
      }
    ],
    "tasks": [
      {
        "relatedConcepts": [
          "operator_overloading",
          "number_types",
          "string_manipulation"
        ],
        "complexity": 7,
        "tags": [
          "type-coercion",
          "operators",
          "string-parsing",
          "calculator",
          "frontend-interview"
        ],
        "testCases": [
          "Test numeric addition: `safeCalculator('5 + 3')` should return `8`",
          "Test string concatenation (both strings): `safeCalculator(\"'hello' + 'world'\")` should return `'helloworld'`",
          "Test mixed addition (number + string literal): `safeCalculator('10 + \"5\"')` should return `15` (because `Number('5')` is `5`)",
          "Test mixed addition (string literal + number): `safeCalculator(\"'5' + 10\")` should return `15`",
          "Test subtraction: `safeCalculator('10 - \"5\"')` should return `5`",
          "Test multiplication: `safeCalculator(\"4 * '2'\")` should return `8`",
          "Test division: `safeCalculator('10 / 2')` should return `5`",
          "Test division by zero (positive): `safeCalculator('5 / 0')` should return `Infinity`",
          "Test division by zero (negative): `safeCalculator('-5 / 0')` should return `-Infinity`",
          "Test invalid numeric operand: `safeCalculator(\"'abc' * 5\")` should return `NaN`",
          "Test invalid expression format: `safeCalculator('5+3')` should throw an error",
          "Test invalid operator: `safeCalculator('5 % 3')` should throw an error"
        ],
        "title": "Build a Robust Calculator Function with Coercion Awareness",
        "solutionCode": "function safeCalculator(expression) {\n  const parts = expression.split(' ');\n  if (parts.length !== 3) {\n    throw new Error('Invalid expression format. Expected \"operand1 operator operand2\".');\n  }\n\n  let [operand1Raw, operator, operand2Raw] = parts;\n\n  // Helper to determine if a raw operand was a string literal and clean it\n  const parseOperand = (raw) => {\n    const isStringLiteral = raw.startsWith(\"'\") && raw.endsWith(\"'\");\n    const cleanedValue = isStringLiteral ? raw.slice(1, -1) : raw;\n    return { value: cleanedValue, isString: isStringLiteral };\n  };\n\n  const op1 = parseOperand(operand1Raw);\n  const op2 = parseOperand(operand2Raw);\n\n  let result;\n\n  switch (operator) {\n    case '+':\n      // Special rule: if BOTH operands were originally string literals, concatenate strings\n      if (op1.isString && op2.isString) {\n        result = op1.value + op2.value;\n      } else {\n        // Otherwise, convert to numbers and perform addition (JavaScript's default + behavior for mixed types or two numbers)\n        const num1 = Number(op1.value);\n        const num2 = Number(op2.value);\n        result = num1 + num2;\n      }\n      break;\n    case '-':\n    case '*':\n    case '/':\n      // For these operators, always attempt numeric conversion\n      const num1 = Number(op1.value);\n      const num2 = Number(op2.value);\n\n      if (isNaN(num1) || isNaN(num2)) {\n        return NaN; // If conversion to number fails, result is NaN\n      }\n\n      if (operator === '-') {\n        result = num1 - num2;\n      } else if (operator === '*') {\n        result = num1 * num2;\n      } else if (operator === '/') {\n        // JavaScript handles division by zero as Infinity/-Infinity; no explicit check needed unless custom error is desired\n        result = num1 / num2;\n      }\n      break;\n    default:\n      throw new Error('Unsupported operator: ' + operator);\n  }\n\n  return result;\n}\n",
        "difficulty": "medium",
        "timeEstimate": 45,
        "description": "\nImplement a function `safeCalculator(expression)` that takes a string `expression` as input. This expression will consist of two numbers (which might be strings) and a single operator (`+`, `-`, `*`, `/`). Your function should parse the expression, perform the calculation, and return the result. Handle common JavaScript type coercion pitfalls by ensuring numerical operations where intended, and string concatenation only where explicitly required or when `+` is used with a string operand.\n\n**Requirements:**\n1.  The `expression` string will be in the format: `\"operand1 operator operand2\"` (e.g., `\"5 + 3\"`, `\"'10' - 2\"`, `\"4 * '2'\"`, `\"'7' / '0'\"`). Note that string literals will be enclosed in single quotes.\n2.  Parse `operand1`, `operator`, and `operand2` from the string.\n3.  For `+` operator:\n    *   If *both* operands were originally string literals (e.g., `'10' + '20'`), perform string concatenation.\n    *   In all other `+` cases (e.g., `10 + '20'`, `10 + 20`, `'5' + 2`), perform numeric addition. This means the operands should be explicitly converted to numbers.\n4.  For `-`, `*`, `/` operators: Always perform numeric operations. Ensure operands are coerced to numbers.\n5.  Handle division by zero gracefully (return `Infinity` or `-Infinity` as per JavaScript's native behavior, not an error).\n6.  Return `NaN` if any operand cannot be meaningfully converted to a number for arithmetic operations (e.g., `\"hello\" * 5`).\n7.  Consider using `Number()` for explicit coercion.\n",
        "id": "task_type_coercion_1",
        "hints": [
          "Use `String.prototype.split(' ')` to break down the expression into its parts.",
          "To handle the `+` operator's dual behavior, you'll need to know if the original operands were string literals (e.g., `'10'`) or actual numbers (`10`). The `parseOperand` helper can assist here.",
          "For `-`, `*`, `/`, `Number()` is generally sufficient for conversion, as these operators always try to make operands numeric.",
          "Remember `isNaN()` to check if a conversion resulted in `NaN`."
        ],
        "learningPath": "intermediate",
        "prerequisites": [
          "type_coercion_peculiarities",
          "basic_string_methods",
          "number_conversion"
        ],
        "startingCode": "function safeCalculator(expression) {\n  const parts = expression.split(' ');\n  if (parts.length !== 3) {\n    throw new Error('Invalid expression format. Expected \"operand1 operator operand2\".');\n  }\n\n  let [operand1Raw, operator, operand2Raw] = parts;\n\n  // Helper to determine if a raw operand was a string literal and clean it\n  const parseOperand = (raw) => {\n    const isStringLiteral = raw.startsWith(\"'\") && raw.endsWith(\"'\");\n    const cleanedValue = isStringLiteral ? raw.slice(1, -1) : raw;\n    return { value: cleanedValue, isString: isStringLiteral };\n  };\n\n  const op1 = parseOperand(operand1Raw);\n  const op2 = parseOperand(operand2Raw);\n\n  // TODO: Implement parsing and calculation logic\n  // 1. Convert operands to numbers where appropriate, handling NaN.\n  // 2. Apply operator logic, especially for '+', considering if both were original string literals.\n  // 3. Handle edge cases like division by zero.\n\n  return undefined; // Replace with actual result\n}\n",
        "interviewRelevance": 8
      },
      {
        "timeEstimate": 60,
        "testCases": [
          "Test Snippet A prediction: Verify `processItemsA()` (when executed) logs `undefined` then `10`.",
          "Test Refactored Snippet A: Verify `processItemsARefactored()` (when executed) logs `undefined` then `10` and uses `let` for better scoping.",
          "Test Snippet B prediction: Verify `console.log(calculateB(5, 3))` (when uncommented) throws `ReferenceError`.",
          "Test Refactored Snippet B: Verify `console.log(calculateBRefactored(5, 3))` logs `15` and is callable before its definition.",
          "Test Snippet C prediction: Verify `initC()` (when uncommented) throws `ReferenceError`.",
          "Test Refactored Snippet C: Verify `initCRefactored()` (when uncommented) logs `0`, then `1`, then `0` and adheres to block scoping properly."
        ],
        "complexity": 9,
        "relatedConcepts": [
          "block-scope",
          "function-scope",
          "variable-shadowing"
        ],
        "learningPath": "advanced",
        "prerequisites": [
          "hoisting_temporal_dead_zone",
          "function_declarations_expressions"
        ],
        "id": "task_hoisting_1",
        "description": "\nGiven the following problematic JavaScript code snippets, your task is twofold:\n\n1.  **Predict Output/Error**: For each snippet, determine what will be logged to the console or if an error will occur. If an error, specify the type (`ReferenceError`, `TypeError`, etc.) and the reason.\n2.  **Refactor**: Rewrite each snippet to achieve its likely intended behavior (i.e., for variables to be accessible with their intended values) while adhering to modern JavaScript best practices (`let`/`const` over `var`). Explain the changes made.\n\n**Snippet A:**\n```javascript\nfunction processItems() {\n  console.log(itemCount);\n  if (true) {\n    var itemCount = 10;\n  }\n  console.log(itemCount);\n}\n```\n\n**Snippet B:**\n```javascript\nconsole.log(calculate(5, 3));\nconst calculate = (x, y) => x * y;\n```\n\n**Snippet C:**\n```javascript\nfunction init() {\n  let counter = 0;\n  {\n    // A new block scope\n    console.log(counter);\n    let counter = 1;\n    console.log(counter);\n  }\n  console.log(counter);\n}\n```\n",
        "interviewRelevance": 9,
        "solutionCode": "// Snippet A\n// Prediction: \n// First console.log: undefined (var itemCount is hoisted to function scope but not initialized until its declaration line)\n// Second console.log: 10 (itemCount is assigned to 10 within the function scope)\n// Refactored Snippet A:\nfunction processItemsARefactored() {\n  let itemCount; // Declare with let at the top of the function scope\n  console.log(itemCount); // undefined\n  if (true) {\n    itemCount = 10; // Assignment, no re-declaration. 'let' is block-scoped but declared at function start.\n  }\n  console.log(itemCount); // 10\n}\n\n// Snippet B\n// Prediction:\n// ReferenceError: Cannot access 'calculateB' before initialization\n// (calculateB is a const function expression. While 'calculateB' is hoisted, it's in the Temporal Dead Zone (TDZ) until its declaration line is reached.)\n// Refactored Snippet B:\nfunction calculateBRefactored(x, y) { // Changed to function declaration for full hoisting\n  return x * y;\n}\nconsole.log(calculateBRefactored(5, 3)); // 15\n\n// Snippet C\n// Prediction:\n// First console.log: ReferenceError: Cannot access 'counter' before initialization\n// (The inner block creates a new scope. The `let counter = 1;` inside this block causes 'counter' to be in its TDZ for that specific block, shadowing the outer 'counter'.)\n// Refactored Snippet C:\nfunction initCRefactored() {\n  let counter = 0; // Outer counter\n  {\n    // A new block scope\n    // To log the outer counter, you'd usually pass it in or use a different variable name for the inner counter\n    // console.log(counter); // If uncommented, this still throws ReferenceError if 'let counter' is below it\n    const innerCounter = 1; // Use a different name for the inner variable to avoid shadowing and TDZ\n    console.log(innerCounter); // 1\n  }\n  console.log(counter); // 0 (outer counter remains 0)\n}\n",
        "startingCode": "// Snippet A\nfunction processItemsA() {\n  console.log(itemCount);\n  if (true) {\n    var itemCount = 10;\n  }\n  console.log(itemCount);\n}\n// processItemsA(); // Call to test\n\n// Snippet B\n// console.log(calculateB(5, 3)); // Call to test\nconst calculateB = (x, y) => x * y;\n\n// Snippet C\nfunction initC() {\n  let counter = 0;\n  {\n    // A new block scope\n    console.log(counter);\n    let counter = 1;\n    console.log(counter);\n  }\n  console.log(counter);\n}\n// initC(); // Call to test\n\n// TODO: Add your predictions and refactored code below\n\n// Predictions for Snippet A:\n// ...\n\n// Refactored Snippet A:\n// function processItemsARefactored() {\n//   ...\n// }\n\n// Predictions for Snippet B:\n// ...\n\n// Refactored Snippet B:\n// function calculateBRefactored() {\n//   ...\n// }\n\n// Predictions for Snippet C:\n// ...\n\n// Refactored Snippet C:\n// function initCRefactored() {\n//   ...\n// }\n",
        "title": "Refactor Code to Resolve Hoisting Issues and Predict Output",
        "tags": [
          "hoisting",
          "scope",
          "var-let-const",
          "refactoring",
          "errors",
          "javascript-fundamentals"
        ],
        "hints": [
          "Remember that `var` is function-scoped, while `let` and `const` are block-scoped.",
          "Function declarations are fully hoisted, but function expressions (including arrow functions) assigned to `let` or `const` variables adhere to the Temporal Dead Zone.",
          "The Temporal Dead Zone (TDZ) prevents access to `let` and `const` variables before their declaration within their block scope, resulting in a `ReferenceError`.",
          "When refactoring, consider if you need a truly block-scoped variable or if a different variable name in a nested scope is clearer to avoid shadowing issues."
        ],
        "difficulty": "hard"
      },
      {
        "tags": [
          "iife",
          "module-pattern",
          "encapsulation",
          "closure",
          "data-privacy",
          "frontend-interview"
        ],
        "id": "task_functions_1",
        "relatedConcepts": [
          "design-patterns",
          "scope",
          "state-management"
        ],
        "startingCode": "const myCounterModule = (function() {\n  // TODO: Declare private 'count' variable here\n\n  // TODO: Implement private helper functions if needed\n\n  // TODO: Return an object with public methods (increment, decrement, getCount)\n\n  return { /* Public API */ };\n})();\n\n// Example Usage (for testing):\n// console.log(myCounterModule.getCount()); // Should be 0\n// myCounterModule.increment();\n// console.log(myCounterModule.getCount()); // Should be 1\n// myCounterModule.decrement();\n// console.log(myCounterModule.getCount()); // Should be 0\n// console.log(myCounterModule.count); // Should be undefined\n// myCounterModule.count = 100; // Attempt to modify externally\n// console.log(myCounterModule.getCount()); // Should still be 0\n",
        "solutionCode": "const myCounterModule = (function() {\n  let count = 0; // Private variable, inaccessible from outside\n\n  function increment() {\n    count++;\n  }\n\n  function decrement() {\n    count--;\n  }\n\n  function getCount() {\n    return count;\n  }\n\n  // Return an object that exposes the public methods\n  return {\n    increment: increment,\n    decrement: decrement,\n    getCount: getCount\n  };\n})();\n",
        "difficulty": "medium",
        "testCases": [
          "Initial state: `myCounterModule.getCount()` should return `0`.",
          "Increment: Call `myCounterModule.increment()`, then `myCounterModule.getCount()` should return `1`.",
          "Multiple increments: Call `myCounterModule.increment()` twice, `myCounterModule.getCount()` should return `3` (after initial increment, total 3).",
          "Decrement: Call `myCounterModule.decrement()`, then `myCounterModule.getCount()` should return `2`.",
          "Combined operations: Perform increments and decrements (e.g., inc, inc, dec, inc), verify `getCount()` reflects the correct value.",
          "Privacy test (direct access): `myCounterModule.count` should be `undefined`.",
          "Privacy test (external modification): Attempting `myCounterModule.count = 100;` should not change the internal count (verify with `myCounterModule.getCount()`, which should remain unaffected)."
        ],
        "interviewRelevance": 7,
        "learningPath": "intermediate",
        "timeEstimate": 30,
        "prerequisites": [
          "iife_basics",
          "javascript_closures",
          "object_literals"
        ],
        "complexity": 6,
        "description": "\nImplement a JavaScript module using the IIFE (Immediately Invoked Function Expression) pattern. This module should expose a simple counter with `increment`, `decrement`, and `getCount` functionalities, while keeping the actual `count` variable private and inaccessible from outside the module.\n\n**Requirements:**\n1.  Create an IIFE that returns an object containing the public methods.\n2.  Inside the IIFE, declare a private variable `count` initialized to `0`.\n3.  Implement a public method `increment` that increases `count` by 1.\n4.  Implement a public method `decrement` that decreases `count` by 1.\n5.  Implement a public method `getCount` that returns the current value of `count`.\n6.  Ensure that `count` cannot be directly accessed or modified from outside the module (e.g., `myCounter.count` should be `undefined` and attempts to assign to it should not affect the internal `count`).\n",
        "title": "Implement a Simple Module Pattern using IIFE for a Counter",
        "hints": [
          "The `count` variable should be declared with `let` or `var` *inside* the IIFE, not outside.",
          "The public methods (increment, decrement, getCount) should be functions defined *inside* the IIFE.",
          "To expose the public methods, return an object from the IIFE that maps property names to these functions.",
          "Remember that functions returned by the IIFE will form a closure over the IIFE's scope, allowing them to access the private `count` variable."
        ]
      }
    ],
    "theory": [
      {
        "requiredFor": [
          "advanced_debugging",
          "understanding_framework_internals"
        ],
        "technology": "JavaScript",
        "examples": [
          {
            "explanation": "This example demonstrates a sequence of implicit type coercions. The `+` operator first performs string concatenation with `[]` (coerced to `\"\"`) and `false` (coerced to `\"false\"`). The result `\"false\"` then interacts with `null` via the `-` operator. `null` is coerced to `0`, but `\"false\"` cannot be coerced to a valid number, resulting in `NaN`. Finally, `NaN` plus `true` (which coerces to `1`) still yields `NaN`.",
            "code": "console.log([] + false - null + true); // NaN\n// Breakdown:\n// 1. [] + false  -> \"\" + \"false\" -> \"false\" (array becomes empty string, then concatenation)\n// 2. \"false\" - null -> NaN (string minus null is Not a Number; null coerces to 0, but \"false\" to NaN)\n// 3. NaN + true   -> NaN (any operation with NaN results in NaN; true coerces to 1)\n",
            "id": "example_type_coercion_1",
            "title": "Complex Coercion Example",
            "language": "javascript"
          },
          {
            "id": "example_type_coercion_2",
            "language": "javascript",
            "explanation": "JavaScript handles division by zero by returning `Infinity` or `-Infinity`, not throwing an error. When `undefined` is involved in arithmetic operations, it often results in `NaN` because `undefined` lacks a clear numeric representation for such operations.",
            "title": "Division by Zero and Undefined Operations",
            "code": "let result = 5 / 0;      // Infinity\nlet negativeResult = -5 / 0; // -Infinity\nlet undefinedOperation = 5 + undefined; // NaN\n\nconsole.log(result); // Infinity\nconsole.log(negativeResult); // -Infinity\nconsole.log(undefinedOperation); // NaN"
          },
          {
            "language": "javascript",
            "explanation": "This illustrates the fundamental difference between loose (`==`) and strict (`===`) equality. Loose equality performs type conversions, leading to `true` for values that are conceptually similar but of different types. Strict equality requires both value and type to be identical, making it more predictable.",
            "id": "example_type_coercion_3",
            "title": "Loose vs Strict Equality",
            "code": "console.log(1 == '1');    // true (coercion: '1' becomes 1)\nconsole.log(1 === '1');   // false (no coercion: number vs string)\nconsole.log(0 == false);  // true (coercion: false becomes 0)\nconsole.log(0 === false); // false (no coercion: number vs boolean)"
          },
          {
            "title": "Logical Operator Return Values",
            "language": "javascript",
            "id": "example_type_coercion_4",
            "code": "console.log(true && 'Hello');   // 'Hello' (returns the last truthy operand)\nconsole.log(false || 'World');  // 'World' (returns the first truthy operand)\nconsole.log(0 || false);      // false (returns the last falsy operand)\nconsole.log('Cat' && 'Dog');  // 'Dog' (returns the last truthy operand)",
            "explanation": "Logical operators in JavaScript (`&&` and `||`) do not strictly return `true` or `false`. Instead, `&&` returns the value of the first falsy operand it encounters, or the value of the last operand if all are truthy. `||` returns the value of the first truthy operand it encounters, or the value of the last operand if all are falsy."
          },
          {
            "explanation": "JavaScript automatically converts numeric string property keys to numbers when accessing object properties. This means `obj[1]` and `obj['1']` refer to the same property. However, non-numeric string keys like `'name'` must be accessed using their string literal or a variable holding the string.",
            "code": "const obj = { 1: 'valueOne' };\nconsole.log(obj[1]);     // 'valueOne'\nconsole.log(obj['1']);   // 'valueOne' (numeric string key is coerced to number)\n\nconst obj2 = { 'name': 'Alice' };\n// console.log(obj2[name]); // ReferenceError: name is not defined (unless 'name' is a variable)\nconsole.log(obj2['name']); // 'Alice'",
            "id": "example_type_coercion_5",
            "title": "Object Property Key Coercion",
            "language": "javascript"
          }
        ],
        "title": "JavaScript Type Coercion and Peculiarities",
        "relatedTasks": [
          "task_type_coercion_1"
        ],
        "tags": [
          "type-coercion",
          "javascript-fundamentals",
          "operators",
          "gotchas",
          "infinity",
          "nan",
          "equality",
          "logical-operators"
        ],
        "relatedQuestions": [
          "question_type_coercion_mcq_1",
          "question_type_coercion_open_1",
          "question_type_coercion_code_1",
          "question_type_coercion_flashcard_1"
        ],
        "learningPath": "intermediate",
        "complexity": 7,
        "interviewRelevance": 9,
        "prerequisites": [
          "basic_javascript_types",
          "basic_javascript_operators"
        ],
        "content": "## Introduction to Type Coercion\nType coercion is JavaScript's automatic conversion of values from one data type to another, either implicitly (e.g., during operations) or explicitly (e.g., using `Number()`). Understanding coercion is crucial for predicting how JavaScript behaves, especially with loose equality (`==`) and arithmetic operations.\n\n### Implicit Type Coercion\nJavaScript frequently performs implicit type coercion when operands of an operation are of different types. This can lead to unexpected results if not understood.\n\n#### Arithmetic Operators\n- **Addition (`+` operator)**: This operator is unique because it performs *either* numeric addition *or* string concatenation. If *any* operand is a string, the other operand(s) will be coerced to strings, and concatenation will occur. Otherwise, operands are coerced to numbers for addition.\n- **Subtraction (`-`), Multiplication (`*`), Division (`/`), Modulo (`%`)**: These operators always attempt to convert operands to numbers. If a non-numeric value cannot be meaningfully converted to a number, the result will be `NaN` (Not a Number).\n\n#### Comparison Operators\n- **Loose Equality (`==`)**: This operator performs type coercion before comparison. If the operands are of different types, JavaScript attempts to convert one or both to a common type before comparing their values.\n  - `null == undefined` is `true`.\n  - `0 == false` is `true`.\n  - `'1' == 1` is `true`.\n- **Strict Equality (`===`)**: This operator compares both the value *and* the type without any type coercion. This is generally preferred for predictability.\n\n#### Other Peculiarities\n- **Division by Zero**: Unlike many other languages, dividing by zero in JavaScript does not throw an error. `5 / 0` results in `Infinity`, and `-5 / 0` results in `-Infinity`.\n- **Operations with `undefined`**: Most arithmetic operations involving `undefined` will result in `NaN` because `undefined` cannot be reliably coerced to a numeric value.\n- **Empty Arrays (`[]`)**: When an empty array is coerced to a primitive (e.g., for arithmetic or string concatenation), it typically becomes an empty string (`\"\"`). This is relevant in contexts like the `+` operator, where it can lead to string concatenation.\n- **Logical Operators (`&&`, `||`)**: These operators do not always return a boolean `true` or `false`. Instead, they return the value of one of the operands. `&&` returns the first falsy operand or the last truthy operand. `||` returns the first truthy operand or the last falsy operand.\n- **Object Property Access**: When accessing object properties, numeric string keys (e.g., `obj['1']`) and number keys (e.g., `obj[1]`) are treated as equivalent. This is because JavaScript internally converts numeric string keys to numbers when possible for property lookup.\n",
        "id": "theory_type_coercion_peculiarities"
      },
      {
        "content": "## Understanding Hoisting\nHoisting is a JavaScript mechanism where variable and function declarations are moved to the top of their containing scope (global or function scope) during the compilation phase, *before* code execution. This means you can use variables and call functions before they are formally declared in your code.\n\n### Variable Hoisting (`var`)\nVariables declared with `var` are hoisted to the top of their function or global scope. However, only their *declaration* is hoisted, not their *initialization*. This means that if you try to access a `var` variable before its assignment, its value will be `undefined`.\n\n### Function Hoisting\n#### Function Declarations\nFunction declarations (`function foo() {}`) are *fully* hoisted. This means both the function's name and its definition are moved to the top of the scope. Consequently, you can call a function declared this way anywhere within its scope, even before its actual declaration in the code.\n\n#### Function Expressions\nFunction expressions (e.g., `const foo = function() {};` or `const bar = () => {};`) are *not* hoisted in the same way as function declarations. They behave like `var` variables in terms of hoisting: only the variable holding the function expression is hoisted (and initialized to `undefined` for `var`). The actual function assignment happens at the line of code where it's defined. Attempting to call a function expression before its assignment will result in a `TypeError: [variable] is not a function` (if declared with `var`) or a `ReferenceError` (if declared with `let`/`const` due to TDZ).\n\n### Hoisting Priority and Behavior\nWhen a variable and a function declaration with the same name exist in the same scope, the function declaration takes precedence during the initial hoisting phase. However, if a `var` variable then gets an assignment, that assignment will overwrite the function reference.\n\n### `let` and `const` and the Temporal Dead Zone (TDZ)\nVariables declared with `let` and `const` are also hoisted, but they behave differently from `var`. While their declarations are moved to the top of the block scope, they are *not* initialized. Instead, they enter a \"Temporal Dead Zone\" (TDZ) from the beginning of their block until their declaration is encountered during execution. Attempting to access `let` or `const` variables within the TDZ will result in a `ReferenceError`, not `undefined`.\n\n**Key Differences:**\n- `var`: Hoisted and initialized with `undefined`. Accessible before declaration (value `undefined`). Function-scoped.\n- `let`/`const`: Hoisted but *not* initialized. Enter TDZ. Accessible only after declaration. Block-scoped.\n",
        "tags": [
          "hoisting",
          "scope",
          "temporal-dead-zone",
          "var-let-const",
          "javascript-fundamentals",
          "execution-context"
        ],
        "id": "theory_hoisting_temporal_dead_zone",
        "technology": "JavaScript",
        "relatedTasks": [
          "task_hoisting_1"
        ],
        "requiredFor": [
          "closure_understanding",
          "module_patterns"
        ],
        "complexity": 8,
        "learningPath": "intermediate",
        "interviewRelevance": 9,
        "examples": [
          {
            "language": "javascript",
            "title": "Variable Hoisting with `var`",
            "id": "example_hoisting_1",
            "code": "console.log(x); // undefined\nvar x = 5;\nconsole.log(x); // 5\n\n// How JavaScript sees it:\n// var x; (declaration hoisted)\n// console.log(x); (x is undefined)\n// x = 5;\n// console.log(x); (x is 5)",
            "explanation": "This example clearly shows `var` variable hoisting. The declaration `var x;` is moved to the top, making `x` accessible but `undefined` before its assignment. Once `x = 5` is executed, its value updates."
          },
          {
            "title": "Function Declaration Hoisting",
            "language": "javascript",
            "id": "example_hoisting_2",
            "explanation": "Function declarations are fully hoisted. This means the entire function definition is available throughout its scope, allowing it to be called before its physical declaration in the code.",
            "code": "console.log(foo()); // \"bar\"\nfunction foo() {\n  return \"bar\";\n}"
          },
          {
            "id": "example_hoisting_3",
            "language": "javascript",
            "explanation": "Function expressions, whether assigned to `var`, `let`, or `const`, are not fully hoisted. Only the variable `varBaz` is hoisted (and initialized to `undefined` for `var`). Trying to call it before the assignment will result in an error because `undefined` is not a function.",
            "title": "Function Expression (Not Fully Hoisted)",
            "code": "// console.log(varBaz()); // Error: varBaz is not a function\nvar varBaz = function() {\n  return \"baz\";\n};\nconsole.log(varBaz()); // \"baz\"\n\n// How JavaScript sees it:\n// var varBaz; (declaration hoisted, initialized to undefined)\n// console.log(varBaz()); // Tries to call undefined(), leads to TypeError\n// varBaz = function() { ... }; (assignment happens here)\n// console.log(varBaz()); // Works now"
          },
          {
            "language": "javascript",
            "id": "example_hoisting_4",
            "title": "Hoisting Priority: Function vs Variable `var`",
            "explanation": "This example demonstrates that while function declarations take priority over `var` variable declarations during the initial hoisting pass, subsequent variable assignments (`var x = 1;`) will overwrite the function reference. This is a common 'gotcha' related to scope and hoisting.",
            "code": "(function() {\n  var x = 1;\n  function x() {};\n  console.log(x); // Outputs: 1\n})();\n\n// Breakdown:\n// 1. Function declaration `function x() {}` is hoisted first.\n// 2. Variable declaration `var x;` is hoisted (but doesn't override the function initially).\n// 3. Execution starts: `var x = 1;` assigns 1 to x, effectively overwriting the function reference.\n// 4. `console.log(x)` outputs 1."
          },
          {
            "language": "javascript",
            "title": "Temporal Dead Zone with `let` and `const`",
            "id": "example_hoisting_5",
            "code": "// console.log(z); // ReferenceError: Cannot access 'z' before initialization\nlet z = 5;\nconsole.log(z); // 5\n\n// console.log(y); // ReferenceError: Cannot access 'y' before initialization\nconst y = 10;\nconsole.log(y); // 10",
            "explanation": "Variables declared with `let` and `const` are hoisted, but they are not initialized until their declaration line is executed. The period between the start of their block scope and their declaration is called the Temporal Dead Zone (TDZ). Accessing them within the TDZ results in a `ReferenceError`, distinct from the `undefined` behavior of `var`."
          }
        ],
        "relatedQuestions": [
          "question_hoisting_mcq_1",
          "question_hoisting_open_1",
          "question_hoisting_code_1",
          "question_hoisting_flashcard_1"
        ],
        "title": "JavaScript Hoisting and Temporal Dead Zone",
        "prerequisites": [
          "basic_javascript_variables",
          "javascript_scopes"
        ]
      },
      {
        "technology": "JavaScript",
        "prerequisites": [
          "javascript_variables",
          "javascript_scopes",
          "hoisting_basics"
        ],
        "learningPath": "intermediate",
        "content": "## Function Definitions in JavaScript\nJavaScript offers several ways to define functions, each with distinct characteristics regarding hoisting, `this` binding, and syntax.\n\n### Function Declaration\nFunction declarations are the most common way to define a function. They start with the `function` keyword, followed by the function name, parameters, and then the function body. They are *hoisted*, meaning they can be called before their definition in the code.\n\n```javascript\nfunction functionName(parameters) {\n  // function body\n  return value;\n}\n```\n\n### Function Expression\nFunction expressions define a function as part of an expression, usually assigned to a variable. They can be anonymous (without a name) or named. Unlike function declarations, function expressions are *not hoisted* in the same way; only the variable they are assigned to is hoisted (and for `var`, initialized to `undefined`). The function itself is only available after the line of code where it's defined has been executed.\n\n#### Anonymous Function Expression\n```javascript\nconst functionName = function(parameters) {\n  // function body\n  return value;\n};\n```\n\n#### Named Function Expression\n```javascript\nconst functionName = function funcName(parameters) {\n  // funcName is only accessible within the function body itself\n  // for recursion or debugging purposes.\n  return value;\n};\n```\n\n#### Arrow Function Expression (ES6+)\nArrow functions are a more concise syntax for writing function expressions. They also have lexical `this` binding, meaning `this` is bound to the surrounding (lexical) context and not rebound based on how the function is called. Arrow functions are always anonymous (unless assigned to a named variable, which is the name of the variable, not the function itself).\n\n```javascript\nconst functionName = (parameters) => {\n  // function body\n  return value;\n};\n\n// Concise body for single expression return:\nconst functionName = (parameters) => expression;\n```\n\n### IIFE (Immediately Invoked Function Expression)\nAn IIFE is a JavaScript function that runs as soon as it is defined. It's a design pattern often used to create a private scope for variables and functions, thereby preventing them from polluting the global namespace. This is especially useful in older JavaScript environments or when building modules.\n\n#### Syntax:\n```javascript\n(function() {\n  // ... private code ...\n})();\n\n// Or with arrow function (less common for traditional IIFE pattern):\n(() => {\n  // ... private code ...\n})();\n```\n\n#### Purpose of IIFE:\n1.  **Scope Isolation**: Encapsulates variables, preventing conflicts with other scripts and the global scope.\n2.  **Data Privacy**: Creates a private scope for data, exposing only what's necessary (e.g., using the module pattern).\n3.  **Alias Creation**: Can be used to create aliases for global variables (e.g., `(function($){ /* use $ for jQuery */ })(jQuery);`).\n4.  **One-time Initialization**: Executes code once upon definition.\n",
        "tags": [
          "functions",
          "function-declaration",
          "function-expression",
          "arrow-functions",
          "iife",
          "scope",
          "module-pattern"
        ],
        "examples": [
          {
            "id": "example_functions_1",
            "language": "javascript",
            "title": "Function Declaration vs. Expression Comparison",
            "explanation": "This example highlights the key difference in hoisting. `addDecl` can be called before its definition because function declarations are fully hoisted. `addExpr` and `addArrow`, being function expressions, must be defined before they are called, as only their variable assignments are hoisted (and for `const`/`let`, they are in the TDZ before assignment).",
            "code": "// Function Declaration\nconsole.log(addDecl(2, 3)); // 5 (works due to hoisting)\nfunction addDecl(a, b) {\n  return a + b;\n}\n\n// Function Expression\n// console.log(addExpr(2, 3)); // TypeError: addExpr is not a function (before definition)\nconst addExpr = function(a, b) {\n  return a + b;\n};\nconsole.log(addExpr(2, 3)); // 5 (works after definition)\n\n// Arrow Function Expression\nconst addArrow = (a, b) => a + b;\nconsole.log(addArrow(2, 3)); // 5"
          },
          {
            "code": "(function() {\n  var privateVar = \"I'm private!\";\n  console.log(privateVar); // \"I'm private!\" (accessible inside IIFE)\n})();\n\n// console.log(privateVar); // ReferenceError: privateVar is not defined (not accessible outside IIFE)",
            "explanation": "This IIFE creates its own isolated scope. `privateVar` is defined within this scope and is not accessible from the global scope, demonstrating how IIFEs prevent variable pollution and provide data privacy.",
            "language": "javascript",
            "id": "example_iife_1",
            "title": "Basic IIFE for Scope Isolation"
          },
          {
            "language": "javascript",
            "explanation": "This example shows an IIFE used to implement a basic module pattern. `count` is a private variable inaccessible from outside the IIFE. Only the `increment` and `getCount` functions, exposed through the returned object, can interact with `count`. This is a classic way to achieve encapsulation and maintain state.",
            "code": "const counterModule = (function() {\n  let count = 0; // private variable\n\n  function increment() {\n    count++;\n  }\n\n  function getCount() {\n    return count;\n  }\n\n  return {\n    increment: increment,\n    getCount: getCount\n  };\n})();\n\nconsole.log(counterModule.getCount()); // 0\ncounterModule.increment();\ncounterModule.increment();\nconsole.log(counterModule.getCount()); // 2\n// console.log(counterModule.count); // undefined (private)",
            "id": "example_iife_2",
            "title": "IIFE with Parameters and Return Value (Module Pattern)"
          }
        ],
        "id": "theory_function_mechanics_iife",
        "requiredFor": [
          "closure_understanding",
          "design_patterns",
          "frontend_architecture"
        ],
        "title": "JavaScript Function Declarations, Expressions, and IIFEs",
        "relatedTasks": [
          "task_functions_1"
        ],
        "interviewRelevance": 8,
        "complexity": 7,
        "relatedQuestions": [
          "question_functions_mcq_1",
          "question_functions_open_1",
          "question_functions_code_1",
          "question_functions_flashcard_1"
        ]
      }
    ],
    "completed": false
  },
  {
    "startLine": 900,
    "displayEndLine": 999,
    "theory": [
      {
        "interviewRelevance": 8,
        "learningPath": "intermediate",
        "complexity": 7,
        "technology": "JavaScript",
        "requiredFor": [
          "es6_classes",
          "javascript_design_patterns"
        ],
        "title": "Prototypal Inheritance in JavaScript",
        "examples": [
          {
            "explanation": "This example demonstrates how to set up prototypal inheritance using constructor functions and `Object.create()`. `Person.call(this, firstName)` is used to invoke the `Person` constructor in the context of the `Student` instance, inheriting `firstName`. `Student.prototype = Object.create(Person.prototype)` establishes the prototype chain, making `Student`'s prototype inherit from `Person`'s prototype. The `constructor` property is then manually reset to `Student` to maintain correct `instanceof` and constructor identification. Finally, `Student.prototype.sayHello` overrides the parent's method.",
            "title": "Basic Prototypal Inheritance",
            "code": "function Person(firstName) {\n  this.firstName = firstName;\n}\n\nPerson.prototype.sayHello = function() {\n  console.log(\"Hello, I'm \" + this.firstName);\n};\n\nfunction Student(firstName, subject) {\n  Person.call(this, firstName); // Call parent constructor to inherit properties\n  this.subject = subject;\n}\n\n// Create Student.prototype that inherits from Person.prototype\nStudent.prototype = Object.create(Person.prototype);\n// Fix the constructor reference because Object.create resets it\nStudent.prototype.constructor = Student;\n\n// Override a method\nStudent.prototype.sayHello = function() {\n  console.log(\"Hello, I'm \" + this.firstName + \". I'm studying \" + this.subject + \".\");\n};\n\nvar student = new Student(\"John\", \"Computer Science\");\nstudent.sayHello(); // \"Hello, I'm John. I'm studying Computer Science.\"\n\nvar person = new Person(\"Jane\");\nperson.sayHello(); // \"Hello, I'm Jane\"\n\nconsole.log(student instanceof Student); // true\nconsole.log(student instanceof Person);  // true\nconsole.log(student.constructor === Student); // true\n",
            "id": "example_prototypal_inheritance_1",
            "language": "javascript"
          }
        ],
        "content": "JavaScript is a prototype-based language, meaning that objects can inherit properties and methods from other objects. This mechanism is known as prototypal inheritance. Before ES6 classes, developers directly manipulated prototypes to achieve inheritance.\n\n## Key Concepts\n- **Prototype Chain**: Every JavaScript object has an internal slot called `[[Prototype]]` (exposed via `__proto__` in some environments, or `Object.getPrototypeOf()`). When a property or method is accessed on an object, if it's not found directly on the object, JavaScript looks up the prototype chain until it finds the property or reaches the end of the chain (i.e., `null`).\n- **`prototype` Property**: Functions in JavaScript automatically get a `prototype` property. When a function is used as a constructor (with the `new` keyword), the `prototype` property of the constructor function becomes the `[[Prototype]]` of the newly created object.\n- **`Object.create()`**: This method creates a new object, using an existing object as the prototype of the newly created object. It's a clean way to set up the prototype chain.\n- **`constructor` Property**: Every object created by a constructor function implicitly has a `constructor` property that points back to the constructor function. When manually setting a prototype using `Object.create()`, it's crucial to reset the `constructor` property of the `prototype` to point back to the correct constructor function. This ensures `instanceof` and `constructor` checks work as expected.\n- **Method Overriding**: Child objects/constructors can define methods with the same name as methods in their prototype chain. When such a method is called on the child object, its own version takes precedence over the parent's version.",
        "id": "theory_prototypal_inheritance",
        "prerequisites": [
          "javascript_objects",
          "javascript_functions",
          "this_keyword"
        ],
        "tags": [
          "JavaScript",
          "Inheritance",
          "Prototypes",
          "ES5",
          "Object.create",
          "Constructor Function"
        ],
        "relatedTasks": [
          "task_prototypal_inheritance_1"
        ],
        "relatedQuestions": [
          "question_prototypal_inheritance_1",
          "question_prototypal_inheritance_2",
          "question_prototypal_inheritance_3"
        ]
      },
      {
        "complexity": 6,
        "learningPath": "intermediate",
        "examples": [
          {
            "language": "javascript",
            "id": "example_es6_class_inheritance_1",
            "title": "ES6 Class Inheritance Example",
            "code": "class Person {\n  constructor(firstName) {\n    this.firstName = firstName;\n  }\n  \n  sayHello() {\n    console.log(\"Hello, I'm \" + this.firstName);\n  }\n}\n\nclass Student extends Person {\n  constructor(firstName, subject) {\n    super(firstName); // Call parent constructor\n    this.subject = subject;\n  }\n  \n  sayHello() { // Overriding method\n    console.log(\"Hello, I'm \" + this.firstName + \". I'm studying \" + this.subject + \".\");\n  }\n\n  study() {\n    console.log(`${this.firstName} is studying ${this.subject}.`);\n  }\n}\n\nconst student = new Student(\"John\", \"Computer Science\");\nstudent.sayHello(); // \"Hello, I'm John. I'm studying Computer Science.\"\nstudent.study();    // \"John is studying Computer Science.\"\n\nconst person = new Person(\"Alice\");\nperson.sayHello(); // \"Hello, I'm Alice\"\n\nconsole.log(student instanceof Student); // true\nconsole.log(student instanceof Person);  // true\n",
            "explanation": "This example showcases ES6 class syntax for inheritance. The `Student` class `extends` the `Person` class, inheriting its properties and methods. The `constructor` of `Student` calls `super(firstName)` to ensure the `Person` constructor initializes the `firstName` property. The `sayHello` method in `Student` overrides the one in `Person`. This syntax offers a cleaner and more readable way to define inheritance hierarchies compared to direct prototype manipulation."
          }
        ],
        "title": "ES6 Class Syntax for Inheritance",
        "tags": [
          "JavaScript",
          "ES6",
          "Classes",
          "Inheritance",
          "Syntactic Sugar",
          "super"
        ],
        "relatedQuestions": [
          "question_es6_class_1",
          "question_es6_class_2",
          "question_es6_class_3",
          "question_es6_class_4"
        ],
        "content": "ES6 (ECMAScript 2015) introduced a new syntax for creating 'classes' in JavaScript, providing a more familiar object-oriented programming (OOP) feel for developers coming from other languages like Java or C++. It's important to understand that ES6 classes are primarily syntactic sugar over JavaScript's existing prototypal inheritance mechanism; they do not introduce a new inheritance model.\n\n## Key Concepts\n- **`class` Keyword**: Used to declare a class. Class declarations are not hoisted like function declarations.\n- **`constructor` Method**: A special method for creating and initializing an object created with a class. There can only be one constructor method per class. If not specified, a default empty constructor is provided.\n- **`extends` Keyword**: Used to create a child class that inherits from a parent class. This keyword automatically sets up the prototype chain correctly.\n- **`super()` Keyword**: When a child class has its own `constructor`, it **must** call `super()` before accessing `this`. `super()` calls the parent class's constructor, ensuring that the parent's initialization logic is executed and `this` is correctly bound and initialized within the subclass.\n- **Method Overriding**: Similar to prototypal inheritance, methods defined in a child class with the same name as methods in the parent class will override the parent's implementation. You can access the parent's method using `super.methodName()`.\n- **No Hoisting**: Unlike function declarations, class declarations are not hoisted. You must define a class before you use it.",
        "relatedTasks": [
          "task_es6_class_inheritance_1"
        ],
        "technology": "JavaScript",
        "prerequisites": [
          "prototypal_inheritance"
        ],
        "id": "theory_es6_class_syntax",
        "interviewRelevance": 9,
        "requiredFor": [
          "react_components",
          "typescript_classes"
        ]
      },
      {
        "examples": [
          {
            "language": "javascript",
            "explanation": "This example demonstrates functional inheritance. The `Machine` function defines an `enabled` variable locally, which becomes private due to closures formed by `enable`, `disable`, and `isEnabled` methods. `CoffeeMachine` 'inherits' these methods by calling `Machine.call(this)`, effectively copying the methods onto its own instance. It also defines its own private `waterAmount` using a closure. This pattern provides strong encapsulation but creates new copies of methods for each instance.",
            "code": "function Machine() {\n  let enabled = false; // Private variable via closure\n  \n  this.enable = function() {\n    enabled = true;\n  };\n  \n  this.disable = function() {\n    enabled = false;\n  };\n  \n  this.isEnabled = function() {\n    return enabled;\n  };\n}\n\nfunction CoffeeMachine(power) {\n  // Inherit methods from Machine by calling its constructor with `this` context\n  Machine.call(this);\n  \n  let waterAmount = 0; // Private variable specific to CoffeeMachine\n  \n  this.setWaterAmount = function(amount) {\n    if (amount < 0) {\n        console.error(\"Water amount cannot be negative.\");\n        return;\n    }\n    waterAmount = amount;\n  };\n  \n  this.getWaterAmount = function() {\n    return waterAmount;\n  };\n  \n  this.brew = function() {\n    if (this.isEnabled()) {\n      console.log(`Making coffee with ${waterAmount}ml of water using ${power}W power`);\n    } else {\n      console.log(\"Coffee machine is off\");\n    }\n  };\n}\n\nconst coffeeMachine = new CoffeeMachine(1000);\nconsole.log(coffeeMachine.isEnabled()); // false (initially)\ncoffeeMachine.enable();\ncoffeeMachine.setWaterAmount(200);\ncoffeeMachine.brew(); // \"Making coffee with 200ml of water using 1000W power\"\ncoffeeMachine.disable();\ncoffeeMachine.brew(); // \"Coffee machine is off\"\n\n// Attempting to access private variable directly (will fail)\n// console.log(coffeeMachine.enabled); // undefined\n// console.log(coffeeMachine.waterAmount); // undefined\n",
            "title": "Functional Inheritance with Closures for Private State",
            "id": "example_functional_inheritance_1"
          }
        ],
        "id": "theory_functional_inheritance_and_closures",
        "relatedTasks": [
          "task_functional_inheritance_1"
        ],
        "title": "Functional Inheritance and Closures for Encapsulation",
        "requiredFor": [
          "javascript_design_patterns",
          "advanced_closure_patterns"
        ],
        "relatedQuestions": [
          "question_functional_inheritance_1",
          "question_functional_inheritance_2",
          "question_functional_inheritance_3"
        ],
        "content": "Functional inheritance is a pattern where an object is created by a function, and methods and properties are added to it directly, often leveraging closures to achieve privacy. This differs from prototypal or class-based inheritance as it doesn't typically involve `prototype` chains or `new` keyword instantiation in the same way, though it can compose with them.\n\n## Key Concepts\n- **Closure**: A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In JavaScript, closures are created every time a function is created, at function creation time. They give you access to an outer function's scope from an inner function.\n- **Private Variables/Methods via Closures**: Variables declared with `let` or `const` (or `var` in older code) inside a function are local to that function. If an inner function (which forms a closure) exposes methods that access these local variables, those variables effectively become 'private' to the object returned by the outer function. They cannot be directly accessed from outside.\n- **Functional Inheritance Pattern**: This pattern involves one function calling another function (often using `call()` or `apply()`) to add properties and methods to `this`, or directly manipulating an object passed as an argument. The 'inheritance' part comes from the fact that common behaviors can be bundled into functions and then 'mixed in' or applied to different objects.\n- **Advantages**: True privacy (data is not exposed), flexible composition.\n- **Disadvantages**: Each instance gets its own copy of methods (potential memory inefficiency), `instanceof` operator doesn't work for type checking (as there's no shared `prototype`), difficult to chain prototypes directly.",
        "tags": [
          "JavaScript",
          "Functional Inheritance",
          "Closures",
          "Encapsulation",
          "Privacy"
        ],
        "prerequisites": [
          "javascript_scope",
          "this_keyword",
          "call_apply_bind"
        ],
        "interviewRelevance": 7,
        "technology": "JavaScript",
        "complexity": 7,
        "learningPath": "advanced"
      },
      {
        "id": "theory_encapsulation_javascript",
        "relatedTasks": [
          "task_encapsulation_1",
          "task_encapsulation_2"
        ],
        "relatedQuestions": [
          "question_encapsulation_1",
          "question_encapsulation_2",
          "question_encapsulation_3",
          "question_encapsulation_4",
          "question_encapsulation_5"
        ],
        "requiredFor": [
          "javascript_design_patterns",
          "secure_coding"
        ],
        "tags": [
          "JavaScript",
          "Encapsulation",
          "Closures",
          "Module Pattern",
          "ES6 Modules",
          "Private Class Fields",
          "WeakMap",
          "OOP"
        ],
        "examples": [],
        "content": "Encapsulation is one of the fundamental principles of object-oriented programming (OOP). It refers to the bundling of data (attributes) and methods (functions) that operate on the data into a single unit (an object or module), and restricting direct access to some of an object's components. This restriction is often achieved through 'information hiding', where the internal state of an object is not directly exposed to the outside.\n\nIn JavaScript, due to its dynamic and prototype-based nature, achieving strict encapsulation like in some classical OOP languages (e.g., C++, Java with `private` keywords) has historically been different. However, several patterns and features allow developers to achieve varying degrees of encapsulation:\n\n## Techniques for Encapsulation:\n\n1.  **Closures (Functional/Module Pattern)**:\n    *   **Description**: As seen in functional inheritance, variables declared inside a function are local to that function. If an inner function (a closure) is returned or assigned as a public method, it can access these 'private' variables, while the variables themselves are inaccessible from outside. This is a very common and powerful way to create private members.\n    *   **Example**: The `enabled` and `waterAmount` variables in the `Machine` and `CoffeeMachine` examples from the functional inheritance section are prime examples of encapsulation through closures.\n    *   **Pros**: True privacy, widely supported.\n    *   **Cons**: Methods are recreated for each instance (potential memory overhead for many instances), no easy way to modify private variables from outside via inheritance.\n\n2.  **IIFE (Immediately Invoked Function Expression) / Module Pattern**:\n    *   **Description**: An IIFE creates a private scope for variables and functions. It typically returns an object containing public methods and properties, while keeping internal details private within the IIFE's scope. This is the foundation of the 'Module Pattern'.\n    *   **Pros**: Strong encapsulation, clean separation of public/private interfaces, prevents global scope pollution.\n    *   **Cons**: Not suitable for instance-specific private data (more for singleton-like modules or factories), doesn't easily support inheritance of private state between modules.\n\n    ```javascript\n    const CounterModule = (function() {\n      let count = 0; // Private variable\n    \n      function privateIncrement() { // Private method\n        count++;\n      }\n    \n      function privateDecrement() {\n        count--;\n      }\n    \n      return {\n        // Public interface\n        increment: function() {\n          privateIncrement();\n          console.log(`Count: ${count}`);\n        },\n        decrement: function() {\n          privateDecrement();\n          console.log(`Count: ${count}`);\n        },\n        reset: function() {\n          count = 0;\n          console.log(`Count reset: ${count}`);\n        }\n      };\n    })();\n    \n    CounterModule.increment(); // Count: 1\n    CounterModule.decrement(); // Count: 0\n    // console.log(CounterModule.count); // undefined - 'count' is private\n    ```\n\n3.  **ES6 Modules (`import`/`export`)**:\n    *   **Description**: ES6 modules inherently provide file-level scope. Anything not explicitly `export`ed from a module file is private to that module. This is a modern and standard way to achieve encapsulation at the module level.\n    *   **Pros**: Standard, tree-shaking friendly, clear dependencies.\n    *   **Cons**: Encapsulation is at the module (file) level, not directly on instances of classes within the module.\n\n    ```javascript\n    // myModule.js\n    let privateData = 'secret'; // Private to this module\n    \n    export function getPublicData() {\n      return `Public access to ${privateData}`;\n    }\n    \n    export class MyClass {\n      constructor(value) {\n        this.value = value;\n      }\n      // ...\n    }\n    \n    // anotherFile.js\n    import { getPublicData, MyClass } from './myModule.js';\n    console.log(getPublicData()); // Public access to secret\n    // console.log(privateData); // Error: privateData is not defined\n    ```\n\n4.  **Private Class Fields (ES2019+)**:\n    *   **Description**: With the introduction of private class fields (using the `#` prefix), JavaScript classes can now declare truly private instance fields and methods that are only accessible from within the class body.\n    *   **Pros**: Native syntax, true instance-level privacy, clear declaration.\n    *   **Cons**: Relatively new (may require transpilation for older environments), only works with ES6 classes.\n\n    ```javascript\n    class BankAccount {\n      #balance; // Private field\n      #pin;     // Private field\n    \n      constructor(initialBalance, pin) {\n        this.#balance = initialBalance;\n        this.#pin = pin;\n      }\n    \n      deposit(amount) {\n        if (amount > 0) {\n          this.#balance += amount;\n          console.log(`Deposited: ${amount}. New balance: ${this.#balance}`);\n        }\n      }\n    \n      withdraw(amount, enteredPin) {\n        if (enteredPin === this.#pin && amount > 0 && amount <= this.#balance) {\n          this.#balance -= amount;\n          console.log(`Withdrew: ${amount}. New balance: ${this.#balance}`);\n        } else {\n          console.log('Withdrawal failed: Invalid PIN or insufficient funds.');\n        }\n      }\n    \n      getBalance(enteredPin) {\n        if (enteredPin === this.#pin) {\n          return this.#balance;\n        } else {\n          console.log('Access denied: Invalid PIN.');\n          return null;\n        }\n      }\n    }\n    \n    const myAccount = new BankAccount(1000, 1234);\n    myAccount.deposit(500); // Deposited: 500. New balance: 1500\n    myAccount.withdraw(200, 1234); // Withdrew: 200. New balance: 1300\n    // console.log(myAccount.#balance); // SyntaxError: Private field '#balance' must be declared in an enclosing class\n    console.log(myAccount.getBalance(1234)); // 1300\n    console.log(myAccount.getBalance(9999)); // Access denied: Invalid PIN. null\n    ```\n\n5.  **WeakMaps (Advanced Privacy)**:\n    *   **Description**: WeakMaps can be used to store truly private instance data. The instance (the key) is garbage-collectable if there are no other references to it, making WeakMaps suitable for private data that doesn't prevent an object from being garbage collected. This pattern is less common for typical application code but provides robust privacy.\n    *   **Pros**: True instance-level privacy, doesn't prevent garbage collection.\n    *   **Cons**: More verbose, requires careful management, cannot easily list private properties.\n\nUnderstanding these various techniques allows a JavaScript developer to choose the appropriate level and method of encapsulation based on the project's requirements and target environment.",
        "interviewRelevance": 9,
        "learningPath": "advanced",
        "technology": "JavaScript",
        "title": "Encapsulation in JavaScript",
        "prerequisites": [
          "javascript_scope",
          "this_keyword",
          "functions"
        ],
        "complexity": 8
      }
    ],
    "endLine": 1000,
    "questions": [
      {
        "id": "question_prototypal_inheritance_1",
        "prerequisites": [
          "javascript_objects",
          "javascript_functions"
        ],
        "question": "What is the primary purpose of `Object.create(Person.prototype)` when setting up prototypal inheritance?",
        "level": "easy",
        "type": "mcq",
        "evaluationCriteria": [
          "Ability to distinguish between shallow copy and prototype linking.",
          "Understanding of the role of `prototype` property."
        ],
        "options": [
          "To copy all properties from `Person.prototype` to `Student.prototype`.",
          "To create a new instance of `Person` and assign it to `Student.prototype`.",
          "To set the prototype of the `Student.prototype` object to `Person.prototype`, establishing the inheritance chain.",
          "To execute the `Person` constructor function for `Student.prototype`."
        ],
        "topic": "Prototypal Inheritance",
        "tags": [
          "JavaScript",
          "Prototypes",
          "Inheritance",
          "Object.create"
        ],
        "keyConcepts": [
          "Prototypal Inheritance",
          "Object.create()",
          "Prototype Chain",
          "Constructor Function"
        ],
        "answer": "To set the prototype of the `Student.prototype` object to `Person.prototype`, establishing the inheritance chain.",
        "interviewFrequency": 7,
        "learningPath": "intermediate",
        "analysisPoints": [
          "Tests understanding of `Object.create()`.",
          "Highlights the distinction between copying properties and setting up the prototype chain.",
          "Reinforces the concept that `prototype` property itself is an object."
        ],
        "example": "\n```javascript\nfunction Parent() {}\nParent.prototype.greet = function() { return 'Hello'; };\n\nfunction Child() {}\nChild.prototype = Object.create(Parent.prototype);\n// Child.prototype now inherits from Parent.prototype\n\nconst child = new Child();\nconsole.log(child.greet()); // 'Hello'\n```",
        "complexity": 5
      },
      {
        "learningPath": "intermediate",
        "level": "medium",
        "id": "question_prototypal_inheritance_2",
        "interviewFrequency": 8,
        "evaluationCriteria": [
          "Clarity of explanation.",
          "Comprehensiveness of reasons for resetting `constructor`.",
          "Demonstrated understanding of JavaScript's prototype model."
        ],
        "type": "open",
        "answer": "When `Student.prototype` is set to `Object.create(Person.prototype)`, the original `constructor` property on `Student.prototype` (which pointed to `Student`) is overwritten by the new object returned by `Object.create()`. This new object's `constructor` property will point to `Person` (if `Person.prototype` had one, or to `Object` if `Person.prototype` didn't explicitly set it). Resetting `Student.prototype.constructor = Student;` restores the correct `constructor` reference. This is important for:\n1.  **`instanceof` operator**: While `instanceof` primarily checks the prototype chain, having the correct `constructor` property can be important for certain library implementations or custom checks.\n2.  **`new student.constructor(...)`**: If you want to create a new instance of the same 'type' as `student` using `student.constructor`, it needs to point to `Student`.\n3.  **Reflectability**: It maintains the expectation that `student.constructor` will correctly identify `Student` as its direct constructor, which is standard practice and helps in debugging and introspection.",
        "topic": "Prototypal Inheritance",
        "keyConcepts": [
          "Prototypal Inheritance",
          "Constructor Property",
          "Object.create()",
          "instanceof operator"
        ],
        "complexity": 7,
        "question": "When implementing prototypal inheritance as shown, why is it necessary to explicitly set `Student.prototype.constructor = Student;`?",
        "prerequisites": [
          "prototypal_inheritance",
          "javascript_objects"
        ],
        "tags": [
          "JavaScript",
          "Prototypes",
          "Inheritance",
          "Constructor",
          "Best Practices"
        ],
        "example": "\n```javascript\nfunction Animal() {}\nfunction Dog() {}\n\nDog.prototype = Object.create(Animal.prototype);\n// At this point, Dog.prototype.constructor points to Animal (or Object if Animal didn't set it).\n\n// Correcting the constructor\nDog.prototype.constructor = Dog;\n\nconst myDog = new Dog();\nconsole.log(myDog.constructor === Dog);    // true after correction\nconsole.log(myDog instanceof Dog);       // true\nconsole.log(myDog instanceof Animal);    // true\n```",
        "analysisPoints": [
          "Understanding of `constructor` property's default behavior.",
          "Knowledge of how `Object.create()` affects the `constructor`.",
          "Ability to explain the practical implications of a missing or incorrect `constructor` reference."
        ]
      },
      {
        "prerequisites": [
          "prototypal_inheritance",
          "call_apply_bind"
        ],
        "tags": [
          "JavaScript",
          "Prototypes",
          "Inheritance",
          "Advanced",
          "This",
          "Call"
        ],
        "id": "question_prototypal_inheritance_3",
        "keyConcepts": [
          "Prototypal Inheritance",
          "Method Overriding",
          "Function.prototype.call()",
          "this keyword"
        ],
        "level": "hard",
        "answer": "```javascript\nfunction Person(firstName) {\n  this.firstName = firstName;\n}\n\nPerson.prototype.sayHello = function() {\n  return \"Hello, I'm \" + this.firstName;\n};\n\nfunction Student(firstName, subject) {\n  Person.call(this, firstName);\n  this.subject = subject;\n}\n\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\n\n// Modify the sayHello method to call the parent's method\nStudent.prototype.sayHello = function() {\n  // Call the parent's sayHello method using .call() with the current 'this' context\n  const parentGreeting = Person.prototype.sayHello.call(this);\n  return parentGreeting + \". I'm studying \" + this.subject + \".\";\n};\n\nvar student = new Student(\"Jane\", \"Art History\");\nconsole.log(student.sayHello()); // Expected: \"Hello, I'm Jane. I'm studying Art History.\"\n```",
        "evaluationCriteria": [
          "Correct implementation of parent method call.",
          "Accurate handling of `this` context.",
          "Completeness of the solution.",
          "Adherence to the 'no ES6 class' constraint."
        ],
        "complexity": 8,
        "type": "code",
        "topic": "Prototypal Inheritance vs. ES6 Classes",
        "interviewFrequency": 7,
        "learningPath": "advanced",
        "question": "Given the following prototypal inheritance setup, modify the `Student`'s `sayHello` method to call the `Person`'s `sayHello` method and then append the subject. Do not use ES6 class syntax.",
        "analysisPoints": [
          "Tests understanding of calling parent methods in prototypal inheritance.",
          "Evaluates correct usage of `call()` for setting `this` context.",
          "Checks the ability to combine parent logic with child-specific enhancements."
        ],
        "example": ""
      },
      {
        "keyConcepts": [
          "ES6 Classes",
          "Inheritance",
          "Constructor",
          "super()"
        ],
        "answer": "To call the constructor of the parent class.",
        "options": [
          "To return the `this` context of the child class.",
          "To call a static method of the parent class.",
          "To call the constructor of the parent class.",
          "To access properties of the parent class directly without invoking its constructor."
        ],
        "complexity": 4,
        "example": "\n```typescript\nclass Parent {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nclass Child extends Parent {\n  constructor(name, age) {\n    super(name); // Must be called before `this` is used in Child constructor\n    this.age = age;\n  }\n}\n```",
        "tags": [
          "JavaScript",
          "ES6",
          "Classes",
          "super"
        ],
        "learningPath": "intermediate",
        "evaluationCriteria": [
          "Correct identification of `super()` purpose.",
          "Recognition of the context of `super()` within constructors."
        ],
        "topic": "ES6 Class Syntax",
        "level": "easy",
        "id": "question_es6_class_1",
        "prerequisites": [
          "es6_class_syntax"
        ],
        "analysisPoints": [
          "Tests basic understanding of `super()` in ES6 classes.",
          "Distinguishes `super()` from other `super` keyword uses (e.g., `super.method`).",
          "Reinforces the requirement to call `super()` before `this` in child constructors."
        ],
        "interviewFrequency": 9,
        "question": "What is `super()` used for in an ES6 child class constructor?",
        "type": "mcq"
      },
      {
        "answer": "ES6 classes are **syntactic sugar** over JavaScript's existing prototypal inheritance model. They do not introduce a new object-oriented inheritance mechanism under the hood. Instead, they provide a cleaner, more familiar syntax for developers to define constructor functions, attach methods to their `prototype` property, and manage prototype chains.\n\n**Explanation:**\n*   When you define an ES6 class, JavaScript internally creates a constructor function and sets up its `prototype` property. Methods defined in the class body are added to the constructor's `prototype`.\n*   When you use `extends`, JavaScript automatically handles the `Object.create()` part and the `constructor` property correction that would be manually required with traditional prototypal inheritance.\n*   The `super()` call in a subclass constructor essentially performs the `Parent.call(this, ...)` equivalent, ensuring the parent's constructor is invoked with the correct `this` context.\n\nThis 'syntactic sugar' approach makes JavaScript inheritance more intuitive for developers familiar with class-based languages, while retaining the underlying flexibility and nature of prototypal inheritance.",
        "tags": [
          "JavaScript",
          "ES6",
          "Classes",
          "Prototypes",
          "Syntactic Sugar"
        ],
        "analysisPoints": [
          "Understanding of the 'syntactic sugar' concept.",
          "Ability to explain the underlying prototypal mechanisms that ES6 classes abstract away.",
          "Comparison between ES6 class syntax and pre-ES6 prototypal inheritance."
        ],
        "topic": "ES6 Class Syntax",
        "level": "medium",
        "question": "Are ES6 classes truly a new inheritance model in JavaScript, or are they syntactic sugar? Explain your answer.",
        "type": "open",
        "prerequisites": [
          "prototypal_inheritance",
          "es6_class_syntax"
        ],
        "evaluationCriteria": [
          "Clarity and accuracy of the 'syntactic sugar' explanation.",
          "Demonstrated knowledge of how classes map to prototypes.",
          "Coherent comparison of the two approaches."
        ],
        "complexity": 7,
        "example": "",
        "interviewFrequency": 8,
        "id": "question_es6_class_2",
        "keyConcepts": [
          "ES6 Classes",
          "Syntactic Sugar",
          "Prototypal Inheritance",
          "Constructor Function",
          "Prototype Chain"
        ],
        "learningPath": "intermediate"
      },
      {
        "id": "question_es6_class_3",
        "interviewFrequency": 8,
        "complexity": 6,
        "evaluationCriteria": [
          "Syntactic correctness of ES6 classes.",
          "Accurate inheritance setup.",
          "Correct implementation of method overriding with parent method call.",
          "Readability and best practices."
        ],
        "example": "",
        "analysisPoints": [
          "Correct use of `extends` and `super()` in constructor.",
          "Proper method overriding in a child class.",
          "Effective use of `super.methodName()` to access parent methods."
        ],
        "keyConcepts": [
          "ES6 Classes",
          "Inheritance",
          "super()",
          "Method Overriding",
          "super.methodName()"
        ],
        "topic": "ES6 Class Syntax",
        "answer": "```javascript\nclass Vehicle {\n  constructor(make, model) {\n    this.make = make;\n    this.model = model;\n  }\n\n  displayInfo() {\n    return `Make: ${this.make}, Model: ${this.model}`;\n  }\n}\n\nclass Car extends Vehicle {\n  constructor(make, model, numDoors) {\n    super(make, model);\n    this.numDoors = numDoors;\n  }\n\n  displayInfo() {\n    // Call the parent's displayInfo method using super.methodName()\n    const vehicleInfo = super.displayInfo();\n    return `${vehicleInfo}, Doors: ${this.numDoors}`;\n  }\n}\n\nconst myCar = new Car(\"Toyota\", \"Camry\", 4);\nconsole.log(myCar.displayInfo()); // Expected: \"Make: Toyota, Model: Camry, Doors: 4\"\n\nconst myVehicle = new Vehicle(\"Honda\", \"CRV\");\nconsole.log(myVehicle.displayInfo()); // Expected: \"Make: Honda, Model: CRV\"\n```",
        "level": "medium",
        "prerequisites": [
          "es6_class_syntax"
        ],
        "type": "code",
        "question": "Create an ES6 class `Vehicle` with a `make` and `model`. Then create a class `Car` that `extends` `Vehicle` and adds a `numDoors` property. Override a `displayInfo` method in `Car` to include `numDoors` while still using `super.displayInfo()` from `Vehicle`.",
        "tags": [
          "JavaScript",
          "ES6",
          "Classes",
          "Inheritance",
          "Code Challenge"
        ],
        "learningPath": "intermediate"
      },
      {
        "learningPath": "intermediate",
        "complexity": 7,
        "analysisPoints": [
          "Understanding of hoisting.",
          "Knowledge of the temporal dead zone.",
          "Comparison of hoisting rules for different JavaScript constructs."
        ],
        "evaluationCriteria": [
          "Accuracy of hoisting explanation.",
          "Correct distinction between function and class hoisting.",
          "Mention of `ReferenceError` or temporal dead zone."
        ],
        "keyConcepts": [
          "ES6 Classes",
          "Hoisting",
          "Temporal Dead Zone",
          "Function Declaration"
        ],
        "answer": "ES6 class declarations are **not hoisted** in the same way function declarations are. Function declarations are hoisted to the top of their scope, meaning you can call them before they are declared in the code. Class declarations, however, are *not* hoisted. You must define a class before you can instantiate it or reference it; otherwise, you will encounter a `ReferenceError` (often referred to as a 'temporal dead zone' for classes).",
        "topic": "ES6 Class Syntax",
        "question": "What is the key difference in 'hoisting' behavior between ES6 class declarations and traditional function declarations?",
        "type": "flashcard",
        "tags": [
          "JavaScript",
          "ES6",
          "Classes",
          "Hoisting",
          "Temporal Dead Zone"
        ],
        "example": "\n```javascript\n// Function Hoisting (Works)\nhelloFunction(); // \"Hello from function!\"\nfunction helloFunction() { console.log(\"Hello from function!\"); }\n\n// Class Hoisting (Does NOT Work)\n// new MyClass(); // ReferenceError: Cannot access 'MyClass' before initialization\nclass MyClass { constructor() { console.log(\"Hello from class!\"); } }\nnew MyClass(); // Works here\n```",
        "id": "question_es6_class_4",
        "interviewFrequency": 7,
        "prerequisites": [
          "javascript_scope",
          "hoisting"
        ],
        "level": "hard"
      },
      {
        "id": "question_functional_inheritance_1",
        "example": "\n```javascript\nfunction createPerson(name) {\n  let age = 0; // Private\n\n  return {\n    getName: () => name,\n    getAge: () => age,\n    celebrateBirthday: () => { age++; }\n  };\n}\n\nconst person = createPerson('Alice');\nperson.celebrateBirthday();\nconsole.log(person.getAge()); // 1\n// console.log(person.age); // undefined - 'age' is private\n```",
        "answer": "By declaring it using `let` inside the `CoffeeMachine` function, making it accessible only by methods defined within the same function's scope (via closure).",
        "complexity": 6,
        "analysisPoints": [
          "Tests understanding of closures for privacy.",
          "Distinguishes between public properties (on `this`) and private variables.",
          "Correctly identifies `let`/`const`/`var` scope within functions as the mechanism."
        ],
        "interviewFrequency": 7,
        "learningPath": "intermediate",
        "tags": [
          "JavaScript",
          "Closures",
          "Encapsulation",
          "Functional Programming"
        ],
        "topic": "Functional Inheritance & Closures",
        "keyConcepts": [
          "Functional Inheritance",
          "Closures",
          "Encapsulation",
          "Private Variables",
          "Lexical Scope"
        ],
        "level": "medium",
        "options": [
          "By attaching it to the `this` keyword.",
          "By declaring it using `let` inside the `CoffeeMachine` function, making it accessible only by methods defined within the same function's scope (via closure).",
          "By setting its value to `null` after each use.",
          "By using the `private` keyword (which is not standard JavaScript for object properties)."
        ],
        "prerequisites": [
          "javascript_scope",
          "this_keyword"
        ],
        "type": "mcq",
        "evaluationCriteria": [
          "Correct identification of closure mechanism.",
          "Understanding of variable scoping.",
          "Avoidance of common misconceptions about JavaScript privacy."
        ],
        "question": "In the `CoffeeMachine` example using functional inheritance, how is the `waterAmount` variable made 'private'?"
      },
      {
        "answer": "**Advantages of Functional Inheritance with Closures:**\n1.  **True Privacy**: Variables declared inside the function using `let` or `const` (or `var`) are truly private. There's no way to access them from outside the returned object, unlike convention-based 'private' properties (e.g., prefixing with `_`) or even ES6 private class fields which have a different access mechanism. This offers strong encapsulation.\n2.  **Flexible Composition**: Functional inheritance allows for easy 'mixin' patterns where behaviors can be composed by calling multiple functions (e.g., `Machine.call(this)` and then adding more methods) without complex prototype chain manipulation.\n3.  **No `this` binding issues**: Inner functions (methods) automatically close over the lexical environment, so `this` binding issues common in prototypal or class-based methods are less prevalent *if* the internal methods don't rely on `this` being the instance.\n\n**Disadvantages of Functional Inheritance with Closures:**\n1.  **Memory Inefficiency**: Each instance created using this pattern gets its own *copy* of all methods. In prototypal or class-based inheritance, methods are stored once on the `prototype` and shared among all instances. For applications with many instances, this can lead to higher memory consumption.\n2.  **`instanceof` Operator**: The `instanceof` operator relies on the prototype chain. Since functional inheritance doesn't typically involve setting up a shared `prototype` object (methods are directly assigned to the instance), `instanceof` will not work for type checking (e.g., `coffeeMachine instanceof Machine` would be `false` unless `Machine` itself also manipulates prototypes in a specific way).\n3.  **Debugging**: It can sometimes be harder to inspect the internal state in a debugger if variables are deeply nested within closures.\n4.  **No `super` equivalent**: There's no direct equivalent to `super` for calling 'parent' methods if you override them, making method overriding less straightforward than in class-based systems.",
        "keyConcepts": [
          "Functional Inheritance",
          "Closures",
          "Encapsulation",
          "Memory Management",
          "instanceof operator",
          "ES6 Classes",
          "Prototypal Inheritance"
        ],
        "id": "question_functional_inheritance_2",
        "tags": [
          "JavaScript",
          "Functional Programming",
          "Inheritance",
          "Encapsulation",
          "Performance",
          "Interview Question"
        ],
        "type": "open",
        "analysisPoints": [
          "Comprehensive understanding of functional inheritance characteristics.",
          "Ability to articulate clear pros and cons.",
          "Specific focus on memory implications (method duplication per instance).",
          "Correct explanation of `instanceof` behavior with functional inheritance."
        ],
        "level": "hard",
        "question": "Discuss the advantages and disadvantages of using functional inheritance with closures for managing object state and behavior compared to ES6 classes or prototypal inheritance. Focus on memory efficiency and `instanceof` behavior.",
        "topic": "Functional Inheritance & Closures",
        "evaluationCriteria": [
          "Depth and accuracy of the comparison.",
          "Clear explanation of memory trade-offs.",
          "Correct assessment of `instanceof` functionality.",
          "Structured and comprehensive answer."
        ],
        "interviewFrequency": 7,
        "prerequisites": [
          "functional_inheritance_and_closures",
          "es6_class_syntax",
          "prototypal_inheritance"
        ],
        "learningPath": "expert",
        "example": "",
        "complexity": 9
      },
      {
        "type": "flashcard",
        "id": "question_functional_inheritance_3",
        "learningPath": "intermediate",
        "question": "What is a closure in JavaScript, and how does it enable 'private' variables?",
        "complexity": 6,
        "answer": "A **closure** is the combination of a function and the lexical environment within which that function was declared. This environment consists of any local variables that were in-scope at the time the closure was created.\n\nIt enables 'private' variables because variables declared inside an outer function are not accessible from outside that function. However, if an inner function (the closure) is returned or exposed, it retains a reference to its outer lexical environment, including those 'private' variables. This allows the inner function to access and manipulate those variables, while direct external access is prevented, thus creating a form of privacy.",
        "prerequisites": [
          "javascript_scope",
          "javascript_functions"
        ],
        "evaluationCriteria": [
          "Conciseness and accuracy of definition.",
          "Correctly links closure mechanism to privacy."
        ],
        "level": "easy",
        "analysisPoints": [
          "Clear definition of closure.",
          "Accurate explanation of how closure maintains access to outer scope.",
          "Connection between closure and data privacy."
        ],
        "example": "",
        "interviewFrequency": 9,
        "tags": [
          "JavaScript",
          "Closures",
          "Scope",
          "Encapsulation"
        ],
        "keyConcepts": [
          "Closures",
          "Lexical Environment",
          "Scope",
          "Private Variables",
          "Encapsulation"
        ],
        "topic": "Closures for Encapsulation"
      },
      {
        "example": "",
        "evaluationCriteria": [
          "Comprehensive definition and justification.",
          "Accuracy and breadth of JavaScript-specific encapsulation methods.",
          "Structured and logical flow of explanation."
        ],
        "level": "medium",
        "keyConcepts": [
          "Encapsulation",
          "OOP Principles",
          "Data Hiding",
          "Closures",
          "Module Pattern",
          "ES6 Modules",
          "Private Class Fields"
        ],
        "complexity": 8,
        "interviewFrequency": 9,
        "answer": "In OOP, **encapsulation** is the bundling of data (attributes) and the methods (functions) that operate on that data into a single unit (an object), and restricting direct access to some of an object's components. It's often referred to as 'information hiding'.\n\n**Why it's desirable:**\n1.  **Data Integrity**: It prevents external code from directly manipulating an object's internal state in an uncontrolled way, thus maintaining data consistency and validity.\n2.  **Reduced Complexity**: By hiding internal details, it simplifies the object's public interface, making it easier for other parts of the system to interact with it.\n3.  **Maintainability and Flexibility**: Changes to the internal implementation of an object do not affect the external code that uses its public interface, as long as the interface remains consistent. This makes the code easier to maintain and modify without breaking existing functionality.\n4.  **Modularity**: Encapsulation promotes modular design, where components are self-contained and have well-defined responsibilities.\n\n**How JavaScript achieves it:**\nJavaScript does not have built-in `public`, `private`, `protected` keywords like some other OOP languages (though private class fields are a recent addition). Instead, it achieves encapsulation primarily through:\n1.  **Closures (Functional Pattern/Module Pattern)**: Variables declared within a function's scope are private to that function. If an object/module returns public methods that close over these variables, they remain private while being accessible to the public methods.\n2.  **ES6 Modules**: Anything not explicitly `export`ed from an ES6 module file is private to that module.\n3.  **Private Class Fields (`#` prefix)**: Introduced in ES2019, these allow true private instance properties and methods within ES6 classes that are only accessible from inside the class definition.\n4.  **Convention**: Developers often use conventions like prefixing internal properties/methods with an underscore (`_`) to indicate they are intended for internal use, though this doesn't enforce privacy.",
        "topic": "Encapsulation in JavaScript",
        "analysisPoints": [
          "Clear definition of encapsulation.",
          "Thorough explanation of its benefits.",
          "Detailed exposition of JavaScript's various encapsulation techniques.",
          "Differentiation between native 'private' and convention-based privacy."
        ],
        "learningPath": "advanced",
        "prerequisites": [
          "javascript_objects",
          "javascript_functions",
          "es6_classes"
        ],
        "question": "Define encapsulation in the context of Object-Oriented Programming (OOP) and explain why it's a desirable principle. How does JavaScript achieve it?",
        "id": "question_encapsulation_1",
        "tags": [
          "JavaScript",
          "Encapsulation",
          "OOP",
          "Design Principles",
          "Closures",
          "ES6"
        ],
        "type": "open"
      },
      {
        "interviewFrequency": 8,
        "example": "\n```typescript\nclass MyPrivateClass {\n  #secret = 'my_secret';\n\n  getSecret() {\n    return this.#secret;\n  }\n}\n\nconst obj = new MyPrivateClass();\nconsole.log(obj.getSecret()); // 'my_secret'\n// console.log(obj.#secret); // SyntaxError\n```",
        "evaluationCriteria": [
          "Correct identification of the most robust method.",
          "Understanding of the limitations of other options."
        ],
        "topic": "Encapsulation in JavaScript",
        "complexity": 7,
        "question": "Which of the following JavaScript features provides the strongest and most robust form of instance-level data privacy/encapsulation?",
        "level": "medium",
        "keyConcepts": [
          "Encapsulation",
          "Private Class Fields",
          "Closures",
          "WeakMap",
          "Convention"
        ],
        "answer": "Private Class Fields (`#` prefix)",
        "id": "question_encapsulation_2",
        "learningPath": "advanced",
        "options": [
          "Variables declared with `var` inside a constructor function.",
          "Prefixing properties with an underscore (e.g., `_propertyName`).",
          "Private Class Fields (`#` prefix)",
          "WeakMaps used for storing private data."
        ],
        "tags": [
          "JavaScript",
          "Encapsulation",
          "ES2019",
          "Private Class Fields"
        ],
        "analysisPoints": [
          "Tests knowledge of various encapsulation techniques' effectiveness.",
          "Distinguishes between conventions and language-enforced privacy.",
          "Highlights the strength of private class fields vs. other methods."
        ],
        "type": "mcq",
        "prerequisites": [
          "encapsulation_javascript"
        ]
      },
      {
        "keyConcepts": [
          "Encapsulation",
          "IIFE",
          "Module Pattern",
          "Closures",
          "Private Variables"
        ],
        "learningPath": "intermediate",
        "example": "",
        "id": "question_encapsulation_3",
        "prerequisites": [
          "encapsulation_javascript"
        ],
        "complexity": 7,
        "level": "hard",
        "interviewFrequency": 7,
        "tags": [
          "JavaScript",
          "Encapsulation",
          "Module Pattern",
          "IIFE",
          "Closures",
          "Code Challenge"
        ],
        "question": "Implement a simple `Logger` module using the IIFE (Immediately Invoked Function Expression) / Module Pattern. The module should have a private `logCount` variable that tracks the number of messages logged and a public `log(message)` method. The `log` method should increment `logCount` and print the message along with the current count. Also, provide a public `getLogCount()` method.",
        "analysisPoints": [
          "Correct implementation of the IIFE/Module Pattern.",
          "Effective use of closures for private state (`logCount`).",
          "Clear distinction between public and private methods/variables.",
          "Demonstrated understanding of encapsulation principles."
        ],
        "evaluationCriteria": [
          "Syntactic correctness of IIFE.",
          "Proper encapsulation of `logCount`.",
          "Functional correctness of `log` and `getLogCount` methods.",
          "Adherence to the module pattern structure."
        ],
        "answer": "```javascript\nconst Logger = (function() {\n  let logCount = 0; // Private variable\n\n  function privateLog(message) {\n    logCount++;\n    console.log(`[Log #${logCount}]: ${message}`);\n  }\n\n  return {\n    // Public interface\n    log: function(message) {\n      privateLog(message);\n    },\n    getLogCount: function() {\n      return logCount;\n    }\n  };\n})();\n\n// Test cases\nLogger.log(\"Application started.\");   // [Log #1]: Application started.\nLogger.log(\"User logged in.\");     // [Log #2]: User logged in.\nconsole.log(Logger.getLogCount()); // Expected: 2\n\n// Attempt to access private variable (will fail)\n// console.log(Logger.logCount); // undefined\n```",
        "topic": "Encapsulation in JavaScript",
        "type": "code"
      },
      {
        "tags": [
          "JavaScript",
          "Encapsulation",
          "Closures",
          "Private Class Fields",
          "ES6"
        ],
        "topic": "Encapsulation in JavaScript",
        "example": "",
        "learningPath": "advanced",
        "keyConcepts": [
          "Encapsulation",
          "Closures",
          "Private Class Fields",
          "Lexical Scope",
          "ES6 Classes",
          "Prototypal Inheritance"
        ],
        "evaluationCriteria": [
          "Clear and concise comparison.",
          "Accurate description of how each achieves privacy.",
          "Mention of 'copied methods' vs. 'prototype methods' for closures vs. classes."
        ],
        "question": "What is the primary difference between using closures for privacy in a constructor function (like the functional inheritance example) and using ES6 Private Class Fields (`#`) for privacy?",
        "level": "medium",
        "id": "question_encapsulation_4",
        "complexity": 7,
        "prerequisites": [
          "encapsulation_javascript",
          "es6_class_syntax",
          "functional_inheritance_and_closures"
        ],
        "analysisPoints": [
          "Distinguishes between lexical scope-based privacy and language-level syntax privacy.",
          "Explains the impact on method instantiation (copied vs. prototype).",
          "Highlights the explicit nature of private class fields."
        ],
        "interviewFrequency": 8,
        "answer": "The primary difference lies in their nature and scope:\n\n*   **Closures (Functional/Constructor Pattern)**: Privacy is achieved through lexical scope. Variables declared within the constructor function's scope (e.g., `let myPrivateVar`) are private. Each instance gets its *own copy* of the methods (because they are defined inside the constructor), which close over their respective private variables. This is a purely JavaScript-native behavior based on its function-scoping rules.\n\n*   **ES6 Private Class Fields (`#`)**: Privacy is a *native syntax* feature for ES6 classes. Fields declared with `#` (e.g., `#myPrivateField`) are truly private to the class instance and can *only* be accessed from within the class's own methods. These private fields are part of the class's definition, and methods can be defined once on the prototype, accessing the private fields via `this.#field`. This offers a more direct and syntactically explicit way to declare private members, similar to classical OOP languages.",
        "type": "flashcard"
      },
      {
        "complexity": 9,
        "analysisPoints": [
          "Correct application of the Module Pattern.",
          "Demonstrated understanding of how closures achieve privacy.",
          "Logical reasoning for choosing the specific encapsulation technique.",
          "Implementation of core requirements: unique IDs, non-tamperable state.",
          "Consideration of single vs. multiple instances for choosing pattern."
        ],
        "type": "open",
        "id": "question_encapsulation_5",
        "evaluationCriteria": [
          "Effectiveness of encapsulation.",
          "Clarity of code and comments.",
          "Accuracy of justification for chosen technique.",
          "Correct handling of unique ID generation logic.",
          "Adherence to functional requirements."
        ],
        "level": "hard",
        "tags": [
          "JavaScript",
          "Encapsulation",
          "Module Pattern",
          "Design Patterns",
          "Closures",
          "Data Structures",
          "Singleton"
        ],
        "topic": "Encapsulation in JavaScript",
        "example": "",
        "question": "You need to manage a collection of unique IDs in a JavaScript application. Design a simple `IDGenerator` object that ensures IDs are unique and cannot be tampered with directly from outside. Explain your choice of encapsulation technique.",
        "answer": "For this `IDGenerator`, using the **Module Pattern (via IIFE and closures)** is an excellent choice to ensure IDs are unique and the internal state (`lastId`, `generatedIds`) cannot be tampered with directly. This pattern is suitable because we likely want a *single instance* of the ID generator throughout the application (a singleton-like behavior), rather than multiple instances each with their own ID state. If we needed multiple independent ID generators, then ES6 classes with private fields would be more appropriate.\n\n```javascript\nconst IDGenerator = (function() {\n  let lastId = 0; // Private: Tracks the last generated ID\n  const generatedIds = new Set(); // Private: Stores all generated IDs to ensure uniqueness\n\n  function generateUniqueId() {\n    let newId;\n    do {\n      lastId++;\n      newId = `id_${lastId}`;\n    } while (generatedIds.has(newId));\n    generatedIds.add(newId);\n    return newId;\n  }\n\n  function resetGenerator() {\n    lastId = 0;\n    generatedIds.clear();\n    console.log(\"IDGenerator reset.\");\n  }\n\n  return {\n    // Public interface\n    next: function() {\n      return generateUniqueId();\n    },\n    count: function() {\n      return generatedIds.size;\n    },\n    reset: function() {\n      resetGenerator();\n    }\n  };\n})();\n\n// --- Usage --- \nconsole.log(IDGenerator.next()); // id_1\nconsole.log(IDGenerator.next()); // id_2\nconsole.log(IDGenerator.count()); // 2\n\nconst id3 = IDGenerator.next();\nconsole.log(id3); // id_3\n\n// Simulate an external attempt to tamper (will fail)\n// console.log(IDGenerator.lastId); // undefined\n// IDGenerator.generatedIds.clear(); // Error: generatedIds is undefined\n\nIDGenerator.reset();\nconsole.log(IDGenerator.count()); // 0\nconsole.log(IDGenerator.next()); // id_1 (resets)\n```\n\n**Choice of Encapsulation Technique Justification:**\n\n*   **Module Pattern (IIFE + Closures)**: This pattern creates a single, self-contained unit. The `lastId` and `generatedIds` variables are declared within the IIFE's scope, making them inaccessible from outside. The public methods (`next`, `count`, `reset`) returned by the IIFE are closures that have access to these private variables, allowing them to operate on the internal state without exposing it directly. This guarantees that `lastId` can only be incremented via `next()` and `generatedIds` can only be modified by the module's own logic, ensuring uniqueness and preventing external corruption. It's ideal for a utility that should only have one instance globally.",
        "learningPath": "expert",
        "prerequisites": [
          "encapsulation_javascript",
          "functional_inheritance_and_closures"
        ],
        "keyConcepts": [
          "Encapsulation",
          "Module Pattern",
          "IIFE",
          "Closures",
          "Singleton Pattern",
          "Data Integrity",
          "Set (Data Structure)"
        ],
        "interviewFrequency": 7
      }
    ],
    "tasks": [
      {
        "learningPath": "intermediate",
        "solutionCode": "function Shape(name) {\n  this.name = name;\n}\n\nShape.prototype.getArea = function() {\n  return 0;\n};\n\nfunction Circle(radius) {\n  Shape.call(this, 'Circle'); // Call parent constructor to set name\n  this.radius = radius;\n}\n\n// Set up prototypal inheritance for Circle\nCircle.prototype = Object.create(Shape.prototype);\n// Fix the constructor reference\nCircle.prototype.constructor = Circle;\n\n// Override getArea for Circle\nCircle.prototype.getArea = function() {\n  return Math.PI * this.radius * this.radius;\n};\n\n// Test cases\nconst genericShape = new Shape('Generic');\nconsole.log(`${genericShape.name} Area: ${genericShape.getArea()}`);\n\nconst myCircle = new Circle(5);\nconsole.log(`${myCircle.name} Area: ${myCircle.getArea()}`);\nconsole.log(myCircle instanceof Circle);\nconsole.log(myCircle instanceof Shape);\nconsole.log(myCircle.constructor === Circle);\n\nconst invalidCircle = new Circle(-1);\nconsole.log(`${invalidCircle.name} Area (negative radius): ${invalidCircle.getArea()}`); // Should still calculate, but result might be unexpected (Pi * 1)\n",
        "timeEstimate": 45,
        "prerequisites": [
          "prototypal_inheritance"
        ],
        "hints": [
          "Remember to use `Person.call(this, ...)` in the child constructor to correctly initialize parent properties.",
          "`Object.create()` is key to setting up the prototype chain.",
          "Don't forget to correct the `constructor` property after setting the prototype."
        ],
        "testCases": [
          "Create a `Shape` instance and call `getArea()`: `new Shape('Triangle').getArea()` should return `0`.",
          "Create a `Circle` instance with `radius = 0` and check its area: `new Circle(0).getArea()` should return `0`.",
          "Create a `Circle` instance with `radius = 1` and check its area: `new Circle(1).getArea()` should return `Math.PI`.",
          "Create a `Circle` instance with `radius = 10` and check its area: `new Circle(10).getArea()` should return `Math.PI * 100`.",
          "Verify `instanceof` for `Circle` instance: `myCircle instanceof Circle` should be `true` and `myCircle instanceof Shape` should be `true`.",
          "Verify `constructor` property for `Circle` instance: `myCircle.constructor === Circle` should be `true`."
        ],
        "startingCode": "function Shape(name) {\n  this.name = name;\n}\n\nShape.prototype.getArea = function() {\n  // TODO: Implement generic getArea\n  return 0;\n};\n\nfunction Circle(radius) {\n  // TODO: Inherit from Shape and set radius\n  // Shape.call(this, ...);\n  this.radius = radius;\n}\n\n// TODO: Set up prototypal inheritance for Circle\n// Circle.prototype = Object.create(...);\n// Circle.prototype.constructor = ...;\n\n// TODO: Override getArea for Circle\nCircle.prototype.getArea = function() {\n  // return area of circle\n};\n\n// Test cases (uncomment and run)\n// const genericShape = new Shape('Generic');\n// console.log(`${genericShape.name} Area: ${genericShape.getArea()}`); // Expected: 0\n\n// const myCircle = new Circle(5);\n// console.log(`${myCircle.name} Area: ${myCircle.getArea()}`); // Expected: ~78.53\n// console.log(myCircle instanceof Circle); // Expected: true\n// console.log(myCircle instanceof Shape);  // Expected: true\n// console.log(myCircle.constructor === Circle); // Expected: true\n",
        "description": "\nImplement a basic inheritance hierarchy for geometric shapes using JavaScript's prototypal inheritance (pre-ES6 class syntax). \n\n1.  Create a `Shape` constructor function with properties `name` (e.g., 'Circle', 'Rectangle') and a method `getArea()` which should return `0` (as a generic shape has no specific area).\n2.  Create a `Circle` constructor function that inherits from `Shape`. It should have an additional property `radius`.\n3.  Override the `getArea()` method in `Circle.prototype` to calculate the area of a circle (`Math.PI * radius * radius`).\n4.  Ensure that `Circle.prototype.constructor` points back to `Circle`.\n5.  Demonstrate usage by creating instances of `Shape` and `Circle` and calling `getArea()`.\n",
        "id": "task_prototypal_inheritance_1",
        "title": "Build a Simple Shape Hierarchy with Prototypal Inheritance",
        "tags": [
          "JavaScript",
          "Prototypal Inheritance",
          "OOP",
          "Object.create",
          "Constructor Function",
          "Task"
        ],
        "interviewRelevance": 8,
        "relatedConcepts": [
          "prototype_chain",
          "this_keyword",
          "method_overriding"
        ],
        "difficulty": "medium",
        "complexity": 7
      },
      {
        "id": "task_es6_class_inheritance_1",
        "complexity": 6,
        "learningPath": "intermediate",
        "solutionCode": "class Shape {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  getArea() {\n    return 0;\n  }\n}\n\nclass Circle extends Shape {\n  constructor(radius) {\n    super('Circle'); // Call parent constructor to set name\n    this.radius = radius;\n  }\n  \n  getArea() {\n    return Math.PI * this.radius * this.radius;\n  }\n}\n\n// Test cases\nconst genericShape = new Shape('Generic');\nconsole.log(`${genericShape.name} Area: ${genericShape.getArea()}`);\n\nconst myCircle = new Circle(5);\nconsole.log(`${myCircle.name} Area: ${myCircle.getArea()}`);\nconsole.log(myCircle instanceof Circle);\nconsole.log(myCircle instanceof Shape);\nconsole.log(myCircle.constructor === Circle);\n\nconst anotherCircle = new Circle(0);\nconsole.log(`${anotherCircle.name} Area (radius 0): ${anotherCircle.getArea()}`);\n",
        "description": "\nRefactor the previous `Shape` and `Circle` inheritance hierarchy using modern ES6 class syntax.\n\n1.  Create a `Shape` class with a `constructor` taking `name` and a `getArea()` method returning `0`.\n2.  Create a `Circle` class that `extends` `Shape`. It should have a `radius` property.\n3.  In `Circle`'s `constructor`, ensure `super()` is correctly called.\n4.  Override the `getArea()` method in `Circle` to calculate the area of a circle.\n5.  Demonstrate usage by creating instances and calling methods.\n",
        "startingCode": "class Shape {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  getArea() {\n    // TODO: Implement generic getArea\n    return 0;\n  }\n}\n\nclass Circle extends Shape {\n  constructor(radius) {\n    // TODO: Call super and set radius\n  }\n  \n  getArea() {\n    // TODO: Implement circle area calculation\n  }\n}\n\n// Test cases (uncomment and run)\n// const genericShape = new Shape('Generic');\n// console.log(`${genericShape.name} Area: ${genericShape.getArea()}`); // Expected: 0\n\n// const myCircle = new Circle(5);\n// console.log(`${myCircle.name} Area: ${myCircle.getArea()}`); // Expected: ~78.53\n// console.log(myCircle instanceof Circle); // Expected: true\n// console.log(myCircle instanceof Shape);  // Expected: true\n// console.log(myCircle.constructor === Circle); // Expected: true\n",
        "testCases": [
          "Create a `Shape` instance and call `getArea()`: `new Shape('Square').getArea()` should return `0`.",
          "Create a `Circle` instance with `radius = 0` and check its area: `new Circle(0).getArea()` should return `0`.",
          "Create a `Circle` instance with `radius = 1` and check its area: `new Circle(1).getArea()` should return `Math.PI`.",
          "Create a `Circle` instance with `radius = 7` and check its area: `new Circle(7).getArea()` should return `Math.PI * 49`.",
          "Verify `instanceof` for `Circle` instance: `myCircle instanceof Circle` should be `true` and `myCircle instanceof Shape` should be `true`.",
          "Verify `constructor` property for `Circle` instance: `myCircle.constructor === Circle` should be `true`."
        ],
        "timeEstimate": 30,
        "interviewRelevance": 9,
        "tags": [
          "JavaScript",
          "ES6 Classes",
          "Inheritance",
          "OOP",
          "super",
          "Task"
        ],
        "prerequisites": [
          "es6_class_syntax"
        ],
        "hints": [
          "Remember that `extends` handles much of the prototype chain setup automatically.",
          "The `super()` keyword is essential in the child class constructor to properly initialize the parent class."
        ],
        "title": "Refactor Shape Hierarchy to ES6 Classes",
        "relatedConcepts": [
          "syntactic_sugar",
          "method_overriding"
        ],
        "difficulty": "medium"
      },
      {
        "prerequisites": [
          "functional_inheritance_and_closures",
          "this_keyword",
          "call_apply_bind"
        ],
        "startingCode": "function Battery() {\n  let charge = 100; // Private\n\n  this.getCharge = function() {\n    return charge;\n  };\n\n  this.drain = function(amount) {\n    charge = Math.max(0, charge - amount);\n  };\n}\n\nfunction Smartphone(model) {\n  // TODO: Inherit from Battery\n  // Battery.call(this);\n  this.model = model;\n\n  let isOn = false; // Private\n\n  this.powerOn = function() {\n    // TODO: Set isOn to true, check charge\n  };\n\n  this.powerOff = function() {\n    // TODO: Set isOn to false\n  };\n\n  this.use = function(minutes) {\n    // TODO: Implement usage logic\n  };\n}\n\n// Test cases (uncomment and run)\n// const myPhone = new Smartphone('iPhone 15');\n// console.log(`${myPhone.model} charge: ${myPhone.getCharge()}`); // Expected: 100\n// myPhone.use(10); // Should say 'Phone is off'\n// myPhone.powerOn();\n// myPhone.use(20); // Drains 10 charge\n// console.log(`${myPhone.model} charge: ${myPhone.getCharge()}`); // Expected: 90\n// myPhone.use(200); // Drains 100 charge (should become 0)\n// console.log(`${myPhone.model} charge: ${myPhone.getCharge()}`); // Expected: 0\n// myPhone.use(10); // Should say 'Not enough charge' or similar\n// console.log(myPhone.isOn); // Should be undefined\n",
        "hints": [
          "Remember `Battery.call(this)` to 'inherit' methods onto the `Smartphone` instance.",
          "The `charge` and `isOn` variables should be `let` or `const` declarations within their respective functions to become private via closures.",
          "Ensure `use()` checks both `isOn` status and `charge` level."
        ],
        "solutionCode": "function Battery() {\n  let charge = 100; // Private via closure\n\n  this.getCharge = function() {\n    return charge;\n  };\n\n  this.drain = function(amount) {\n    charge = Math.max(0, charge - amount);\n    console.log(`Battery drained by ${amount}. Remaining charge: ${charge}`);\n  };\n}\n\nfunction Smartphone(model) {\n  Battery.call(this); // Inherit Battery's public methods and its closure-managed 'charge'\n  this.model = model;\n\n  let isOn = false; // Private to Smartphone\n\n  this.powerOn = function() {\n    if (this.getCharge() > 0) {\n      isOn = true;\n      console.log(`${this.model} powered on.`);\n    } else {\n      console.log(`${this.model} cannot power on, battery is empty.`);\n    }\n  };\n\n  this.powerOff = function() {\n    isOn = false;\n    console.log(`${this.model} powered off.`);\n  };\n\n  this.use = function(minutes) {\n    if (!isOn) {\n      console.log(`${this.model} is off. Please power on first.`);\n      return;\n    }\n    const drainAmount = minutes * 0.5;\n    if (this.getCharge() >= drainAmount) {\n      this.drain(drainAmount); // Use the inherited drain method\n      console.log(`${this.model} used for ${minutes} minutes.`);\n    } else {\n      console.log(`${this.model} not enough charge for ${minutes} minutes. Remaining: ${this.getCharge()}%`);\n      this.powerOff(); // Auto-power off if charge runs out during usage attempt\n    }\n  };\n\n  // Expose a public method to check power state (optional, for testing)\n  this.isPoweredOn = function() {\n    return isOn;\n  };\n}\n\n// Test cases\nconst myPhone = new Smartphone('iPhone 15');\nconsole.log(`Initial ${myPhone.model} charge: ${myPhone.getCharge()}%`); // Expected: 100\nmyPhone.use(10); // Expected: Phone is off\n\nmyPhone.powerOn();\nmyPhone.use(20); // Drains 10 charge\nconsole.log(`${myPhone.model} charge after 20min use: ${myPhone.getCharge()}%`); // Expected: 90\n\nmyPhone.use(180); // Drains 90 charge\nconsole.log(`${myPhone.model} charge after 180min use: ${myPhone.getCharge()}%`); // Expected: 0\nmyPhone.use(10); // Expected: Not enough charge & auto-power off\nconsole.log(`${myPhone.model} is on: ${myPhone.isPoweredOn()}`); // Expected: false\n\nconst deadPhone = new Smartphone('Old Nokia');\ndeadPhone.drain(100);\ndeadPhone.powerOn(); // Expected: Cannot power on\n",
        "complexity": 8,
        "learningPath": "advanced",
        "title": "Create a Battery-Powered Device with Functional Inheritance",
        "id": "task_functional_inheritance_1",
        "timeEstimate": 60,
        "testCases": [
          "Initialize `Smartphone` and check initial charge: should be 100.",
          "Attempt to `use()` `Smartphone` when it's `off`: should print 'Phone is off' and not drain battery.",
          "Call `powerOn()`, then `use(20)`: `charge` should decrease by 10. `getCharge()` should reflect 90.",
          "Call `use()` with an amount that completely drains the battery (e.g., `use(200)` when charge is 100): `charge` should become 0.",
          "Attempt to `use()` with `charge` at 0: should print 'Not enough charge' and potentially power off.",
          "Verify internal `isOn` variable cannot be accessed directly: `myPhone.isOn` should be `undefined`."
        ],
        "difficulty": "hard",
        "tags": [
          "JavaScript",
          "Functional Inheritance",
          "Encapsulation",
          "Closures",
          "Design Pattern",
          "Task",
          "Advanced"
        ],
        "description": "\nImplement a `Battery` function and a `Smartphone` function using functional inheritance and closures to manage internal state.\n\n1.  Create a `Battery` function that defines a private variable `charge` (default to 100). It should expose public methods `getCharge()` and `drain(amount)` (which reduces `charge`).\n2.  Create a `Smartphone` function that 'inherits' from `Battery`. It should also have a private variable `isOn` (default to `false`).\n3.  `Smartphone` should expose `powerOn()` and `powerOff()` methods, and a `use(minutes)` method.\n4.  The `use(minutes)` method should only work if `isOn` is `true` and `charge` is sufficient. It should drain the battery by `minutes * 0.5`.\n5.  Demonstrate usage by creating a `Smartphone` instance, powering it on, using it, and checking charge.\n",
        "relatedConcepts": [
          "private_variables",
          "composition"
        ],
        "interviewRelevance": 7
      },
      {
        "solutionCode": "class UserProfile {\n  #username;\n  #password;\n  #loggedInStatus = false;\n\n  constructor(username, password) {\n    this.#username = username;\n    this.#password = password;\n  }\n\n  login(username, password) {\n    if (username === this.#username && password === this.#password) {\n      this.#loggedInStatus = true;\n      console.log('Login successful.');\n      return true;\n    } else {\n      console.log('Login failed: Invalid credentials.');\n      return false;\n    }\n  }\n\n  logout() {\n    if (this.#loggedInStatus) {\n      this.#loggedInStatus = false;\n      console.log('Logout successful.');\n    } else {\n      console.log('Already logged out.');\n    }\n  }\n\n  getUsername() {\n    if (this.#loggedInStatus) {\n      return this.#username;\n    } else {\n      console.log('Access denied: Not logged in.');\n      return null;\n    }\n  }\n\n  isLoggedIn() {\n    return this.#loggedInStatus;\n  }\n}\n\n// Test cases\nconst user = new UserProfile('testuser', 'password123');\nconsole.log(`Initial login status: ${user.isLoggedIn()}`); // Expected: false\nconsole.log(user.getUsername()); // Expected: Access denied: Not logged in. null\n\nuser.login('testuser', 'wrongpass'); // Expected: Login failed\nconsole.log(`Login status after wrong attempt: ${user.isLoggedIn()}`); // Expected: false\n\nuser.login('testuser', 'password123'); // Expected: Login successful\nconsole.log(`Login status after successful login: ${user.isLoggedIn()}`); // Expected: true\nconsole.log(`Username: ${user.getUsername()}`); // Expected: 'testuser'\n\nuser.logout(); // Expected: Logout successful\nconsole.log(`Login status after logout: ${user.isLoggedIn()}`); // Expected: false\n\nuser.logout(); // Expected: Already logged out.\n\n// Attempt to access private fields directly (will cause SyntaxError if uncommented/run in compatible env)\n// try {\n//   console.log(user.#password);\n// } catch (e) {\n//   console.error(e.message);\n// }\n",
        "description": "\nDesign an ES6 `UserProfile` class that uses private class fields to store sensitive user data, ensuring it's not directly accessible from outside the class.\n\n1.  Create a `UserProfile` class with a `constructor` that takes `username` and `password`.\n2.  Use private class fields (`#`) for `#username`, `#password`, and a calculated `#loggedInStatus` (initially `false`).\n3.  Implement a public `login(username, password)` method that sets `#loggedInStatus` to `true` if credentials match.\n4.  Implement a public `logout()` method that sets `#loggedInStatus` to `false`.\n5.  Implement a public `getUsername()` method to safely retrieve the username (since it's a display name, it can be exposed). This method should only work if `loggedInStatus` is `true`.\n6.  Attempt to access private fields directly outside the class to demonstrate their privacy.\n",
        "tags": [
          "JavaScript",
          "Encapsulation",
          "ES6 Classes",
          "Private Class Fields",
          "OOP",
          "Security",
          "Task"
        ],
        "id": "task_encapsulation_1",
        "relatedConcepts": [
          "data_integrity",
          "information_hiding"
        ],
        "complexity": 7,
        "startingCode": "class UserProfile {\n  // TODO: Declare private fields #username, #password, #loggedInStatus\n\n  constructor(username, password) {\n    // TODO: Initialize private fields\n  }\n\n  login(username, password) {\n    // TODO: Implement login logic\n  }\n\n  logout() {\n    // TODO: Implement logout logic\n  }\n\n  getUsername() {\n    // TODO: Implement getUsername logic (only if logged in)\n  }\n\n  // Optional: A public method to check login status for convenience\n  isLoggedIn() {\n    // TODO: Return #loggedInStatus\n  }\n}\n\n// Test cases (uncomment and run)\n// const user = new UserProfile('testuser', 'password123');\n// console.log(user.getUsername()); // Expected: null or access denied if not logged in\n// console.log(user.isLoggedIn()); // Expected: false\n\n// user.login('testuser', 'wrongpass'); // Expected: Login failed\n// user.login('testuser', 'password123'); // Expected: Login successful\n// console.log(user.isLoggedIn()); // Expected: true\n// console.log(user.getUsername()); // Expected: 'testuser'\n\n// user.logout(); // Expected: Logout successful\n// console.log(user.isLoggedIn()); // Expected: false\n\n// // Demonstrate attempted private access (will cause SyntaxError if uncommented)\n// // console.log(user.#password);\n",
        "testCases": [
          "Initialize `UserProfile` and verify `isLoggedIn()` is `false` and `getUsername()` returns `null` or 'access denied'.",
          "Attempt `login()` with incorrect credentials: `isLoggedIn()` should remain `false`.",
          "Perform successful `login()`: `isLoggedIn()` should become `true`, `getUsername()` should return the correct username.",
          "Perform `logout()`: `isLoggedIn()` should become `false`.",
          "Attempt `logout()` when already logged out: should handle gracefully.",
          "Verify that attempting to access `user.#username` or `user.#password` directly results in a `SyntaxError`."
        ],
        "learningPath": "advanced",
        "interviewRelevance": 8,
        "hints": [
          "Declare private fields at the top of the class using the `#` prefix.",
          "Access private fields using `this.#fieldName` *only* inside the class methods.",
          "Make sure methods like `getUsername()` check the `#loggedInStatus` before revealing data."
        ],
        "prerequisites": [
          "encapsulation_javascript",
          "es6_class_syntax"
        ],
        "difficulty": "medium",
        "title": "Implement a Secure User Profile with Private Class Fields",
        "timeEstimate": 45
      },
      {
        "startingCode": "const ConfigManager = (function() {\n  const _settings = { // Private settings object\n    theme: 'dark',\n    language: 'en',\n    notifications: true\n  };\n\n  const SENSITIVE_KEYS = ['password', 'apiKey', 'token'];\n\n  return {\n    get: function(key) {\n      // TODO: Implement getting a setting\n    },\n\n    set: function(key, value) {\n      // TODO: Implement setting a setting, prevent sensitive keys\n    },\n\n    getAll: function() {\n      // TODO: Return a copy of _settings\n    }\n  };\n})();\n\n// Test cases (uncomment and run)\n// console.log(ConfigManager.get('theme')); // Expected: 'dark'\n// ConfigManager.set('language', 'es');\n// console.log(ConfigManager.get('language')); // Expected: 'es'\n\n// ConfigManager.set('password', 'secret'); // Expected: message preventing setting sensitive key\n// console.log(ConfigManager.get('password')); // Expected: undefined\n\n// const allSettings = ConfigManager.getAll();\n// console.log(allSettings); // Expected: { theme: 'dark', language: 'es', notifications: true }\n// allSettings.theme = 'light'; // Attempt to modify the copy\n// console.log(ConfigManager.get('theme')); // Expected: 'dark' (should not be affected)\n// // console.log(ConfigManager._settings); // Expected: undefined (private)\n",
        "learningPath": "intermediate",
        "testCases": [
          "Call `get('theme')`: Should return 'dark'.",
          "Call `set('language', 'fr')`: `get('language')` should return 'fr'.",
          "Call `set('apiKey', 'secret')`: Should warn about sensitive key and not update the setting; `get('apiKey')` should return `undefined`.",
          "Call `getAll()`: Should return an object with current settings.",
          "Modify the object returned by `getAll()` (e.g., `allSettings.theme = 'light'`): `ConfigManager.get('theme')` should *still* return 'dark', demonstrating that the internal `_settings` was not directly modified.",
          "Attempt to access `ConfigManager._settings` directly: Should result in `undefined` or an error, confirming its privacy."
        ],
        "timeEstimate": 45,
        "description": "\nImplement a `ConfigManager` JavaScript module using the IIFE (Immediately Invoked Function Expression) / Module Pattern. This manager should store and retrieve configuration settings, ensuring the settings are private and not directly mutable from outside.\n\n1.  The module should contain a private object, `_settings`, to store key-value pairs of configurations.\n2.  Implement a public `get(key)` method that returns the value associated with a given key from `_settings`.\n3.  Implement a public `set(key, value)` method that updates a setting in `_settings`. For security, prevent setting sensitive keys like `password` or `apiKey`.\n4.  Implement a public `getAll()` method that returns a *copy* of the `_settings` object to prevent direct modification of the internal state.\n5.  Demonstrate usage by setting, getting, and attempting to modify settings, including sensitive ones.\n",
        "solutionCode": "const ConfigManager = (function() {\n  const _settings = { // Private settings object via closure\n    theme: 'dark',\n    language: 'en',\n    notifications: true\n  };\n\n  const SENSITIVE_KEYS = ['password', 'apiKey', 'token'];\n\n  return {\n    get: function(key) {\n      return _settings[key];\n    },\n\n    set: function(key, value) {\n      if (SENSITIVE_KEYS.includes(key)) {\n        console.warn(`Cannot set sensitive key: ${key}`);\n        return false;\n      }\n      _settings[key] = value;\n      console.log(`Setting '${key}' updated to '${value}'.`);\n      return true;\n    },\n\n    getAll: function() {\n      // Return a shallow copy to prevent direct modification of _settings\n      return { ..._settings }; \n      // Alternatively: Object.assign({}, _settings);\n      // Or: JSON.parse(JSON.stringify(_settings)); for deep copy (if settings object has nested objects/arrays)\n    }\n  };\n})();\n\n// Test cases\nconsole.log(`Initial theme: ${ConfigManager.get('theme')}`); // Expected: 'dark'\nconsole.log(`Initial language: ${ConfigManager.get('language')}`); // Expected: 'en'\n\nConfigManager.set('language', 'es'); // Setting 'language' updated to 'es'.\nconsole.log(`Updated language: ${ConfigManager.get('language')}`); // Expected: 'es'\n\nConfigManager.set('notifications', false); // Setting 'notifications' updated to 'false'.\nconsole.log(`Updated notifications: ${ConfigManager.get('notifications')}`); // Expected: false\n\nConfigManager.set('apiKey', 'supersecret123'); // Cannot set sensitive key: apiKey\nconsole.log(`API Key (should be undefined): ${ConfigManager.get('apiKey')}`); // Expected: undefined\n\nconst allSettings = ConfigManager.getAll();\nconsole.log('All settings (copy):', allSettings); // Expected: { theme: 'dark', language: 'es', notifications: false }\n\n// Attempt to modify the returned copy, should not affect original private _settings\nallSettings.theme = 'light';\nallSettings.language = 'fr';\nconsole.log('Modified copy:', allSettings); // Expected: { theme: 'light', language: 'fr', notifications: false }\nconsole.log(`Original theme (should remain 'dark'): ${ConfigManager.get('theme')}`); // Expected: 'dark'\nconsole.log(`Original language (should remain 'es'): ${ConfigManager.get('language')}`); // Expected: 'es'\n\n// Verify private access attempt\n// console.log(ConfigManager._settings); // Should be undefined (SyntaxError if in module context, undefined in browser/node console if not exposed)\n",
        "hints": [
          "The `_settings` object should be declared within the IIFE to make it private.",
          "For `getAll()`, remember to return a *copy* of the settings object (e.g., using `Object.assign({}, _settings)` or spread syntax `{ ..._settings }`) to prevent external direct modification of the internal state.",
          "Use `Array.prototype.includes()` or `Set.prototype.has()` for checking sensitive keys."
        ],
        "difficulty": "medium",
        "title": "Create a Configuration Manager using the Module Pattern",
        "relatedConcepts": [
          "singleton",
          "data_hiding",
          "functional_programming"
        ],
        "prerequisites": [
          "encapsulation_javascript"
        ],
        "complexity": 7,
        "id": "task_encapsulation_2",
        "tags": [
          "JavaScript",
          "Encapsulation",
          "Module Pattern",
          "IIFE",
          "Closures",
          "Design Pattern",
          "Task"
        ],
        "interviewRelevance": 9
      }
    ],
    "logicalBlockInfo": {
      "suggestedEndLine": -1
    },
    "id": "chunk_900_999_1749978741726",
    "completed": false,
    "processedDate": "2025-06-15T09:12:21.717Z"
  },
  {
    "id": "chunk_1000_1000_1749978819093",
    "tasks": [
      {
        "id": "task_predict_output_event_loop",
        "testCases": [
          "Verify output for synchronous code.",
          "Verify microtask priority over macrotasks.",
          "Verify nested asynchronous calls and their queuing behavior.",
          "Verify draining of microtasks after a macrotask."
        ],
        "startingCode": "console.log('A');\n\nsetTimeout(() => {\n  console.log('B');\n  Promise.resolve().then(() => console.log('C'));\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('D');\n  setTimeout(() => console.log('E'), 0);\n});\n\nconsole.log('F');\n\n// TODO: Write down the predicted output and a step-by-step explanation.",
        "timeEstimate": 60,
        "learningPath": "advanced",
        "prerequisites": [
          "theory_event_loop_and_async_js"
        ],
        "relatedConcepts": [
          "Call Stack",
          "Microtask Queue",
          "Macrotask Queue"
        ],
        "hints": [
          "Remember that synchronous code always runs first.",
          "Microtasks (Promises) have higher priority than macrotasks (setTimeout).",
          "The Microtask Queue is drained completely after synchronous code and after *each* macrotask, before the *next* macrotask is picked.",
          "Tasks added *during* the execution of a microtask or macrotask are queued according to their type."
        ],
        "complexity": 9,
        "interviewRelevance": 10,
        "solutionCode": "/*\nPredicted Output:\nA\nF\nD\nB\nC\nE\n\nStep-by-step Explanation:\n\n1.  **console.log('A')**: This is synchronous code. 'A' is immediately printed to the console. The Call Stack contains `console.log('A')`, which then pops.\n\n2.  **setTimeout(() => { console.log('B'); ... }, 0)**: This `setTimeout` call is a macrotask. Its callback is sent to the Web APIs and, upon timer expiry (0ms), is moved to the **Macrotask Queue**.\n\n3.  **Promise.resolve().then(() => { console.log('D'); ... })**: This Promise's `.then()` callback is a microtask. It is immediately scheduled and moved to the **Microtask Queue**.\n\n4.  **console.log('F')**: This is synchronous code. 'F' is immediately printed to the console. The Call Stack contains `console.log('F')`, which then pops.\n\n5.  **Call Stack is now empty.** The Event Loop starts its cycle.\n\n6.  **Drain Microtask Queue:** The Event Loop first checks the Microtask Queue. It finds the callback from step 3.\n    *   Execute `() => { console.log('D'); setTimeout(() => console.log('E'), 0); }`.\n    *   **console.log('D')**: 'D' is printed.\n    *   **setTimeout(() => console.log('E'), 0)**: This is a new macrotask. Its callback is sent to the Web APIs and, after timer expiry, is moved to the **Macrotask Queue**. It is placed *after* the 'B' callback that was added in step 2.\n    *   The microtask from step 3 completes and pops from the Call Stack.\n\n7.  **Microtask Queue is now empty.** (There were no new microtasks added during the execution of 'D's callback).\n\n8.  **Drain Macrotask Queue (first macrotask):** The Event Loop checks the Macrotask Queue and finds the callback from step 2.\n    *   Execute `() => { console.log('B'); Promise.resolve().then(() => console.log('C')); }`.\n    *   **console.log('B')**: 'B' is printed.\n    *   **Promise.resolve().then(() => console.log('C'))**: This is a new microtask. It is immediately scheduled and moved to the **Microtask Queue**. *Crucially, the Microtask Queue is drained entirely after each macrotask is processed, before the next macrotask is picked up.*\n    *   The macrotask from step 2 completes and pops from the Call Stack.\n\n9.  **Call Stack is now empty.** The Event Loop starts a new cycle and checks the Microtask Queue again (because a new microtask was added in step 8).\n\n10. **Drain Microtask Queue (second drain):** The Event Loop finds the new microtask from step 8.\n    *   Execute `() => console.log('C')`.\n    *   **console.log('C')**: 'C' is printed.\n    *   The microtask from step 8 completes and pops from the Call Stack.\n\n11. **Microtask Queue is now empty.**\n\n12. **Drain Macrotask Queue (second macrotask):** The Event Loop checks the Macrotask Queue and finds the callback for 'E' (from step 6).\n    *   Execute `() => console.log('E')`.\n    *   **console.log('E')**: 'E' is printed.\n    *   The macrotask from step 6 completes and pops from the Call Stack.\n\n13. All queues are now empty. The program finishes.\n*/\n",
        "tags": [
          "JavaScript",
          "Event Loop",
          "Asynchronous",
          "Promises",
          "setTimeout",
          "Execution Order"
        ],
        "description": "\nGiven the following JavaScript code, predict the exact order of console logs. Your solution should explain the reasoning behind each line's execution, referencing the Call Stack, Web APIs, Microtask Queue, Macrotask Queue, and the Event Loop.\n\n```javascript\nconsole.log('A');\n\nsetTimeout(() => {\n  console.log('B');\n  Promise.resolve().then(() => console.log('C'));\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('D');\n  setTimeout(() => console.log('E'), 0);\n});\n\nconsole.log('F');\n```\n",
        "title": "Predict Execution Order with Timers and Promises",
        "difficulty": "hard"
      },
      {
        "testCases": [
          "Calling `await delay(100)` should pause execution for roughly 100ms.",
          "Calling `await delay(0)` should resolve immediately, but allow other microtasks to run first.",
          "Verify it returns a Promise.",
          "Ensure multiple `await delay()` calls in sequence work correctly.",
          "Test with larger delay values (e.g., 5000ms) to ensure stability."
        ],
        "startingCode": "/**\n * Delays execution for a specified number of milliseconds.\n * @param {number} ms - The number of milliseconds to wait.\n * @returns {Promise<void>}\n */\nfunction delay(ms) {\n  // TODO: Implement this function using setTimeout and Promises\n  \n  return new Promise((resolve) => {\n    // Your implementation here\n  });\n}\n\n// Example Usage (for testing):\nasync function testDelay() {\n  console.log('Starting delay...');\n  await delay(1000);\n  console.log('Delay finished after 1 second.');\n\n  console.log('Starting zero delay...');\n  await delay(0);\n  console.log('Zero delay finished (immediate after microtasks).');\n}\n\n// Uncomment to run the test\n// testDelay();\n",
        "solutionCode": "/**\n * Delays execution for a specified number of milliseconds.\n * @param {number} ms - The number of milliseconds to wait.\n * @returns {Promise<void>}\n */\nfunction delay(ms) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve();\n    }, ms);\n  });\n}\n\n// Example Usage (for testing):\nasync function testDelay() {\n  console.log('Starting delay...');\n  const start = Date.now();\n  await delay(1000);\n  const end = Date.now();\n  console.log(`Delay finished after ${end - start}ms (expected ~1000ms).`);\n\n  console.log('Synchronous code before zero delay...');\n  await delay(0);\n  console.log('Zero delay finished (immediate after microtasks).');\n\n  console.log('Chaining delays...');\n  await delay(200);\n  console.log('After 200ms');\n  await delay(100);\n  console.log('After 100ms more');\n}\n\n// testDelay();\n",
        "description": "\nImplement a JavaScript function `delay(ms)` that returns a Promise. This Promise should resolve after `ms` milliseconds. You should use `setTimeout` internally. The function should be able to be `await`ed.\n\nRequirements:\n1.  The function `delay(ms)` must return a `Promise`.\n2.  The `Promise` should resolve after approximately `ms` milliseconds.\n3.  The function should handle `ms` being 0 correctly (resolves immediately after microtasks).\n4.  No return value is needed from the resolved promise itself.\n\n",
        "interviewRelevance": 8,
        "learningPath": "intermediate",
        "id": "task_implement_promise_based_delay",
        "hints": [
          "A Promise constructor takes a function with `resolve` and `reject` arguments.",
          "`setTimeout` is the primitive for creating delays.",
          "The `resolve` function of the Promise needs to be called inside the `setTimeout` callback."
        ],
        "timeEstimate": 30,
        "difficulty": "medium",
        "relatedConcepts": [
          "Promise",
          "setTimeout",
          "Async/Await"
        ],
        "title": "Implement a Promise-based Delay Function",
        "complexity": 6,
        "tags": [
          "JavaScript",
          "Promises",
          "Asynchronous",
          "setTimeout",
          "Async/Await",
          "Interview Task"
        ],
        "prerequisites": [
          "promises",
          "setTimeout",
          "async_await"
        ]
      },
      {
        "testCases": [
          "Successful sequential execution for a valid user ID (e.g., 1).",
          "Error handling: ensure `try...catch` captures and logs errors from any step.",
          "Verify that `await` correctly pauses execution and resumes with the resolved value.",
          "Verify the overall time taken is roughly the sum of individual delays (500 + 300 + 200 = 1000ms), confirming sequential execution.",
          "Demonstrate that other synchronous/microtask code runs during `await` pauses."
        ],
        "startingCode": "function delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nasync function fetchUser(userId) {\n  console.log(`Fetching user ${userId}...`);\n  await delay(500);\n  const userData = `User_${userId}_Data`;\n  console.log(`Fetched: ${userData}`);\n  return userData;\n}\n\nasync function processUserData(userData) {\n  console.log(`Processing ${userData}...`);\n  await delay(300);\n  const processedData = `Processed_${userData}`;\n  console.log(`Processed: ${processedData}`);\n  return processedData;\n}\n\nasync function saveProcessedData(processedData) {\n  console.log(`Saving ${processedData}...`);\n  await delay(200);\n  // Simulate an error for testing (uncomment to test error handling)\n  // if (processedData.includes('Error')) {\n  //   throw new Error('Failed to save data!');\n  // }\n  const saveResult = `Saved_${processedData}`;\n  console.log(`Saved: ${saveResult}`);\n  return saveResult;\n}\n\nasync function processDataSequence(userId) {\n  // TODO: Implement the sequence and error handling here\n  console.log(`Starting sequence for user ${userId}`);\n  // Example: \n  // try {\n  //   const user = await fetchUser(userId);\n  //   // ... more steps\n  // } catch (error) {\n  //   console.error('Sequence failed:', error.message);\n  // }\n  console.log(`Sequence completed for user ${userId}`);\n}\n\n// Test cases (uncomment to run)\n// console.log('*** Running successful sequence ***');\n// processDataSequence(1);\n\n// console.log('\\n*** Running sequence with simulated error (e.g., for user 99) ***');\n// processDataSequence(99); // Assume fetchUser(99) might lead to an error that propagates\n",
        "learningPath": "intermediate",
        "description": "\nImplement an `async` function `processDataSequence()` that simulates a series of asynchronous data processing steps. Each step should represent a `fetch` call or a computational task that takes time.\n\nRequirements:\n1.  Create an `async` function `fetchUser(userId)` that returns a Promise resolving with a string like `User_{userId}_Data` after 500ms.\n2.  Create an `async` function `processUserData(userData)` that returns a Promise resolving with a string like `Processed_{userData}` after 300ms.\n3.  Create an `async` function `saveProcessedData(processedData)` that returns a Promise resolving with a string like `Saved_{processedData}` after 200ms.\n4.  Implement `processDataSequence(userId)` which uses `await` to call these functions in sequence, starting with `fetchUser(userId)`, then `processUserData`, and finally `saveProcessedData`. It should log each intermediate result and the final result.\n5.  Handle potential errors in any of the steps using `try...catch` and log the error.\n\nExample sequence:\n`fetchUser(1)` -> `processUserData('User_1_Data')` -> `saveProcessedData('Processed_User_1_Data')`\n",
        "complexity": 7,
        "solutionCode": "function delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nasync function fetchUser(userId) {\n  console.log(`Fetching user ${userId}...`);\n  await delay(500);\n  // Simulate a potential error for specific user IDs\n  if (userId === 99) {\n    throw new Error(`User ${userId} not found!`);\n  }\n  const userData = `User_${userId}_Data`;\n  console.log(`Fetched: ${userData}`);\n  return userData;\n}\n\nasync function processUserData(userData) {\n  console.log(`Processing ${userData}...`);\n  await delay(300);\n  const processedData = `Processed_${userData}`;\n  console.log(`Processed: ${processedData}`);\n  return processedData;\n}\n\nasync function saveProcessedData(processedData) {\n  console.log(`Saving ${processedData}...`);\n  await delay(200);\n  const saveResult = `Saved_${processedData}`;\n  console.log(`Saved: ${saveResult}`);\n  return saveResult;\n}\n\nasync function processDataSequence(userId) {\n  console.log(`\\n--- Starting sequence for user ${userId} ---`);\n  try {\n    const user = await fetchUser(userId);\n    const processed = await processUserData(user);\n    const saved = await saveProcessedData(processed);\n    console.log(`Final result for user ${userId}: ${saved}`);\n  } catch (error) {\n    console.error(`Sequence failed for user ${userId}: ${error.message}`);\n  }\n  console.log(`--- Sequence completed for user ${userId} ---`);\n}\n\n// Test cases:\nconsole.log('*** Running successful sequence (User 1) ***');\nprocessDataSequence(1);\n\nconsole.log('\\n*** Running sequence with simulated error (User 99) ***');\nprocessDataSequence(99);\n\n// Demonstrate concurrent processing (these will run in parallel with the sequences above)\nconsole.log('\\n*** Other concurrent operations ***');\nsetTimeout(() => console.log('Concurrent Timeout 1 (macrotask)'), 10);\nPromise.resolve().then(() => console.log('Concurrent Promise 1 (microtask)'));\nsetTimeout(() => console.log('Concurrent Timeout 2 (macrotask)'), 50);\n",
        "tags": [
          "JavaScript",
          "Async/Await",
          "Promises",
          "Asynchronous Flow",
          "Error Handling",
          "Interview Task"
        ],
        "difficulty": "medium",
        "relatedConcepts": [
          "Promise Chaining",
          "Asynchronous Control Flow"
        ],
        "hints": [
          "Remember that `await` can only be used inside an `async` function.",
          "Use `try...catch` blocks to gracefully handle rejections from Promises.",
          "The `delay` function provided in the starting code can be used to simulate network latency or heavy computation.",
          "Pay attention to what each `await` call returns."
        ],
        "id": "task_chain_async_operations",
        "timeEstimate": 45,
        "interviewRelevance": 9,
        "prerequisites": [
          "promises",
          "async_await",
          "error_handling"
        ],
        "title": "Chain Asynchronous Operations with `async/await`"
      }
    ],
    "startLine": 1000,
    "endLine": 1001,
    "questions": [
      {
        "answer": "JavaScript is single-threaded, executing one operation at a time.",
        "type": "mcq",
        "question": "What is the primary characteristic of JavaScript regarding its execution model?",
        "interviewFrequency": 7,
        "options": [
          "JavaScript is multi-threaded, executing multiple operations concurrently.",
          "JavaScript uses a thread pool for parallel execution.",
          "JavaScript is single-threaded, executing one operation at a time.",
          "JavaScript is compiled to native code for simultaneous execution."
        ],
        "example": null,
        "tags": [
          "JavaScript",
          "Fundamentals",
          "Event Loop"
        ],
        "keyConcepts": [
          "Single-threaded",
          "Execution Model"
        ],
        "level": "easy",
        "id": "question_event_loop_1",
        "prerequisites": [
          "javascript_basics"
        ],
        "topic": "JavaScript Event Loop Fundamentals",
        "evaluationCriteria": [
          "Correct identification of JavaScript's execution characteristic."
        ],
        "learningPath": "beginner",
        "analysisPoints": [
          "Tests fundamental understanding of JavaScript's execution model.",
          "Distinguishes between single-threaded and multi-threaded concepts.",
          "Highlights the core nature of JavaScript's concurrency model."
        ],
        "complexity": 2
      },
      {
        "analysisPoints": [
          "Evaluates knowledge of core JavaScript runtime components.",
          "Ensures understanding of where synchronous execution contexts are managed."
        ],
        "type": "mcq",
        "level": "easy",
        "id": "question_event_loop_2",
        "answer": "The Call Stack",
        "options": [
          "The Event Queue",
          "The Message Queue",
          "The Call Stack",
          "The Heap"
        ],
        "topic": "Call Stack",
        "tags": [
          "JavaScript",
          "Call Stack",
          "Execution Context"
        ],
        "interviewFrequency": 6,
        "prerequisites": [
          "javascript_basics",
          "functions"
        ],
        "evaluationCriteria": [
          "Ability to name the correct data structure."
        ],
        "keyConcepts": [
          "Call Stack",
          "Execution Context"
        ],
        "question": "Which data structure is responsible for tracking the execution context of functions in JavaScript?",
        "learningPath": "beginner",
        "complexity": 3,
        "example": null
      },
      {
        "level": "medium",
        "topic": "Web APIs",
        "type": "open",
        "answer": "Web APIs (e.g., `setTimeout`, `fetch`, DOM events like `click`) are functionalities provided by the browser environment (not the JavaScript engine itself) that enable asynchronous operations. They allow JavaScript to offload tasks that might take a long time to complete to the browser's underlying threads. Once these tasks are finished, their associated callbacks are placed into the Callback Queue, to be picked up by the Event Loop when the Call Stack is empty. This prevents the single JavaScript thread from being blocked, ensuring the UI remains responsive. Examples include: `setTimeout()` for delayed execution, `fetch()` for network requests, `addEventListener()` for handling user interactions.",
        "keyConcepts": [
          "Web APIs",
          "Asynchronous JavaScript",
          "Single-threaded",
          "Browser Environment"
        ],
        "question": "Explain the role of Web APIs in the context of JavaScript's single-threaded nature. Provide at least two examples.",
        "tags": [
          "JavaScript",
          "Asynchronous",
          "Web APIs",
          "Browser"
        ],
        "id": "question_event_loop_3",
        "learningPath": "intermediate",
        "interviewFrequency": 8,
        "example": null,
        "analysisPoints": [
          "Tests understanding of the interaction between JavaScript and the browser environment.",
          "Assesses ability to explain how asynchronous tasks are handled without blocking.",
          "Requires recall of specific examples of Web APIs."
        ],
        "evaluationCriteria": [
          "Clarity of explanation regarding Web API purpose.",
          "Accuracy of provided examples.",
          "Correct linkage to the Event Loop concept."
        ],
        "prerequisites": [
          "event_loop_and_async_js"
        ],
        "complexity": 6
      },
      {
        "learningPath": "intermediate",
        "keyConcepts": [
          "Callback Queue",
          "Microtask Queue",
          "Macrotask",
          "Microtask",
          "Priority",
          "Event Loop"
        ],
        "id": "question_event_loop_4",
        "analysisPoints": [
          "Tests detailed knowledge of Event Loop queues.",
          "Assesses ability to categorize different asynchronous tasks correctly.",
          "Evaluates understanding of task priority in the Event Loop."
        ],
        "answer": "The Callback Queue (or Macrotask Queue) holds callbacks for macrotasks such as `setTimeout`, `setInterval`, I/O operations (like network requests initiated by `fetch` or `XMLHttpRequest`), and UI rendering events. It operates on a FIFO basis, and the Event Loop processes one macrotask per cycle.\n\nThe Microtask Queue, on the other hand, holds callbacks for microtasks, which primarily include Promise callbacks (`.then()`, `.catch()`, `.finally()`) and `MutationObserver` callbacks. Microtasks have a higher priority than macrotasks. The Event Loop completely drains the Microtask Queue after the Call Stack is empty but *before* taking the next macrotask from the Callback Queue. This means all pending microtasks are executed before the browser gets a chance to render or process the next macrotask.",
        "prerequisites": [
          "event_loop_and_async_js"
        ],
        "interviewFrequency": 9,
        "type": "open",
        "level": "medium",
        "complexity": 7,
        "tags": [
          "JavaScript",
          "Event Loop",
          "Queues",
          "Asynchronous"
        ],
        "topic": "Callback Queue vs. Microtask Queue",
        "question": "Differentiate between the Callback Queue (Macrotask Queue) and the Microtask Queue in JavaScript's Event Loop. What types of tasks go into each, and which has higher priority?",
        "evaluationCriteria": [
          "Accurate definition and examples for both queues.",
          "Clear explanation of priority differences.",
          "Demonstration of how the Event Loop handles each."
        ],
        "example": null
      },
      {
        "interviewFrequency": 10,
        "answer": "The output will be:\n```\nStart\nEnd\nPromise 1\nPromise 2\nImmediate Timeout\nNext Tick\n```\n\n**Reasoning:**\n1.  **'Start'** is logged immediately as it's synchronous code.\n2.  The `setTimeout` callback is sent to the Web APIs and, upon timer expiry (0ms), moved to the **Macrotask Queue**.\n3.  `Promise.resolve()` creates a resolved promise, and its `.then()` callbacks are immediately scheduled as **Microtasks**.\n4.  `process.nextTick` (Node.js specific, but relevant for priority comparison) is another microtask-like mechanism, placed at the front of the microtask queue.\n5.  **'End'** is logged immediately as it's synchronous code.\n6.  The Call Stack is now empty. The Event Loop first checks the **Microtask Queue**.\n7.  `process.nextTick`'s callback is executed: **'Next Tick'** is logged.\n8.  The first `Promise.then` callback is executed: **'Promise 1'** is logged.\n9.  The second `Promise.then` callback is executed: **'Promise 2'** is logged.\n10. The Microtask Queue is now empty. The Event Loop then checks the **Macrotask Queue**.\n11. The `setTimeout` callback is executed: **'Immediate Timeout'** is logged.",
        "id": "question_event_loop_5",
        "evaluationCriteria": [
          "Correct prediction of the output order.",
          "Accurate step-by-step explanation of Event Loop behavior.",
          "Correct identification of task types and their priorities."
        ],
        "topic": "Event Loop Order Prediction",
        "prerequisites": [
          "event_loop_and_async_js"
        ],
        "example": "```javascript\nconsole.log('Start');\n\nsetTimeout(() => {\n  console.log('Immediate Timeout');\n}, 0);\n\nPromise.resolve()\n  .then(() => {\n    console.log('Promise 1');\n  })\n  .then(() => {\n    console.log('Promise 2');\n  });\n\n// Note: process.nextTick is Node.js specific, but used here for priority illustration.\n// In browser environments, this would be omitted or replaced with another microtask source.\n// For browser context, consider queueMicrotask() for similar priority.\n// Assuming Node.js environment for this specific example's full output.\nif (typeof process !== 'undefined' && process.nextTick) {\n  process.nextTick(() => {\n    console.log('Next Tick');\n  });\n}\n\nconsole.log('End');\n```",
        "type": "code",
        "options": [],
        "level": "hard",
        "learningPath": "advanced",
        "tags": [
          "JavaScript",
          "Event Loop",
          "Asynchronous",
          "Promises",
          "setTimeout",
          "Hard"
        ],
        "complexity": 9,
        "analysisPoints": [
          "Evaluates a deep understanding of synchronous execution, microtask queue, and macrotask queue.",
          "Tests the ability to trace code execution through the Event Loop.",
          "Distinguishes between `setTimeout` and `Promise` execution priority."
        ],
        "question": "Predict the exact output of the following JavaScript code and explain your reasoning step-by-step:",
        "keyConcepts": [
          "Event Loop",
          "Microtask Queue",
          "Macrotask Queue",
          "Promise",
          "setTimeout",
          "process.nextTick (contextual)"
        ]
      },
      {
        "type": "open",
        "complexity": 8,
        "evaluationCriteria": [
          "Clear explanation of `async/await`'s relationship to Promises.",
          "Correct description of how `await` works without blocking.",
          "Accurate mention of the Microtask Queue's role."
        ],
        "example": null,
        "analysisPoints": [
          "Tests understanding of `async/await` as syntactic sugar.",
          "Assesses knowledge of `await`'s non-blocking nature.",
          "Requires linking `async/await` back to Promises and the Microtask Queue."
        ],
        "keyConcepts": [
          "Async/Await",
          "Promises",
          "Microtask Queue",
          "Non-blocking",
          "Syntactic Sugar"
        ],
        "prerequisites": [
          "event_loop_and_async_js"
        ],
        "id": "question_event_loop_6",
        "learningPath": "advanced",
        "level": "medium",
        "answer": "`async/await` is syntactic sugar built on top of Promises. An `async` function always returns a Promise. When `await` is encountered inside an `async` function, it essentially 'pauses' the execution of that specific `async` function and releases the main thread. The value being awaited must be a Promise. The runtime then continues executing any synchronous code outside the `async` function.\n\nOnce the awaited Promise resolves (or rejects), the remaining code of the `async` function (after the `await` keyword) is wrapped into a callback and placed into the **Microtask Queue**. The Event Loop will then pick up this microtask and push it onto the Call Stack for execution once the Call Stack is empty and all other microtasks have been processed. This mechanism ensures that the `async` function's execution resumes as soon as possible after the awaited Promise settles, without ever blocking the main JavaScript thread.",
        "question": "How does `async/await` work under the hood with Promises and the Event Loop? Explain how `await` keyword effectively 'pauses' execution without blocking the main thread.",
        "interviewFrequency": 9,
        "tags": [
          "JavaScript",
          "Async/Await",
          "Promises",
          "Event Loop"
        ],
        "topic": "Async/Await"
      },
      {
        "id": "question_event_loop_7",
        "tags": [
          "Flashcard",
          "Event Loop"
        ],
        "question": "What is the main responsibility of the Event Loop?",
        "type": "flashcard",
        "keyConcepts": [
          "Event Loop",
          "Call Stack",
          "Queues"
        ],
        "topic": "Event Loop Cycle",
        "interviewFrequency": 6,
        "level": "easy",
        "complexity": 2,
        "learningPath": "beginner",
        "prerequisites": [],
        "evaluationCriteria": [],
        "example": null,
        "analysisPoints": [],
        "answer": "The main responsibility of the Event Loop is to continuously check if the Call Stack is empty. If it is, it moves callbacks from the Microtask Queue (then the Macrotask Queue) to the Call Stack for execution."
      },
      {
        "keyConcepts": [
          "DOM Events",
          "Event Loop",
          "Callback Queue",
          "Asynchronous"
        ],
        "example": "```javascript\ndocument.getElementById('myButton').addEventListener('click', () => {\n  console.log('Button clicked!');\n});\nconsole.log('Script end');\n```",
        "interviewFrequency": 7,
        "learningPath": "intermediate",
        "complexity": 6,
        "topic": "DOM Interaction and Event Loop",
        "type": "open",
        "prerequisites": [
          "event_loop_and_async_js"
        ],
        "level": "medium",
        "tags": [
          "JavaScript",
          "Event Loop",
          "DOM",
          "Browser"
        ],
        "evaluationCriteria": [
          "Correctly identifies where the event callback goes.",
          "Explains the Event Loop's role in processing it.",
          "Connects it to the non-blocking nature of JavaScript."
        ],
        "answer": "When a user clicks a button, the browser's rendering engine detects this interaction. It then places the associated callback function (registered via `addEventListener`) into the **Callback Queue (Macrotask Queue)**. The Event Loop, upon finding the Call Stack empty and the Microtask Queue empty, will then pick this callback from the Callback Queue and push it onto the Call Stack for execution. This ensures that user interactions do not block the main thread and are processed asynchronously in the correct order after any synchronous code and microtasks have completed.",
        "id": "question_event_loop_8",
        "question": "Consider a scenario where a user clicks a button, triggering a DOM event. How does this interaction fit into the Event Loop model?",
        "analysisPoints": [
          "Tests understanding of how user input/DOM events are handled asynchronously.",
          "Relates concrete browser behavior to the abstract Event Loop model.",
          "Highlights the role of the Callback Queue for such events."
        ]
      },
      {
        "topic": "Infinite Loop Impact",
        "question": "What happens if an infinite loop runs in JavaScript's main thread? How does it affect asynchronous operations and the user interface?",
        "evaluationCriteria": [
          "Clear explanation of the blocking effect.",
          "Correctly identifies the consequence for asynchronous tasks.",
          "Describes the impact on the user interface."
        ],
        "tags": [
          "JavaScript",
          "Blocking",
          "Performance",
          "Event Loop"
        ],
        "interviewFrequency": 6,
        "id": "question_event_loop_9",
        "prerequisites": [
          "event_loop_and_async_js"
        ],
        "analysisPoints": [
          "Tests understanding of synchronous blocking behavior.",
          "Connects Call Stack blocking to UI unresponsiveness.",
          "Explains the impact on asynchronous task processing."
        ],
        "type": "open",
        "complexity": 7,
        "keyConcepts": [
          "Blocking",
          "Infinite Loop",
          "Call Stack",
          "UI Responsiveness",
          "Event Loop"
        ],
        "answer": "If an infinite loop runs in JavaScript's main thread, it will completely block the Call Stack. Since the Event Loop can only push callbacks from the queues to the Call Stack when the Call Stack is empty, no asynchronous operations (neither microtasks nor macrotasks like `setTimeout` callbacks or UI events) will ever be executed. This leads to a completely frozen and unresponsive user interface, as the browser's rendering engine and event handlers are effectively blocked by the continuous execution of the infinite loop.",
        "learningPath": "intermediate",
        "example": "```javascript\nconsole.log('Start');\n\nwhile (true) {\n  // Infinite loop - DANGER!\n}\n\nsetTimeout(() => {\n  console.log('This will never run!');\n}, 1000);\n\nconsole.log('End - This will also never run!');\n```",
        "level": "medium"
      },
      {
        "type": "mcq",
        "example": null,
        "tags": [
          "JavaScript",
          "Event Loop",
          "Microtask",
          "Priority"
        ],
        "evaluationCriteria": [
          "Correctly identifies the order and completeness of microtask processing."
        ],
        "options": [
          "It processes one microtask, then one macrotask, in alternating fashion.",
          "It processes all microtasks after all macrotasks are done.",
          "It processes microtasks only if the Macrotask Queue is empty.",
          "The Event Loop processes all tasks in the Microtask Queue completely after the Call Stack is empty and before picking the next task from the Macrotask Queue."
        ],
        "keyConcepts": [
          "Microtask Queue",
          "Event Loop",
          "Priority",
          "Macrotask Queue"
        ],
        "learningPath": "intermediate",
        "question": "When does the Event Loop process tasks from the Microtask Queue?",
        "interviewFrequency": 8,
        "level": "medium",
        "id": "question_event_loop_10",
        "prerequisites": [
          "event_loop_and_async_js"
        ],
        "analysisPoints": [
          "Tests precise understanding of Microtask Queue priority and draining behavior.",
          "Distinguishes microtask processing from macrotask processing timing.",
          "Reinforces the concept of full microtask queue draining."
        ],
        "answer": "The Event Loop processes all tasks in the Microtask Queue completely after the Call Stack is empty and before picking the next task from the Macrotask Queue.",
        "complexity": 6,
        "topic": "Microtask Queue Draining"
      },
      {
        "topic": "Performance implications of blocking",
        "tags": [
          "Performance",
          "JavaScript",
          "Event Loop",
          "Best Practices"
        ],
        "level": "hard",
        "keyConcepts": [
          "Performance",
          "Blocking",
          "Responsiveness",
          "Event Loop",
          "Asynchronous",
          "Web Workers",
          "DOM Manipulation"
        ],
        "prerequisites": [
          "event_loop_and_async_js"
        ],
        "type": "open",
        "learningPath": "advanced",
        "analysisPoints": [
          "Comprehensive understanding of blocking consequences.",
          "Deep knowledge of Event Loop's role in performance.",
          "Ability to identify practical scenarios causing blocking.",
          "Suggests solutions to prevent blocking."
        ],
        "id": "question_event_loop_11",
        "evaluationCriteria": [
          "Detailed explanation of UI impact.",
          "Clear articulation of Event Loop's solution.",
          "Accurate and relevant examples of blocking scenarios.",
          "Provides practical mitigation strategies."
        ],
        "answer": "Blocking the main JavaScript thread in a web application leads to a frozen and unresponsive user interface (UI). Users cannot interact with the page, animations stop, and network requests appear stalled because no new events or rendering updates can be processed. This results in a poor user experience and can lead to the browser displaying a 'page unresponsive' warning.\n\nThe Event Loop is crucial for mitigating these issues by enabling asynchronous operations. It allows tasks like network requests, timers, and UI events to be offloaded to Web APIs and processed in the background. Once these asynchronous tasks complete, their callbacks are queued and executed only when the main thread (Call Stack) is free, ensuring that long-running operations don't monopolize the single thread.\n\nCommon scenarios where developers might inadvertently block the main thread include:\n1.  **Heavy synchronous computations:** Performing complex calculations, large array sorting, or extensive data processing directly on the main thread.\n2.  **Synchronous I/O:** Although less common in browser JS, old APIs or certain Node.js operations can be synchronous and block (e.g., `fs.readFileSync` in Node.js).\n3.  **Large DOM manipulations:** Performing many DOM operations in a single synchronous batch without allowing the browser to repaint.\n4.  **Infinite or long-running loops:** Accidental infinite loops or loops iterating over extremely large datasets without yielding to the Event Loop.\n\nTo avoid blocking, developers should leverage Web Workers for CPU-intensive tasks, use `async/await` and Promises for I/O operations, and use techniques like `requestAnimationFrame` for animations and efficient batching for DOM updates.",
        "example": null,
        "interviewFrequency": 8,
        "question": "Discuss the performance implications of blocking the main JavaScript thread in a web application. How does the Event Loop help mitigate these issues, and what are common scenarios where developers might inadvertently block the thread?",
        "complexity": 9
      },
      {
        "example": null,
        "level": "easy",
        "tags": [
          "Flashcard",
          "Web APIs"
        ],
        "topic": "Flashcard: Web APIs",
        "keyConcepts": [
          "Web APIs",
          "Event Loop"
        ],
        "answer": "`setTimeout()`, `fetch()`, `addEventListener()`, `XMLHttpRequest` (any two are sufficient).",
        "question": "Name two common Web APIs that interact with the Event Loop.",
        "learningPath": "beginner",
        "evaluationCriteria": [],
        "prerequisites": [],
        "id": "question_event_loop_12",
        "complexity": 2,
        "type": "flashcard",
        "analysisPoints": [],
        "interviewFrequency": 5
      }
    ],
    "theory": [
      {
        "content": "## JavaScript is Single-Threaded\nJavaScript is inherently single-threaded, meaning it can execute only one piece of code at a time. This characteristic simplifies programming by removing the complexities of concurrency issues like deadlocks or race conditions. However, it also implies that any long-running operation could block the main thread, leading to an unresponsive user interface.\n\n## The Call Stack\nThe Call Stack is a data structure that records where in the program we are. When a function is called, it's pushed onto the stack. When it returns, it's popped off. JavaScript executes code in a synchronous, blocking manner by default, following a LIFO (Last-In, First-Out) principle for the call stack.\n\n## Web APIs (Browser Environment)\nBrowsers provide additional functionalities beyond the core JavaScript language, known as Web APIs. These APIs are not part of the JavaScript engine itself but are exposed to JavaScript to perform tasks that might block the main thread if executed synchronously. Examples include `setTimeout()`, `setInterval()`, `fetch()`, DOM manipulation functions (e.g., `addEventListener`), Geolocation API, etc. When a Web API function is called, the browser handles it in the background, off the main thread.\n\n## Callback Queue (Task Queue / Macrotask Queue)\nOnce a Web API completes its operation (e.g., a `setTimeout` timer expires, a `fetch` request receives a response), its associated callback function is not immediately pushed onto the Call Stack. Instead, it's placed into a data structure called the Callback Queue (also known as the Task Queue or Macrotask Queue). This queue operates on a FIFO (First-In, First-Out) principle.\n\n## Microtask Queue\nThe Microtask Queue is another queue, separate from the Callback Queue, specifically for handling microtasks. Promises (specifically, their `.then()`, `.catch()`, `.finally()` callbacks) and `MutationObserver` callbacks are examples of microtasks. Microtasks have higher priority than macrotasks. The Event Loop processes all microtasks in the Microtask Queue before moving to the next macrotask in the Callback Queue.\n\n## The Event Loop\nThe Event Loop is a continuously running process that monitors both the Call Stack and the Callback Queue (and Microtask Queue). Its primary responsibility is to check if the Call Stack is empty. If the Call Stack is empty, it first moves all pending microtasks from the Microtask Queue to the Call Stack for execution. Once the Microtask Queue is empty, it then picks the first callback from the Callback Queue and pushes it onto the Call Stack for execution. This cycle allows asynchronous operations to be handled without blocking the main thread, ensuring a responsive user interface.\n\n### Event Loop Cycle (Simplified):\n1.  Execute all synchronous code in the Call Stack.\n2.  When the Call Stack is empty, the Event Loop checks the Microtask Queue.\n3.  Move all microtasks from the Microtask Queue to the Call Stack and execute them until the Microtask Queue is empty.\n4.  If the Microtask Queue is empty, the Event Loop checks the Callback Queue (Macrotask Queue).\n5.  Move the first macrotask from the Callback Queue to the Call Stack and execute it.\n6.  Repeat from step 2.\n\n## `async/await`\n`async/await` is modern JavaScript syntax built on top of Promises, providing a more synchronous-looking way to write asynchronous code. An `async` function implicitly returns a Promise. The `await` keyword can only be used inside an `async` function and pauses the execution of the `async` function until the awaited Promise settles (resolves or rejects), allowing other synchronous code to run in the meantime. Once the awaited Promise settles, the `async` function resumes its execution.\n\nThis mechanism effectively converts the rest of the `async` function's body after an `await` into a microtask, ensuring it runs with higher priority than macrotasks once the awaited Promise resolves.\n\n### Key Differences and Priority:\n*   **Synchronous Code:** Executes first and immediately.\n*   **Microtasks (e.g., Promises, `async/await` continuation):** Executed after synchronous code completes, and *before* the next macrotask. All microtasks are drained before a new macrotask is processed.\n*   **Macrotasks (e.g., `setTimeout`, `setInterval`, I/O, UI rendering):** Executed one at a time, only after the Call Stack and Microtask Queue are empty.\n\n### Visualization:\n![Event Loop Diagram](https://i.stack.imgur.com/gA3qj.png)\n*Self-correction: The original markdown content would contain specific diagrams. I'm using a placeholder popular one.*",
        "technology": "JavaScript",
        "relatedTasks": [
          "task_predict_output_event_loop",
          "task_implement_promise_based_delay",
          "task_chain_async_operations"
        ],
        "complexity": 7,
        "examples": [
          {
            "title": "Call Stack Execution",
            "id": "example_call_stack_1",
            "code": "function first() {\n  console.log('First function');\n  second();\n}\n\nfunction second() {\n  console.log('Second function');\n}\n\nfirst();\nconsole.log('Global scope');",
            "language": "javascript",
            "explanation": "This example demonstrates the Call Stack. `first()` is pushed, then `second()` is pushed. `second()` pops, then `first()` pops. Finally, global scope code runs."
          },
          {
            "title": "Basic setTimeout and Call Stack Interaction",
            "id": "example_web_apis_timeout_1",
            "code": "console.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout callback');\n}, 0);\n\nconsole.log('End');",
            "language": "javascript",
            "explanation": "Even with `delay` of 0, `setTimeout` callback goes to Web APIs, then Callback Queue. 'Start' and 'End' print immediately, then 'Timeout callback' after the Call Stack is empty."
          },
          {
            "id": "example_microtask_vs_macrotask_1",
            "code": "console.log('Script start');\n\nsetTimeout(() => {\n  console.log('setTimeout (macrotask)');\n}, 0);\n\nPromise.resolve()\n  .then(() => {\n    console.log('Promise.then (microtask)');\n  })\n  .then(() => {\n    console.log('Promise.then 2 (microtask)');\n  });\n\nconsole.log('Script end');",
            "language": "javascript",
            "title": "Microtask vs. Macrotask Priority",
            "explanation": "Output order: 'Script start', 'Script end', 'Promise.then (microtask)', 'Promise.then 2 (microtask)', 'setTimeout (macrotask)'. This clearly shows microtasks are prioritized over macrotasks after synchronous code completes."
          },
          {
            "title": "Async/Await Basic Usage",
            "id": "example_async_await_1",
            "code": "async function fetchData() {\n  console.log('Fetching data...');\n  const data = await Promise.resolve('Some data');\n  console.log('Data received:', data);\n}\n\nconsole.log('Before async call');\nfetchData();\nconsole.log('After async call');",
            "language": "javascript",
            "explanation": "Output: 'Before async call', 'Fetching data...', 'After async call', 'Data received: Some data'. The `await` pauses `fetchData` function, allowing 'After async call' to run, then `fetchData` resumes as a microtask."
          }
        ],
        "id": "theory_event_loop_and_async_js",
        "prerequisites": [
          "javascript_basics",
          "functions",
          "callbacks"
        ],
        "requiredFor": [
          "advanced_js",
          "frontend_architecture",
          "performance_optimization"
        ],
        "relatedQuestions": [
          "question_event_loop_1",
          "question_event_loop_2",
          "question_event_loop_3",
          "question_event_loop_4",
          "question_event_loop_5",
          "question_event_loop_6",
          "question_event_loop_7",
          "question_event_loop_8",
          "question_event_loop_9",
          "question_event_loop_10",
          "question_event_loop_11",
          "question_event_loop_12"
        ],
        "learningPath": "intermediate",
        "tags": [
          "JavaScript",
          "Asynchronous",
          "Event Loop",
          "Promises",
          "Async/Await",
          "Concurrency",
          "Frontend Performance"
        ],
        "interviewRelevance": 9,
        "title": "JavaScript Event Loop and Asynchronous Programming"
      }
    ],
    "completed": false,
    "displayEndLine": 1000,
    "logicalBlockInfo": {
      "suggestedEndLine": -1
    },
    "processedDate": "2025-06-15T09:13:39.083Z"
  }
]