[
  {
    "theory": [
      {
        "id": "theory_javascript_core",
        "title": "JavaScript Core Concepts",
        "content": "# JavaScript Core Concepts\n\nJavaScript is a programming language that powers the web. It's essential for frontend developers to understand its core concepts.\n\n## Key Components of JavaScript Runtime:\n1. **Call Stack**: Where function calls are stacked and executed (LIFO - Last In, First Out)\n2. **Heap**: Memory allocation pool for objects in JS\n3. **Event Loop**: Enables non-blocking, asynchronous behavior\n\n### Execution Context\nThe environment where JavaScript code is evaluated and executed. Each context has its own variable environment, scope chain, and `this` value.\n\n![JavaScript Memory Heap and Call Stack](images/js_engine_memory_heap.png)\n![JavaScript Event Loop](images/js_engine_execution.png)\n![JavaScript Execution Context](images/js_event_loop.png)",
        "prerequisites": [
          "basic-programming"
        ],
        "complexity": 7,
        "interviewRelevance": 9,
        "learningPath": "intermediate",
        "requiredFor": [
          "theory_react"
        ],
        "relatedQuestions": [
          {
            "id": "question_js_core_1",
            "topic": "JavaScript Core Concepts",
            "level": "medium",
            "type": "mcq",
            "question": "What is the primary purpose of the Call Stack in JavaScript?",
            "options": [
              "To store local variables and function frames during execution.",
              "To manage asynchronous operations using event loop.",
              "To handle all browser operations such as DOM manipulation.",
              "To execute code sequentially."
            ],
            "answer": "To store local variables and function frames during execution.",
            "analysisPoints": [
              "Understanding the stack-based execution model of JavaScript.",
              "Distinguishing between synchronous and asynchronous functions."
            ],
            "keyConcepts": [
              "Execution Context",
              "Event Loop"
            ],
            "tags": [
              "JavaScript",
              "Core Concepts"
            ],
            "complexity": 6,
            "interviewRelevance": 7
          },
          {
            "id": "question_js_core_2",
            "topic": "JavaScript Core Concepts",
            "level": "hard",
            "type": "open",
            "question": "Explain how the Event Loop manages asynchronous operations in JavaScript.",
            "answer": "The event loop continuously checks if there are any tasks in the task queue that need to be executed. It handles asynchronous callbacks by delegating them to the appropriate internal mechanisms, managing the call stack and heap efficiently.",
            "options": [],
            "analysisPoints": [
              "Explaining how JavaScript manages time-consuming operations without blocking the main thread.",
              "Understanding the role of the event loop in maintaining non-blocking behavior."
            ],
            "keyConcepts": [
              "Event Loop",
              "Asynchronous Programming"
            ],
            "tags": [
              "JavaScript",
              "Core Concepts"
            ],
            "complexity": 8,
            "interviewRelevance": 8
          }
        ],
        "relatedTasks": [
          {
            "id": "task_js_core_1",
            "title": "Implement a JavaScript Function Using the Call Stack",
            "description": "Create a function that simulates the call stack overflow by calling itself recursively without a base case. Include error handling to catch and display an error message when too many calls are made.",
            "difficulty": "hard",
            "startingCode": "function recursiveFunction() {\n  // Your code here\n}",
            "solutionCode": "function recursiveFunction() {\n  try {\n    recursiveFunction();\n  } catch (error) {\n    console.error('Error:', error.message);\n  }\n}",
            "testCases": [
              "Calling `recursiveFunction()` should eventually lead to a stack overflow error.",
              "Include a mechanism in the function to stop recursion and handle it gracefully."
            ],
            "hints": [
              "Consider adding a condition to limit the number of recursive calls.",
              "Use try-catch blocks to manage errors effectively."
            ],
            "tags": [
              "JavaScript",
              "Core Concepts"
            ],
            "timeEstimate": 30,
            "prerequisites": [],
            "complexity": 9,
            "interviewRelevance": 10
          }
        ],
        "tags": [
          "JavaScript",
          "Core Concepts"
        ],
        "technology": "JavaScript",
        "examples": [
          {
            "id": "example_javascript_core_1",
            "title": "Call Stack Example",
            "code": "function foo() {\n  throw new Error('Stack Trace!');\n}\n\nfunction bar() {\n  foo();\n}\n\nbar();",
            "explanation": "This example demonstrates how the call stack works when an error is thrown. It starts from the most recent function call and unwinds back through the stack.",
            "language": "javascript"
          },
          {
            "id": "example_javascript_core_2",
            "title": "Event Loop Explanation",
            "code": "console.log('Start');\nsetTimeout(() => console.log('Timeout'), 0);\nconsole.log('End');",
            "explanation": "This code snippet shows how the event loop works, with 'start' printed immediately, followed by 'end', and then 'timeout' after a short delay due to the asynchronous nature of setTimeout.",
            "language": "javascript"
          }
        ]
      },
      {
        "id": "theory_event_loop",
        "title": "Event Loop in JavaScript (Continued)",
        "content": "# Event Loop in JavaScript\n\n## Understanding the Event Loop\nThe event loop is a fundamental part of how JavaScript handles asynchronous operations. It continuously checks if there are any tasks in the task queue that need to be executed.\n\n### How it Works\n1. **Task Queue**: A list of tasks waiting to be processed.\n2. **Microtasks and Macrotasks**: Different queues for prioritizing tasks.\n3. **Cycle of Execution**: The loop picks tasks from these queues, processes them in a specific order.\n\n![Detailed Event Loop Diagram](images/event_loop_diagram.png)\n\n### Practical Example\nConsider the following code snippet:\n```javascript\nconsole.log('Start');\nsetTimeout(() => console.log('Timeout'), 0);\nconsole.log('End');\n```\nWhat will be printed, and in what order?\n\n### Key Points to Remember\n- **Synchronous Tasks**: Run immediately.\n- **Microtasks (Promise callbacks)**: Prioritized over Macrotasks.\n- **Macrotasks (setTimeout, setInterval)**: Queued after current synchronous code execution completes.\n",
        "prerequisites": [
          "basic-programming"
        ],
        "complexity": 5,
        "interviewRelevance": 5,
        "learningPath": "intermediate",
        "requiredFor": [
          "advanced-concepts"
        ],
        "relatedQuestions": [
          {
            "id": "question_event_loop_1",
            "topic": "Event Loop in JavaScript",
            "level": "medium",
            "type": "mcq",
            "question": "What is the order of execution for tasks in the event loop?",
            "options": [
              "Synchronous tasks first, then microtasks, followed by macrotasks.",
              "Microtasks before synchronous tasks, then macrotasks.",
              "All tasks run simultaneously regardless of type.",
              "Macrotasks are prioritized over microtasks."
            ],
            "answer": "Synchronous tasks first, then microtasks, followed by macrotasks.",
            "analysisPoints": [
              "Understanding the sequence in which tasks are executed in JavaScript.",
              "Recognizing the priority between synchronous and asynchronous tasks."
            ],
            "keyConcepts": [
              "Event Loop",
              "Microtasks",
              "Macrotasks"
            ],
            "tags": [
              "JavaScript",
              "Core Concepts"
            ],
            "complexity": 7,
            "interviewRelevance": 8
          },
          {
            "id": "question_event_loop_2",
            "topic": "Event Loop in JavaScript",
            "level": "hard",
            "type": "open",
            "question": "Explain how the event loop manages asynchronous operations and the role of microtasks and macrotasks.",
            "answer": "The event loop ensures that synchronous tasks are executed first, followed by any pending microtasks. Macrotasks are queued after all synchronous code has finished executing, ensuring they run only after current synchronous context is completed.",
            "options": [],
            "analysisPoints": [
              "Explaining the prioritization and execution order of different types of asynchronous tasks in JavaScript.",
              "Understanding how the event loop manages task queues efficiently."
            ],
            "keyConcepts": [
              "Event Loop",
              "Microtasks",
              "Macrotasks"
            ],
            "tags": [
              "JavaScript",
              "Core Concepts"
            ],
            "complexity": 8,
            "interviewRelevance": 9
          }
        ],
        "relatedTasks": [
          {
            "id": "task_event_loop_1",
            "title": "Implement a Task Scheduler Using Microtasks and Macrotasks",
            "description": "Create a function that demonstrates the use of microtasks by resolving a promise immediately followed by a macrotask using setTimeout. Log messages to show their order of execution.",
            "difficulty": "hard",
            "startingCode": "function taskScheduler() {\n  // Your code here\n}",
            "solutionCode": "function taskScheduler() {\n  Promise.resolve().then(() => console.log('Microtask'));\ntimeout(() => console.log('Macrotask'), 0);\n}",
            "testCases": [
              "Ensure that 'Microtask' is logged before 'Macrotask'."
            ],
            "hints": [
              "Use `Promise.resolve().then()` for microtasks and `setTimeout` for macrotasks.",
              "Log messages to observe the order of execution."
            ],
            "tags": [
              "JavaScript",
              "Core Concepts"
            ],
            "timeEstimate": 30,
            "prerequisites": [
              "theory_js_core"
            ],
            "complexity": 9,
            "interviewRelevance": 10
          }
        ],
        "tags": [
          "concept",
          "fundamentals",
          "important"
        ],
        "technology": "JavaScript",
        "examples": [
          {
            "id": "example_event_loop_1",
            "title": "Microtasks vs Macrotasks Example",
            "code": "Promise.resolve().then(() => console.log('Microtask'));\ntimeout(() => console.log('Macrotask'), 0);",
            "explanation": "This example demonstrates the difference in execution order between microtasks and macrotasks. Microtasks are executed before macrotasks.",
            "language": "javascript"
          }
        ]
      }
    ],
    "tasks": [],
    "endLine": 100,
    "logicalBlockInfo": {
      "continuesToNextChunk": false,
      "suggestedEndLine": -1
    },
    "startLine": 0,
    "id": "chunk_0_1749681990211",
    "completed": false,
    "processedDate": "2025-06-11T22:46:30.211Z",
    "questions": []
  },
  {
    "processedDate": "2025-06-11T22:47:22.803Z",
    "startLine": 100,
    "id": "chunk_100_1749682042803",
    "completed": false,
    "tasks": [
      {
        "id": "task_implement_async_operation",
        "title": "Implement an Asynchronous Operation with setTimeout and Promises",
        "description": "\n1. Implement a function that uses `setTimeout` to log a message after a delay.\n2. Enhance the function to use Promises for handling asynchronous operations.\n3. Write test cases to verify the functionality of both implementations.",
        "difficulty": "medium",
        "startingCode": "function asyncOperation() {\n  // TODO: Implement the operation using setTimeout\n}\n\n// Example usage:\nasyncOperation();",
        "solutionCode": "function asyncOperation() {\n  console.log('Starting');\n  setTimeout(() => console.log('Executing after delay'), 1000);\n  Promise.resolve().then(() => console.log('Executing asynchronously'));\n}\n\n// Test cases:\nconsole.log(asyncOperation()); // Should log 'Starting' immediately, then 'Executing asynchronously', and finally 'Executing after delay' after the timeout.\n",
        "testCases": [
          "Test with console output: asyncOperation() should print 'Starting', followed by asynchronous messages.",
          "Ensure that setTimeout is used correctly to defer execution of specific logs.",
          "Verify that both synchronous and asynchronous tasks are executed in the correct order."
        ],
        "hints": [
          "Start by declaring your function and setting up basic logging.",
          "Use `setTimeout` for a delayed task simulation.",
          "Integrate Promises for handling non-blocking operations seamlessly."
        ],
        "tags": [
          "javascript",
          "async",
          "promises"
        ],
        "timeEstimate": 30,
        "prerequisites": [
          "concept_event_loop"
        ],
        "complexity": 7,
        "interviewRelevance": 8,
        "learningPath": "intermediate",
        "relatedConcepts": []
      },
      {
        "id": "task_implement_factory_pattern",
        "title": "Implement a Factory Pattern to Create User Objects",
        "description": "\n1. Define a factory function that creates user objects based on the type provided.\n2. Implement different types of users, such as 'admin' and 'user', each with specific properties and methods.\n3. Write test cases to verify object creation.",
        "difficulty": "medium",
        "startingCode": "function createUser(type) {\n  // TODO: Implement the factory pattern\n}",
        "solutionCode": "function createUser(type) {\n  if (type === 'admin') {\n    return {name: 'Admin', permissions: ['read', 'write', 'delete']};\n  } else if (type === 'user') {\n    return {name: 'User', permissions: ['read']};\n  }\n}\n\n// Test cases:\nconst admin = createUser('admin');\nconst user = createUser('user');\nconsole.log(admin); // Should have name 'Admin' and appropriate permissions.\nconsole.log(user); // Should have name 'User' with read-only access.",
        "testCases": [
          "Verify that the factory function correctly creates objects based on the provided type ('admin' or 'user').",
          "Check if different types of users have distinct properties and methods as expected.",
          "Ensure that the solution handles various input types gracefully."
        ],
        "hints": [
          "Begin by setting up a basic structure for the factory function.",
          "Implement conditional logic to return objects with appropriate configurations based on type."
        ],
        "tags": [
          "javascript",
          "factorypattern"
        ],
        "timeEstimate": 45,
        "prerequisites": [
          "theory_js_design_patterns"
        ],
        "complexity": 6,
        "interviewRelevance": 7,
        "learningPath": "intermediate",
        "relatedConcepts": []
      },
      {
        "id": "task_event_loop_implementation",
        "title": "Implement a Simple Event Loop Simulation in JavaScript",
        "description": "\n1. Create a simulation of the event loop using basic JavaScript constructs like setTimeout and Promises.\n2. Log messages to represent different stages of processing, including microtasks, tasks from the callback queue, and UI updates if applicable.\n3. Ensure that your implementation demonstrates how asynchronous operations are handled according to the event loop rules.",
        "difficulty": "hard",
        "startingCode": "function simulateEventLoop() {\n  // TODO: Implement the event loop simulation\n}",
        "solutionCode": "function simulateEventLoop() {\n  console.log('Start');\n  setTimeout(() => console.log('Timeout callback'), 0);\n  Promise.resolve().then(() => console.log('Promise callback'));\n  console.log('End');\n}\n\n// Test cases:\nsimulateEventLoop(); // Should log 'Start', 'End', 'Promise callback' (microtask), and 'Timeout callback' (callback queue).",
        "testCases": [
          "Run the simulation and observe the order of logged messages to confirm the event loop's handling.",
          "Ensure that microtasks are processed before any tasks from the callback queue.",
          "Verify that asynchronous operations are handled correctly according to JavaScript's concurrency model."
        ],
        "hints": [
          "Start by defining a basic structure for your simulation, including console logs to represent different stages.",
          "Use setTimeout and Promise.resolve() to simulate microtasks and tasks respectively."
        ],
        "tags": [
          "javascript",
          "eventloop"
        ],
        "timeEstimate": 60,
        "prerequisites": [],
        "complexity": 9,
        "interviewRelevance": 7,
        "learningPath": "advanced",
        "relatedConcepts": []
      }
    ],
    "questions": [
      {
        "id": "question_web_apis_1",
        "topic": "Web APIs",
        "level": "medium",
        "type": "mcq",
        "question": "Which of the following is a Browser API commonly used for making asynchronous HTTP requests?",
        "answer": "XMLHttpRequest or its modern equivalent, fetch.",
        "options": [
          "setTimeout",
          "fetch",
          "console.log",
          "document.write"
        ],
        "analysisPoints": [
          "Understanding of browser APIs and their usage in web development.",
          "Distinction between synchronous and asynchronous operations."
        ],
        "keyConcepts": [
          "Web APIs",
          "Asynchronous Operations"
        ],
        "evaluationCriteria": [
          "Recognize common Browser APIs.",
          "Understand the distinction between different types of API interactions."
        ],
        "example": "\n```javascript\nfetch('https://api.example.com/data')\n  .then(response => response.json())\n  .then(data => console.log(data))\n  .catch(error => console.error('Error:', error));\n```",
        "tags": [
          "webapis",
          "javascript"
        ],
        "prerequisites": [],
        "complexity": 7,
        "interviewFrequency": 8,
        "learningPath": "intermediate"
      },
      {
        "id": "question_event_loop_1",
        "topic": "Event Loop",
        "level": "hard",
        "type": "open",
        "question": "Explain the Event Loop in JavaScript, detailing how it handles asynchronous operations and UI updates.",
        "answer": "The Event Loop in JavaScript manages a queue of tasks to be executed. It processes items from the microtask queue before moving to the callback queue based on their priority and timing. Non-blocking I/O operations are handled by Web APIs, while the call stack ensures synchronous code execution. The loop repeats this process continuously.",
        "options": [],
        "analysisPoints": [
          "Deep understanding of JavaScript's concurrency model.",
          "Ability to explain the role of microtasks in asynchronous processing."
        ],
        "keyConcepts": [
          "Event Loop",
          "Microtask Queue"
        ],
        "evaluationCriteria": [
          "Explains the theoretical underpinnings of the event loop.",
          "Differentiates between different types of task queues and their handling by the loop."
        ],
        "example": "\n```javascript\nconsole.log('Start');\ntimeout(() => console.log('Timeout callback'), 0);\nPromise.resolve().then(() => console.log('Promise callback'));\nconsole.log('End');\n// Output order:\n// 'Start'\n// 'End'\n// 'Promise callback' (microtask)\n// 'Timeout callback' (task queue)\n```",
        "tags": [
          "eventloop",
          "javascript"
        ],
        "prerequisites": [],
        "complexity": 9,
        "interviewFrequency": 7,
        "learningPath": "advanced"
      },
      {
        "id": "question_constructor_pattern_1",
        "topic": "JavaScript Design Patterns",
        "level": "medium",
        "type": "mcq",
        "question": "What is the purpose of using the Constructor Pattern in JavaScript?",
        "answer": "The purpose of using the Constructor Pattern in JavaScript is to create multiple instances of objects with properties and methods defined once.",
        "options": [
          "To implement inheritance easily.",
          "To define object types and create new objects of that type.",
          "To optimize memory usage by reusing objects.",
          "To simplify the syntax for creating many similar objects."
        ],
        "analysisPoints": [
          "Understanding of design patterns in JavaScript.",
          "Ability to distinguish between different pattern purposes."
        ],
        "keyConcepts": [
          "Constructor Pattern",
          "Object Creation"
        ],
        "evaluationCriteria": [
          "Recognizes when and how to use constructor patterns.",
          "Understands the benefits of creating objects through a defined blueprint."
        ],
        "example": "\n```javascript\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n  this.sayHello = function() {\n    console.log(`Hello, my name is ${this.name}`);\n  };\n}\nconst john = new Person('John', 30);\njohn.sayHello(); // Hello, my name is John\n```",
        "tags": [
          "designpatterns",
          "javascript"
        ],
        "prerequisites": [],
        "complexity": 7,
        "interviewFrequency": 8,
        "learningPath": "intermediate"
      }
    ],
    "theory": [
      {
        "id": "theory_web_apis",
        "title": "Web APIs: Browser APIs and Event Loop",
        "content": "# Web APIs: Browser APIs (DOM, AJAX, setTimeout, etc.) that run operations asynchronously\n\n## Key Concepts\n- **Browser APIs**: Provide functionality for applications to communicate with the user interface or browser itself. Examples include DOM manipulation, AJAX requests, `setTimeout`, and more.\n- **Callback Queue**: Where callbacks from async operations wait to be executed after the call stack is cleared.\n- **Microtask Queue**: A higher priority queue for tasks like Promises and mutation observers.\n- **Event Loop**: Constantly checks if the call stack is empty and moves callbacks to it, ensuring asynchronous code execution follows a specific order.\n\n## Implementation\n### Event Loop Algorithm:\n1. Execute code in the call stack until it's empty.\n2. Check the microtask queue and execute all tasks there.\n3. Render UI updates if needed.\n4. Check the callback queue and push the oldest task to the call stack.\n5. Repeat.\n\n## Examples\n### Common Event Loop Examples:\n```javascript\nconsole.log('Start'); // 1. Runs immediately\n\nsetTimeout(() => {\n  console.log('Timeout callback'); // 4. Runs after stack is empty and delay is complete\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise callback'); // 3. Runs after stack is empty but before timeout\n});\n\nconsole.log('End'); // 2. Runs immediately\n\n// Output order:\n// 'Start'\n// 'End'\n// 'Promise callback' (microtask)\n// 'Timeout callback' (task queue)\n```",
        "prerequisites": [
          "basic-programming"
        ],
        "complexity": 7,
        "interviewRelevance": 8,
        "learningPath": "intermediate",
        "requiredFor": [
          "advanced-concepts"
        ],
        "relatedQuestions": [],
        "relatedTasks": [],
        "tags": [
          "webapis",
          "eventloop",
          "javascript"
        ],
        "technology": "JavaScript",
        "examples": [
          {
            "id": "example_event_loop_1",
            "title": "Event Loop Visualization",
            "code": "console.log('Start');\nsetTimeout(() => console.log('Timeout callback'), 0);\nPromise.resolve().then(() => console.log('Promise callback'));\nconsole.log('End');",
            "explanation": "This example demonstrates the sequence of events in the JavaScript event loop, showing how different types of asynchronous operations are processed.",
            "language": "javascript"
          },
          {
            "id": "example_event_loop_2",
            "title": "Microtask Queue Example",
            "code": "Promise.resolve().then(() => console.log('Microtask 1'));\nconsole.log('Sync Task');\nPromise.resolve().then(() => console.log('Microtask 2'));",
            "explanation": "This example shows how microtasks are prioritized and executed before the next task from the callback queue, illustrating their higher priority.",
            "language": "javascript"
          }
        ]
      },
      {
        "id": "theory_js_design_patterns",
        "title": "JavaScript Design Patterns: Creational Patterns",
        "content": "# JavaScript Design Patterns\n\n## Creational Patterns\n\n### Constructor Pattern\n```javascript\n// Constructor Pattern\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n   \n  this.sayHello = function() {\n    console.log(`Hello, my name is ${this.name}`);\n  };\n}\n\nconst john = new Person('John', 30);\njohn.sayHello(); // Hello, my name is John\n```\n\n### Factory Pattern\n```javascript\n// Factory Pattern\nfunction createUser(type) {\n  if (type === 'admin') {\n    return {\n      name: 'Admin',\n      permissions: ['read', 'write', 'delete']\n    };\n  } else if (type === 'user') {\n    return {\n      name: 'User',\n      permissions: ['read']\n    };\n  }\n}\n\nconst admin = createUser('admin');\nconst user = createUser('user');\n```",
        "prerequisites": [
          "basic-programming"
        ],
        "complexity": 5,
        "interviewRelevance": 7,
        "learningPath": "beginner",
        "requiredFor": [
          "advanced-concepts"
        ],
        "relatedQuestions": [],
        "relatedTasks": [],
        "tags": [
          "designpatterns",
          "creationalpatterns",
          "javascript"
        ],
        "technology": "JavaScript",
        "examples": [
          {
            "id": "example_constructor_pattern_1",
            "title": "Basic Constructor Pattern Example",
            "code": "function Person(name, age) {\n  this.name = name;\n  this.age = age;\n  this.sayHello = function() {\n    console.log(`Hello, my name is ${this.name}`);\n  };\n}\nconst john = new Person('John', 30);",
            "explanation": "This example demonstrates the basic usage of the constructor pattern in JavaScript to create objects with properties and methods.",
            "language": "javascript"
          },
          {
            "id": "example_factory_pattern_1",
            "title": "Basic Factory Pattern Example",
            "code": "function createUser(type) {\n  if (type === 'admin') {\n    return {name: 'Admin', permissions: ['read', 'write', 'delete']};\n  } else if (type === 'user') {\n    return {name: 'User', permissions: ['read']};\n  }\n}",
            "explanation": "This example shows how the factory pattern can be used to create objects with different configurations based on a given type.",
            "language": "javascript"
          }
        ]
      }
    ],
    "endLine": 200,
    "logicalBlockInfo": {
      "continuesToNextChunk": false,
      "suggestedEndLine": -1
    }
  },
  {
    "tasks": [],
    "endLine": 300,
    "id": "chunk_200_1749682140843",
    "processedDate": "2025-06-11T22:49:00.843Z",
    "completed": false,
    "theory": [],
    "logicalBlockInfo": {
      "continuesToNextChunk": false,
      "suggestedEndLine": 100
    },
    "questions": [],
    "startLine": 200
  },
  {
    "startLine": 300,
    "completed": false,
    "questions": [
      {
        "id": "question_behavioral_patterns_1",
        "topic": "Behavioral Patterns",
        "level": "medium",
        "type": "mcq",
        "question": "Which pattern is used to define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically?",
        "answer": "Observer Pattern",
        "options": [
          "Factory Pattern",
          "Singleton Pattern",
          "Observer Pattern",
          "Decorator Pattern"
        ],
        "analysisPoints": [
          "The Observer Pattern is used when you need a one-to-many relationship where changes in the state of one object cause all its dependent objects to be notified and updated automatically.",
          "Factory, Singleton, and Decorator patterns do not relate directly to this concept."
        ],
        "keyConcepts": [
          "Observer Pattern",
          "Dependency Management"
        ],
        "evaluationCriteria": [
          "Understanding of the Observer Pattern's purpose and usage",
          "Ability to differentiate between design patterns"
        ],
        "example": "\n```javascript\nclass Subject {\n  constructor() {\n    this.observers = [];\n  }\n  \n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n  \n  unsubscribe(observer) {\n    this.observers = this.observers.filter(obs => obs !== observer);\n  }\n  \n  notify(data) {\n    this.observers.forEach(observer => observer.update(data));\n  }\n}\n\nclass Observer {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  update(data) {\n    console.log(`${this.name} received: ${data}`);\n  }\n}",
        "tags": [
          "design_patterns",
          "behavioral"
        ],
        "prerequisites": [],
        "complexity": 7,
        "interviewFrequency": 8,
        "learningPath": "intermediate"
      },
      {
        "id": "question_behavioral_patterns_2",
        "topic": "Behavioral Patterns",
        "level": "hard",
        "type": "open",
        "question": "Implement a simple system using the Strategy Pattern to calculate shipping costs based on different strategies (FedEx, UPS, USPS). Provide code and explain your approach.",
        "answer": "To implement this, you would define a base class `ShippingStrategy` with subclasses for each strategy (`FedEx`, `UPS`, `USPS`), each having their own implementation of the `calculate` method. The `Shipping` class would have a reference to an instance of one of these strategies and delegate the calculation to it based on the order's weight.",
        "options": [],
        "analysisPoints": [
          "You need to correctly implement the Strategy Pattern with separate strategy classes for each shipping option.",
          "Ensure that the `Shipping` class can switch between different strategies dynamically, depending on the requirements.",
          "The solution should demonstrate a clear separation of concerns and the ability to extend functionality through new strategies without modifying existing code."
        ],
        "keyConcepts": [
          "Strategy Pattern",
          "Design Patterns"
        ],
        "evaluationCriteria": [
          "Ability to implement design patterns correctly",
          "Flexibility in strategy selection and delegation",
          "Correctness of the implementation, including proper use of inheritance and polymorphism."
        ],
        "example": "\n```javascript\nclass ShippingStrategy {\n  calculate(order) {}\n}\n\nclass FedEx extends ShippingStrategy {\n  calculate(order) {\n    return order.weight * 3;\n  }\n}\n\nclass UPS extends ShippingStrategy {\n  calculate(order) {\n    return order.weight * 4;\n  }\n}\n\nclass USPS extends ShippingStrategy {\n  calculate(order) {\n    return order.weight * 2.5;\n  }\n}\n\nclass Shipping {\n  constructor() {\n    this.strategy = null;\n  }\n  \n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n  \n  calculate(order) {\n    return this.strategy.calculate(order);\n  }\n}\n\nconst shipping = new Shipping();\nshipping.setStrategy(new FedEx());\nconsole.log(shipping.calculate({ weight: 5 })); // 15\nshipping.setStrategy(new UPS());\nconsole.log(shipping.calculate({ weight: 5 })); // 20\n```",
        "tags": [
          "design_patterns",
          "behavioral"
        ],
        "prerequisites": [],
        "complexity": 8,
        "interviewFrequency": 9,
        "learningPath": "advanced"
      }
    ],
    "tasks": [
      {
        "id": "task_strategy_pattern_implementation",
        "title": "Implement a Shipping Cost Calculator Using Strategy Pattern",
        "description": "\nYou are tasked with implementing a system that can calculate shipping costs based on different strategies (FedEx, UPS, USPS). Here are the requirements:\n\n1. Define a base class `ShippingStrategy` with at least three subclasses representing each strategy.\n2. Each strategy subclass should implement a `calculate` method that takes an order object and returns its calculated cost.\n3. Create a `Shipping` class that can switch between different strategies dynamically.\n4. Write a function to test the implementation by creating orders of varying weights using all three shipping methods.",
        "difficulty": "hard",
        "startingCode": "\nclass ShippingStrategy {\n  calculate(order) {}\n}\n\nclass FedEx extends ShippingStrategy {\n  calculate(order) {\n    return order.weight * 3;\n  }\n}\n\nclass UPS extends ShippingStrategy {\n  calculate(order) {\n    return order.weight * 4;\n  }\n}\n\nclass USPS extends ShippingStrategy {\n  calculate(order) {\n    return order.weight * 2.5;\n  }\n}\n\nclass Shipping {\n  constructor() {\n    this.strategy = null;\n  }\n  \n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n  \n  calculate(order) {\n    return this.strategy.calculate(order);\n  }\n}\n\nconst shipping = new Shipping();\n// TODO: Implement test cases for different order weights using all three strategies",
        "solutionCode": "\nclass ShippingStrategy {\n  calculate(order) {}\n}\n\nclass FedEx extends ShippingStrategy {\n  calculate(order) {\n    return order.weight * 3;\n  }\n}\n\nclass UPS extends ShippingStrategy {\n  calculate(order) {\n    return order.weight * 4;\n  }\n}\n\nclass USPS extends ShippingStrategy {\n  calculate(order) {\n    return order.weight * 2.5;\n  }\n}\n\nclass Shipping {\n  constructor() {\n    this.strategy = null;\n  }\n  \n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n  \n  calculate(order) {\n    return this.strategy.calculate(order);\n  }\n}\n\nconst shipping = new Shipping();\nshipping.setStrategy(new FedEx());\nconsole.log(shipping.calculate({ weight: 5 })); // 15\nshipping.setStrategy(new UPS());\nconsole.log(shipping.calculate({ weight: 5 })); // 20\nshipping.setStrategy(new USPS());\nconsole.log(shipping.calculate({ weight: 5 })); // 12.5\n",
        "testCases": [
          {
            "id": "test_case_fedex",
            "description": "Test FedEx strategy with order of weight 5.",
            "code": "console.log(shipping.calculate({ weight: 5 })); // Expected output: 15"
          },
          {
            "id": "test_case_ups",
            "description": "Test UPS strategy with order of weight 5.",
            "code": "console.log(shipping.calculate({ weight: 5 })); // Expected output: 20"
          },
          {
            "id": "test_case_usps",
            "description": "Test USPS strategy with order of weight 5.",
            "code": "console.log(shipping.calculate({ weight: 5 })); // Expected output: 12.5"
          }
        ],
        "hints": [
          "Start by defining the base class and its subclasses according to the Strategy Pattern structure.",
          "Implement a method in each subclass that calculates shipping cost based on the order's weight or other relevant parameters.",
          "In the `Shipping` class, use dependency injection to set the strategy at runtime."
        ],
        "tags": [
          "design_patterns",
          "strategy"
        ],
        "timeEstimate": 60,
        "prerequisites": [],
        "complexity": 8,
        "interviewRelevance": 9,
        "learningPath": "advanced",
        "relatedConcepts": []
      },
      {
        "id": "task_observer_pattern_implementation",
        "title": "Implement a Notification System Using the Observer Pattern",
        "description": "\nYou are tasked with implementing a simple notification system using the Observer Pattern. Here are the requirements:\n\n1. Define a `Subject` class that can subscribe, unsubscribe, and notify observers.\n2. Define an `Observer` class that has an update method to receive notifications from the subject.\n3. Implement functionality where a subject can send updates (like messages) to all its subscribed observers.\n4. Write tests to verify that subscribers are notified correctly when a new message is sent.",
        "difficulty": "medium",
        "startingCode": "\nclass Subject {\n  constructor() {\n    this.observers = [];\n  }\n  \n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n  \n  unsubscribe(observer) {\n    this.observers = this.observers.filter(obs => obs !== observer);\n  }\n  \n  notify(data) {\n    this.observers.forEach(observer => observer.update(data));\n  }\n}\n\nclass Observer {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  update(data) {\n    console.log(`${this.name} received: ${data}`);\n  }\n}",
        "solutionCode": "\nclass Subject {\n  constructor() {\n    this.observers = [];\n  }\n  \n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n  \n  unsubscribe(observer) {\n    this.observers = this.observers.filter(obs => obs !== observer);\n  }\n  \n  notify(data) {\n    this.observers.forEach(observer => observer.update(data));\n  }\n}\n\nclass Observer {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  update(data) {\n    console.log(`${this.name} received: ${data}`);\n  }\n}\n\nconst subject = new Subject();\nconst observer1 = new Observer('Observer 1');\nconst observer2 = new Observer('Observer 2');\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\nsubject.notify('Hello Observers!'); // Both observers should log their received messages.",
        "testCases": [
          {
            "id": "test_case_notification",
            "description": "Test notification functionality with two subscribers.",
            "code": "subject.notify('Hello Observers!');\n// Expected output: Observer 1 received: Hello Observers!\n// Observer 2 received: Hello Observers!"
          }
        ],
        "hints": [
          "Ensure that the `Subject` class can store and manage a list of observers.",
          "Implement methods to add and remove observers from this list.",
          "Trigger an update for all subscribed observers when something happens in the subject."
        ],
        "tags": [
          "design_patterns",
          "behavioral"
        ],
        "timeEstimate": 45,
        "prerequisites": [],
        "complexity": 7,
        "interviewRelevance": 8,
        "learningPath": "intermediate",
        "relatedConcepts": []
      }
    ],
    "endLine": 400,
    "logicalBlockInfo": {
      "suggestedEndLine": -1,
      "continuesToNextChunk": false
    },
    "id": "chunk_300_1749682205901",
    "theory": [
      {
        "id": "theory_behavioral_patterns",
        "title": "Behavioral Patterns",
        "content": "# Behavioral Patterns\n\nBehavioral patterns in software design are concerned with the interaction between objects, and how they communicate and collaborate to achieve common goals. These patterns focus on solving problems of algorithms and the assignment of responsibilities between objects.\n\n## Key Concepts\n- **Observer Pattern**: Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.\n- **Strategy Pattern**: Allows you to define a family of algorithms, encapsulate each as an object, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.\n\n## Implementation Examples\n### Observer Pattern\n```javascript\nclass Subject {\n  constructor() {\n    this.observers = [];\n  }\n  \n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n  \n  unsubscribe(observer) {\n    this.observers = this.observers.filter(obs => obs !== observer);\n  }\n  \n  notify(data) {\n    this.observers.forEach(observer => observer.update(data));\n  }\n}\n\nclass Observer {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  update(data) {\n    console.log(`${this.name} received: ${data}`);\n  }\n}\n\nconst subject = new Subject();\nconst observer1 = new Observer('Observer 1');\nconst observer2 = new Observer('Observer 2');\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\nsubject.notify('Hello Observers!');\n// Output: Observer 1 received: Hello Observers!\n// Observer 2 received: Hello Observers!\n```\n### Strategy Pattern\n```javascript\nclass ShippingStrategy {\n  calculate(order) {}\n}\n\nclass FedEx extends ShippingStrategy {\n  calculate(order) {\n    return order.weight * 3;\n  }\n}\n\nclass UPS extends ShippingStrategy {\n  calculate(order) {\n    return order.weight * 4;\n  }\n}\n\nclass USPS extends ShippingStrategy {\n  calculate(order) {\n    return order.weight * 2.5;\n  }\n}\n\nclass Shipping {\n  constructor() {\n    this.strategy = null;\n  }\n  \n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n  \n  calculate(order) {\n    return this.strategy.calculate(order);\n  }\n}\n\nconst shipping = new Shipping();\nshipping.setStrategy(new FedEx());\nconsole.log(shipping.calculate({ weight: 5 })); // 15\nshipping.setStrategy(new UPS());\nconsole.log(shipping.calculate({ weight: 5 })); // 20\n```\n",
        "prerequisites": [
          "basic-programming"
        ],
        "complexity": 7,
        "interviewRelevance": 9,
        "learningPath": "intermediate",
        "requiredFor": [
          "advanced-concepts"
        ],
        "relatedQuestions": [],
        "relatedTasks": [],
        "tags": [
          "design_patterns",
          "behavioral"
        ],
        "technology": "JavaScript",
        "examples": [
          {
            "id": "example_observer_pattern_1",
            "title": "Basic Observer Pattern Example",
            "code": "// Basic implementation of the Observer pattern\nclass Subject {\n  constructor() {\n    this.observers = [];\n  }\n  \n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n  \n  unsubscribe(observer) {\n    this.observers = this.observers.filter(obs => obs !== observer);\n  }\n  \n  notify(data) {\n    this.observers.forEach(observer => observer.update(data));\n  }\n}\n\nclass Observer {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  update(data) {\n    console.log(`${this.name} received: ${data}`);\n  }\n}",
            "explanation": "This example demonstrates the basic implementation of the Observer pattern, where a subject notifies its observers about changes in its state.",
            "language": "javascript"
          },
          {
            "id": "example_strategy_pattern_1",
            "title": "Basic Strategy Pattern Example",
            "code": "// Basic implementation of the Strategy pattern\nclass ShippingStrategy {\n  calculate(order) {}\n}\n\nclass FedEx extends ShippingStrategy {\n  calculate(order) {\n    return order.weight * 3;\n  }\n}\n\nclass UPS extends ShippingStrategy {\n  calculate(order) {\n    return order.weight * 4;\n  }\n}\n\nclass USPS extends ShippingStrategy {\n  calculate(order) {\n    return order.weight * 2.5;\n  }\n}\n\nclass Shipping {\n  constructor() {\n    this.strategy = null;\n  }\n  \n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n  \n  calculate(order) {\n    return this.strategy.calculate(order);\n  }\n}",
            "explanation": "This example shows how to implement the Strategy pattern with different shipping strategies (FedEx, UPS, USPS) that can be swapped in and out depending on the order.",
            "language": "javascript"
          }
        ]
      }
    ],
    "processedDate": "2025-06-11T22:50:05.901Z"
  },
  {
    "completed": false,
    "endLine": 500,
    "id": "chunk_400_1749682250152",
    "logicalBlockInfo": {
      "continuesToNextChunk": false,
      "suggestedEndLine": -1
    },
    "processedDate": "2025-06-11T22:50:50.152Z",
    "questions": [
      {
        "id": "question_data_types_2",
        "topic": "JavaScript Data Types",
        "level": "easy",
        "type": "mcq",
        "question": "What is the result of evaluating '4' + 5 in JavaScript?",
        "answer": "45",
        "options": [
          "9",
          "45",
          "NaN",
          "Error"
        ],
        "analysisPoints": [
          "In JavaScript, when a string and a number are concatenated using the + operator, the number is converted to a string.",
          "The '4' (string) is concatenated with 5 (number), resulting in '45' (string)."
        ],
        "keyConcepts": [
          "Data Types",
          "Type Conversion"
        ],
        "evaluationCriteria": [
          "Accuracy of understanding",
          "Completeness of answer",
          "Application of knowledge"
        ],
        "example": "",
        "tags": [
          "data-types",
          "javascript"
        ],
        "prerequisites": [],
        "complexity": 3,
        "interviewFrequency": 5,
        "learningPath": "beginner"
      },
      {
        "id": "question_type_conversion_2",
        "topic": "JavaScript Type Conversion",
        "level": "medium",
        "type": "open",
        "question": "Convert the string '123abc' to a number using JavaScript. Explain the process.",
        "answer": "To convert '123abc' to a number, you can use parseInt or parseFloat functions in JavaScript. For example, `parseInt('123abc')` will return 123, ignoring the non-numeric part 'abc'.",
        "options": [],
        "analysisPoints": [
          "Using `parseInt('123abc')` converts only the numeric prefix of the string to a number.",
          "ParseFloat would also work for this case but is less strict than parseInt."
        ],
        "keyConcepts": [
          "Type Conversion",
          "Parsing"
        ],
        "evaluationCriteria": [
          "Accuracy of understanding",
          "Completeness of answer",
          "Application of knowledge"
        ],
        "example": "",
        "tags": [
          "type-conversion",
          "javascript"
        ],
        "prerequisites": [],
        "complexity": 5,
        "interviewFrequency": 7,
        "learningPath": "intermediate"
      }
    ],
    "startLine": 400,
    "tasks": [
      {
        "id": "task_data_types_implementation_1",
        "title": "Implement Data Type Handling Function",
        "description": "Create a function that handles different data types and performs basic conversions. Include tests for various inputs to ensure correctness.",
        "difficulty": "easy",
        "startingCode": "function handleDataTypes(input) {\n  // Implement conversion logic here\n  return input;\n}",
        "solutionCode": "function handleDataTypes(input) {\n  if (typeof input === 'string') {\n    return parseInt(input, 10);\n  } else if (typeof input === 'number') {\n    return String(input);\n  }\n  // Add more type conversions as needed\n}",
        "testCases": [
          "Test with string input: handleDataTypes('42') should return 42",
          "Test with number input: handleDataTypes(42) should convert to '42'",
          "Test with mixed input: handleDataTypes('100px') should correctly parse the numeric part"
        ],
        "hints": [
          "Consider using conditional statements to check the type of the input before conversion.",
          "Ensure you handle edge cases, such as non-numeric strings and unexpected inputs."
        ],
        "tags": [
          "data-types",
          "conversion",
          "javascript"
        ],
        "timeEstimate": 20,
        "prerequisites": [
          "basics-of-javascript"
        ],
        "complexity": 4,
        "interviewRelevance": 6,
        "learningPath": "beginner",
        "relatedConcepts": []
      }
    ],
    "theory": [
      {
        "id": "theory_data_types",
        "title": "JavaScript Data Types and Type Conversion",
        "content": "# JavaScript Data Types and Type Conversion\n\n## Core Concepts\n- Primitive types: String, Number, BigInt, Boolean, Undefined, Symbol, Null\n- Complex type: Object (arrays, functions, etc.)\n\n### Example Code Snippet\n```javascript\nlet firstObj = { name: 'Hello' };  \nlet secondObj = firstObj;  \nfirstObj = { name: 'Bye' };  \nconsole.log(secondObj.name); // Output: Hello\n```\n\n## Type Conversion\n### parseInt() and parseFloat() Examples\n```javascript\n// parseInt(string, radix) - converts string to integer\n// The radix parameter specifies the base of the number system (usually 10 for decimal)\nparseInt('42'); // 42\nparseInt('42px'); // 42 - extracts numbers until it encounters a non-numeric character\nparseInt('-50px'); // -50 - handles negative numbers correctly\nparseInt('0xFF', 16); // 255 - parses hexadecimal with radix 16\n\n// parseFloat() - converts string to floating point number\nparseFloat('3.14'); // 3.14\nparseFloat('3.14 meters'); // 3.14\n```\n\n### Other Conversion Methods Examples\n```javascript\n// Number() - stricter than parseInt, doesn't allow trailing non-numeric characters\nNumber('42'); // 42\nNumber('42px'); // NaN - doesn't allow non-numeric characters\n\n// String() - converts to string\nString(42); // '42'\n\n// Boolean() - converts to boolean\nBoolean(0); // false\nBoolean(1); // true\nBoolean(''); // false\nBoolean('hello'); // true\n```\n\n### Operators Example\n```javascript\ni++ and ++i are like i+=1  \nfor (var i = 0; i < myVar.length; i+3) {}\n```\n\n## JavaScript Behavior and Edge Cases\nUnderstanding unexpected behavior and edge cases is crucial for debugging and writing robust JavaScript code.\n\n### Object Property Access Example\n```javascript\nvar obj = {'1': 0, 1: 1, 0: 2};\nobj['1']; // 1 (numeric key '1' is equivalent to 1)\nobj[1];   // 1 (same property)\n```\n\n### Mixed Type Arithmetic Example\n```javascript\n4 - \"5\" + 0xf - \"1e1\"; // 4\n// Breakdown:\n// 4 - \"5\" → 4 - 5 = -1 (string converted to number in subtraction)\n// -1 + 0xf → -1 + 15 = 14 (0xf is hexadecimal for 15)\n// 14 - \"1e1\" → 14 - 10 = 4 (\"1e1\" is scientific notation for 10)\n```\n\n### Logical Operators Example\n```javascript\n0 || \"\" || undefined || 23 || true || false; // 23 (first truthy value)\n```\n\n### Logical Operators with Variables Example\n```javascript\nlet a = 5, b = 10;\n!!(a && b); // true (converts result to boolean)\n(a && b);   // 10 (returns last evaluated operand)\n```\n\n### Array Operations Example\n```javascript\n[] + false + true; // \"falsetrue\" (empty array coerced to empty string)\n```",
        "prerequisites": [
          "basics-of-programming"
        ],
        "complexity": 6,
        "interviewRelevance": 7,
        "learningPath": "intermediate",
        "requiredFor": [
          "advanced-concepts"
        ],
        "relatedQuestions": [
          {
            "id": "question_data_types_1",
            "topic": "JavaScript Data Types",
            "level": "easy",
            "type": "mcq",
            "question": "Which of the following is a complex data type in JavaScript?",
            "options": [
              "String",
              "Number",
              "Object",
              "Boolean"
            ],
            "answer": "Object",
            "analysisPoints": [
              "Objects are considered complex data types because they can hold multiple values and properties.",
              "Strings, Numbers, and Booleans are all primitive data types."
            ],
            "keyConcepts": [
              "Data Types",
              "Primitive vs Complex"
            ],
            "tags": [
              "data-types",
              "javascript"
            ],
            "complexity": 5,
            "interviewFrequency": 6,
            "learningPath": "beginner"
          },
          {
            "id": "question_type_conversion_1",
            "topic": "JavaScript Type Conversion",
            "level": "medium",
            "type": "open",
            "question": "Explain how parseInt and parseFloat handle the input '42px'.",
            "answer": "parseInt('42px') will convert the string '42px' to the integer 42, ignoring the trailing 'px'. parseFloat('42px'), however, can parse only up to the point where it encounters a non-numeric character, resulting in 42.0.",
            "analysisPoints": [
              "parseInt stops parsing when it finds a non-numeric character and converts what has been parsed so far.",
              "parseFloat continues parsing until it reaches the end of the string or encounters a non-numeric character."
            ],
            "keyConcepts": [
              "Type Conversion",
              "Parsing"
            ],
            "tags": [
              "type-conversion",
              "javascript"
            ],
            "complexity": 7,
            "interviewFrequency": 8,
            "learningPath": "intermediate"
          }
        ],
        "relatedTasks": [
          {
            "id": "task_data_types_implementation",
            "title": "Implement Data Types and Conversion Tasks",
            "description": "Create a function that converts different data types and handles type conversions. Include tests for various inputs to ensure correctness.",
            "difficulty": "medium",
            "startingCode": "function handleDataTypes(input) {\n  // Implement conversion logic here\n  return input;\n}",
            "solutionCode": "function handleDataTypes(input) {\n  if (typeof input === 'string') {\n    return parseInt(input, 10);\n  } else if (typeof input === 'number') {\n    return String(input);\n  }\n  // Add more type conversions as needed\n}",
            "testCases": [
              "Test with string input: handleDataTypes('42') should return 42",
              "Test with number input: handleDataTypes(42) should convert to '42'",
              "Test with mixed input: handleDataTypes('100px') should correctly parse the numeric part"
            ],
            "hints": [
              "Consider using conditional statements to check the type of the input before conversion.",
              "Ensure you handle edge cases, such as non-numeric strings and unexpected inputs."
            ],
            "tags": [
              "data-types",
              "conversion",
              "javascript"
            ],
            "timeEstimate": 30,
            "prerequisites": [
              "basics-of-javascript"
            ],
            "complexity": 6,
            "interviewRelevance": 7,
            "learningPath": "intermediate"
          }
        ],
        "tags": [
          "data-types",
          "type-conversion",
          "javascript"
        ],
        "technology": "JavaScript",
        "examples": [
          {
            "id": "example_data_types_1",
            "title": "Primitive and Complex Data Types Example",
            "code": "let firstObj = { name: 'Hello' };  \nlet secondObj = firstObj;  \nfirstObj = { name: 'Bye' };  \nconsole.log(secondObj.name); // Output: Hello",
            "explanation": "This example demonstrates the difference between primitive and complex data types in JavaScript, highlighting how changes to one do not affect the other.",
            "language": "javascript"
          },
          {
            "id": "example_type_conversion_1",
            "title": "parseInt and parseFloat Example",
            "code": "// parseInt(string, radix) - converts string to integer\n// The radix parameter specifies the base of the number system (usually 10 for decimal)\nconsole.log(parseInt('42')); // 42\nconsole.log(parseInt('42px')); // 42\nconsole.log(parseInt('-50px')); // -50\nconsole.log(parseInt('0xFF', 16)); // 255",
            "explanation": "This example shows how parseInt and parseFloat handle different string inputs, including those with non-numeric characters.",
            "language": "javascript"
          },
          {
            "id": "example_operators_1",
            "title": "Understanding Postfix and Prefix Increment Operators",
            "code": "i++ and ++i are like i+=1  \nfor (var i = 0; i < myVar.length; i+3) {}",
            "explanation": "This snippet explains the difference between postfix (i++) and prefix (++i) increment operators, emphasizing their effect on variable values.",
            "language": "javascript"
          }
        ]
      }
    ]
  }
]